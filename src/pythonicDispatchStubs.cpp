#include "pythonic/pythonicDispatchForwardDecls.hpp"
#include "pythonic/pythonicVars.hpp"
#include "pythonic/pythonicError.hpp"
#include "pythonic/pythonicOverflow.hpp"
#include "pythonic/pythonicPromotion.hpp"
#include <stdexcept>

#include <algorithm>

namespace pythonic {
namespace dispatch {
// generated stubs live in pythonic::dispatch

// Stub definitions for add
var add__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'none'");
}
var add__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'int'");
}
var add__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'float'");
}
var add__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'string'");
}
var add__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'bool'");
}
var add__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'double'");
}
var add__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'long'");
}
var add__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'long_long'");
}
var add__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'long_double'");
}
var add__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'uint'");
}
var add__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'ulong'");
}
var add__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'ulong_long'");
}
var add__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'list'");
}
var add__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'set'");
}
var add__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'dict'");
}
var add__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'orderedset'");
}
var add__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'ordereddict'");
}
var add__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'none' and 'graph'");
}
var add__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'none'");
}
var add__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'string'");
}
var add__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'list'");
}
var add__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'set'");
}
var add__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'dict'");
}
var add__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'orderedset'");
}
var add__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'ordereddict'");
}
var add__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'int' and 'graph'");
}
var add__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'none'");
}
var add__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'string'");
}
var add__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'list'");
}
var add__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'set'");
}
var add__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'dict'");
}
var add__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'orderedset'");
}
var add__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'ordereddict'");
}
var add__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'float' and 'graph'");
}
var add__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'none'");
}
var add__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'int'");
}
var add__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'float'");
}
var add__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() + b.var_get<std::string>());
}
var add__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() + (b.var_get<bool>() ? std::string("true") : std::string("false")));
}
var add__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'double'");
}
var add__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'long'");
}
var add__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'long_long'");
}
var add__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'long_double'");
}
var add__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'uint'");
}
var add__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'ulong'");
}
var add__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'ulong_long'");
}
var add__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'list'");
}
var add__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'set'");
}
var add__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'dict'");
}
var add__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'orderedset'");
}
var add__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'ordereddict'");
}
var add__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'string' and 'graph'");
}
var add__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'bool' and 'none'");
}
var add__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var((a.var_get<bool>() ? std::string("true") : std::string("false")) + b.var_get<std::string>());
}
var add__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'bool' and 'list'");
}
var add__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'bool' and 'set'");
}
var add__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'bool' and 'dict'");
}
var add__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'bool' and 'orderedset'");
}
var add__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'bool' and 'ordereddict'");
}
var add__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'bool' and 'graph'");
}
var add__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'none'");
}
var add__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'string'");
}
var add__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'list'");
}
var add__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'set'");
}
var add__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'dict'");
}
var add__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'orderedset'");
}
var add__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'ordereddict'");
}
var add__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'double' and 'graph'");
}
var add__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'none'");
}
var add__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'string'");
}
var add__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'list'");
}
var add__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'set'");
}
var add__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'dict'");
}
var add__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'orderedset'");
}
var add__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'ordereddict'");
}
var add__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long' and 'graph'");
}
var add__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'none'");
}
var add__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'string'");
}
var add__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'list'");
}
var add__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'set'");
}
var add__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'dict'");
}
var add__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'orderedset'");
}
var add__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'ordereddict'");
}
var add__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_long' and 'graph'");
}
var add__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'none'");
}
var add__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'string'");
}
var add__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'list'");
}
var add__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'set'");
}
var add__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'dict'");
}
var add__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'orderedset'");
}
var add__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'ordereddict'");
}
var add__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'long_double' and 'graph'");
}
var add__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'none'");
}
var add__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'string'");
}
var add__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'list'");
}
var add__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'set'");
}
var add__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'dict'");
}
var add__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'orderedset'");
}
var add__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'ordereddict'");
}
var add__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'uint' and 'graph'");
}
var add__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'none'");
}
var add__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'string'");
}
var add__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'list'");
}
var add__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'set'");
}
var add__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'dict'");
}
var add__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'orderedset'");
}
var add__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'ordereddict'");
}
var add__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong' and 'graph'");
}
var add__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'none'");
}
var add__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'string'");
}
var add__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric add with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la + lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::add_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::add_wrap(la, lb);
        return var(res);
    } else {
        // Promote: compute in long double then smart-promote
        long double result = static_cast<long double>(la) + static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var add__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'list'");
}
var add__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'set'");
}
var add__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'dict'");
}
var add__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'orderedset'");
}
var add__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'ordereddict'");
}
var add__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ulong_long' and 'graph'");
}
var add__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'none'");
}
var add__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'int'");
}
var add__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'float'");
}
var add__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'string'");
}
var add__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'bool'");
}
var add__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'double'");
}
var add__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'long'");
}
var add__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'long_long'");
}
var add__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'long_double'");
}
var add__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'uint'");
}
var add__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'ulong'");
}
var add__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'ulong_long'");
}
var add__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& al = a.var_get<pythonic::vars::List>();
    const auto& bl = b.var_get<pythonic::vars::List>();
    pythonic::vars::List res; res.reserve(al.size() + bl.size());
    res.insert(res.end(), al.begin(), al.end());
    res.insert(res.end(), bl.begin(), bl.end());
    return var(std::move(res));
}
var add__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'set'");
}
var add__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'dict'");
}
var add__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'orderedset'");
}
var add__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'ordereddict'");
}
var add__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'list' and 'graph'");
}
var add__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'none'");
}
var add__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'int'");
}
var add__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'float'");
}
var add__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'string'");
}
var add__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'bool'");
}
var add__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'double'");
}
var add__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'long'");
}
var add__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'long_long'");
}
var add__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'long_double'");
}
var add__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'uint'");
}
var add__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'ulong'");
}
var add__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'ulong_long'");
}
var add__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'list'");
}
var add__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'set'");
}
var add__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'dict'");
}
var add__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'orderedset'");
}
var add__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'ordereddict'");
}
var add__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'set' and 'graph'");
}
var add__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'none'");
}
var add__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'int'");
}
var add__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'float'");
}
var add__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'string'");
}
var add__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'bool'");
}
var add__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'double'");
}
var add__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'long'");
}
var add__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'long_long'");
}
var add__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'long_double'");
}
var add__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'uint'");
}
var add__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'ulong'");
}
var add__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'ulong_long'");
}
var add__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'list'");
}
var add__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'set'");
}
var add__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'dict'");
}
var add__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'orderedset'");
}
var add__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'ordereddict'");
}
var add__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'dict' and 'graph'");
}
var add__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'none'");
}
var add__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'int'");
}
var add__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'float'");
}
var add__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'string'");
}
var add__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'bool'");
}
var add__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'double'");
}
var add__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'long'");
}
var add__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'long_long'");
}
var add__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'long_double'");
}
var add__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'uint'");
}
var add__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'ulong'");
}
var add__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'ulong_long'");
}
var add__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'list'");
}
var add__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'set'");
}
var add__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'dict'");
}
var add__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'orderedset'");
}
var add__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'ordereddict'");
}
var add__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'orderedset' and 'graph'");
}
var add__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'none'");
}
var add__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'int'");
}
var add__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'float'");
}
var add__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'string'");
}
var add__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'bool'");
}
var add__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'double'");
}
var add__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'long'");
}
var add__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'long_long'");
}
var add__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'long_double'");
}
var add__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'uint'");
}
var add__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'ulong'");
}
var add__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'ulong_long'");
}
var add__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'list'");
}
var add__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'set'");
}
var add__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'dict'");
}
var add__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'orderedset'");
}
var add__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'ordereddict'");
}
var add__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'ordereddict' and 'graph'");
}
var add__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'none'");
}
var add__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'int'");
}
var add__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'float'");
}
var add__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'string'");
}
var add__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'bool'");
}
var add__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'double'");
}
var add__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'long'");
}
var add__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'long_long'");
}
var add__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'long_double'");
}
var add__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'uint'");
}
var add__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'ulong'");
}
var add__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'ulong_long'");
}
var add__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'list'");
}
var add__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'set'");
}
var add__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'dict'");
}
var add__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'orderedset'");
}
var add__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'ordereddict'");
}
var add__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for +: 'graph' and 'graph'");
}

// Stub definitions for sub
var sub__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'none'");
}
var sub__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'int'");
}
var sub__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'float'");
}
var sub__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'string'");
}
var sub__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'bool'");
}
var sub__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'double'");
}
var sub__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'long'");
}
var sub__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'long_long'");
}
var sub__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'long_double'");
}
var sub__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'uint'");
}
var sub__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'ulong'");
}
var sub__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'ulong_long'");
}
var sub__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'list'");
}
var sub__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'set'");
}
var sub__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'dict'");
}
var sub__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'orderedset'");
}
var sub__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'ordereddict'");
}
var sub__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'none' and 'graph'");
}
var sub__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'none'");
}
var sub__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'string'");
}
var sub__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'list'");
}
var sub__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'set'");
}
var sub__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'dict'");
}
var sub__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'orderedset'");
}
var sub__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'ordereddict'");
}
var sub__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'int' and 'graph'");
}
var sub__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'none'");
}
var sub__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'string'");
}
var sub__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'list'");
}
var sub__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'set'");
}
var sub__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'dict'");
}
var sub__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'orderedset'");
}
var sub__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'ordereddict'");
}
var sub__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'float' and 'graph'");
}
var sub__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'none'");
}
var sub__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'int'");
}
var sub__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'float'");
}
var sub__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'string'");
}
var sub__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'bool'");
}
var sub__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'double'");
}
var sub__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'long'");
}
var sub__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'long_long'");
}
var sub__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'long_double'");
}
var sub__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'uint'");
}
var sub__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'ulong'");
}
var sub__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'ulong_long'");
}
var sub__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'list'");
}
var sub__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'set'");
}
var sub__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'dict'");
}
var sub__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'orderedset'");
}
var sub__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'ordereddict'");
}
var sub__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'string' and 'graph'");
}
var sub__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'none'");
}
var sub__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'string'");
}
var sub__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'list'");
}
var sub__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'set'");
}
var sub__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'dict'");
}
var sub__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'orderedset'");
}
var sub__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'ordereddict'");
}
var sub__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'bool' and 'graph'");
}
var sub__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'none'");
}
var sub__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'string'");
}
var sub__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'list'");
}
var sub__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'set'");
}
var sub__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'dict'");
}
var sub__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'orderedset'");
}
var sub__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'ordereddict'");
}
var sub__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'double' and 'graph'");
}
var sub__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'none'");
}
var sub__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'string'");
}
var sub__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'list'");
}
var sub__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'set'");
}
var sub__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'dict'");
}
var sub__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'orderedset'");
}
var sub__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'ordereddict'");
}
var sub__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long' and 'graph'");
}
var sub__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'none'");
}
var sub__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'string'");
}
var sub__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'list'");
}
var sub__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'set'");
}
var sub__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'dict'");
}
var sub__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'orderedset'");
}
var sub__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'ordereddict'");
}
var sub__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_long' and 'graph'");
}
var sub__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'none'");
}
var sub__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'string'");
}
var sub__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'list'");
}
var sub__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'set'");
}
var sub__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'dict'");
}
var sub__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'orderedset'");
}
var sub__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'ordereddict'");
}
var sub__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'long_double' and 'graph'");
}
var sub__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'none'");
}
var sub__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'string'");
}
var sub__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'list'");
}
var sub__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'set'");
}
var sub__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'dict'");
}
var sub__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'orderedset'");
}
var sub__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'ordereddict'");
}
var sub__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'uint' and 'graph'");
}
var sub__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'none'");
}
var sub__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'string'");
}
var sub__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'list'");
}
var sub__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'set'");
}
var sub__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'dict'");
}
var sub__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'orderedset'");
}
var sub__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'ordereddict'");
}
var sub__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong' and 'graph'");
}
var sub__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'none'");
}
var sub__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'string'");
}
var sub__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric sub with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la - lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::sub_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::sub_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) - static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, true);
    }
}
var sub__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'list'");
}
var sub__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'set'");
}
var sub__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'dict'");
}
var sub__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'orderedset'");
}
var sub__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'ordereddict'");
}
var sub__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ulong_long' and 'graph'");
}
var sub__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'none'");
}
var sub__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'int'");
}
var sub__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'float'");
}
var sub__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'string'");
}
var sub__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'bool'");
}
var sub__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'double'");
}
var sub__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'long'");
}
var sub__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'long_long'");
}
var sub__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'long_double'");
}
var sub__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'uint'");
}
var sub__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'ulong'");
}
var sub__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'ulong_long'");
}
var sub__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& al = a.var_get<pythonic::vars::List>();
    const auto& bl = b.var_get<pythonic::vars::List>();
    pythonic::vars::List res;
    pythonic::vars::Set bs(bl.begin(), bl.end());
    for(const auto& item : al) {
        if(bs.find(item) == bs.end()) res.push_back(item);
    }
    return var(std::move(res));
}
var sub__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'set'");
}
var sub__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'dict'");
}
var sub__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'orderedset'");
}
var sub__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'ordereddict'");
}
var sub__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'list' and 'graph'");
}
var sub__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'none'");
}
var sub__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'int'");
}
var sub__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'float'");
}
var sub__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'string'");
}
var sub__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'bool'");
}
var sub__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'double'");
}
var sub__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'long'");
}
var sub__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'long_long'");
}
var sub__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'long_double'");
}
var sub__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'uint'");
}
var sub__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'ulong'");
}
var sub__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'ulong_long'");
}
var sub__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'list'");
}
var sub__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& as = a.var_get<pythonic::vars::Set>();
    const auto& bs = b.var_get<pythonic::vars::Set>();
    pythonic::vars::Set res;
    for(const auto& item : as) {
        if(bs.find(item) == bs.end()) res.insert(item);
    }
    return var(std::move(res));
}
var sub__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'dict'");
}
var sub__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'orderedset'");
}
var sub__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'ordereddict'");
}
var sub__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'set' and 'graph'");
}
var sub__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'none'");
}
var sub__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'int'");
}
var sub__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'float'");
}
var sub__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'string'");
}
var sub__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'bool'");
}
var sub__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'double'");
}
var sub__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'long'");
}
var sub__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'long_long'");
}
var sub__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'long_double'");
}
var sub__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'uint'");
}
var sub__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'ulong'");
}
var sub__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'ulong_long'");
}
var sub__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'list'");
}
var sub__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'set'");
}
var sub__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& ad = a.var_get<pythonic::vars::Dict>();
    const auto& bd = b.var_get<pythonic::vars::Dict>();
    pythonic::vars::Dict res;
    for(const auto& [k, v] : ad) {
        if(bd.find(k) == bd.end()) res[k] = v;
    }
    return var(std::move(res));
}
var sub__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'orderedset'");
}
var sub__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'ordereddict'");
}
var sub__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'dict' and 'graph'");
}
var sub__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'none'");
}
var sub__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'int'");
}
var sub__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'float'");
}
var sub__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'string'");
}
var sub__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'bool'");
}
var sub__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'double'");
}
var sub__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'long'");
}
var sub__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'long_long'");
}
var sub__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'long_double'");
}
var sub__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'uint'");
}
var sub__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'ulong'");
}
var sub__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'ulong_long'");
}
var sub__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'list'");
}
var sub__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'set'");
}
var sub__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'dict'");
}
var sub__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& a_cont = a.var_get<pythonic::vars::OrderedSet>();
    const auto& b_cont = b.var_get<pythonic::vars::OrderedSet>();
    pythonic::vars::OrderedSet res;
    // Merge-like difference preserving order
    auto it_a = a_cont.begin();
    auto it_b = b_cont.begin();
    while (it_a != a_cont.end() && it_b != b_cont.end()) {
        if (*it_a < *it_b) {
            res.insert(*it_a);
            ++it_a;
        } else if (*it_b < *it_a) {
            ++it_b;
        } else {
            // Equal, skip
            ++it_a; ++it_b;
        }
    }
    while (it_a != a_cont.end()) {
        res.insert(*it_a);
        ++it_a;
    }
    return var(std::move(res));
}
var sub__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'ordereddict'");
}
var sub__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'orderedset' and 'graph'");
}
var sub__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'none'");
}
var sub__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'int'");
}
var sub__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'float'");
}
var sub__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'string'");
}
var sub__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'bool'");
}
var sub__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'double'");
}
var sub__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'long'");
}
var sub__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'long_long'");
}
var sub__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'long_double'");
}
var sub__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'uint'");
}
var sub__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'ulong'");
}
var sub__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'ulong_long'");
}
var sub__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'list'");
}
var sub__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'set'");
}
var sub__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'dict'");
}
var sub__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'orderedset'");
}
var sub__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& ad = a.var_get<pythonic::vars::OrderedDict>();
    const auto& bd = b.var_get<pythonic::vars::OrderedDict>();
    pythonic::vars::OrderedDict res;
    for(const auto& val : ad) {
        if(bd.find(val.first) == bd.end()) res.insert(val);
    }
    return var(std::move(res));
}
var sub__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'ordereddict' and 'graph'");
}
var sub__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'none'");
}
var sub__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'int'");
}
var sub__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'float'");
}
var sub__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'string'");
}
var sub__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'bool'");
}
var sub__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'double'");
}
var sub__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'long'");
}
var sub__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'long_long'");
}
var sub__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'long_double'");
}
var sub__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'uint'");
}
var sub__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'ulong'");
}
var sub__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'ulong_long'");
}
var sub__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'list'");
}
var sub__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'set'");
}
var sub__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'dict'");
}
var sub__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'orderedset'");
}
var sub__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'ordereddict'");
}
var sub__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for -: 'graph' and 'graph'");
}

// Stub definitions for mul
var mul__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'none'");
}
var mul__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'int'");
}
var mul__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'float'");
}
var mul__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'string'");
}
var mul__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'bool'");
}
var mul__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'double'");
}
var mul__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'long'");
}
var mul__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'long_long'");
}
var mul__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'long_double'");
}
var mul__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'uint'");
}
var mul__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'ulong'");
}
var mul__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'ulong_long'");
}
var mul__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'list'");
}
var mul__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'set'");
}
var mul__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'dict'");
}
var mul__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'orderedset'");
}
var mul__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'ordereddict'");
}
var mul__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'none' and 'graph'");
}
var mul__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'int' and 'none'");
}
var mul__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    std::string s = b.var_get<std::string>();
    long long n = (long long)a.var_get<int>();
    if(n <= 0) return var(std::string(""));
    std::string res; res.reserve(s.size() * n);
    for(long long i=0; i<n; ++i) res += s;
    return var(res);
}
var mul__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& lst = b.var_get<pythonic::vars::List>();
    long long n = (long long)a.var_get<int>();
    if(n <= 0) return var(pythonic::vars::List{});
    pythonic::vars::List res; res.reserve(lst.size() * n);
    for(long long i=0; i<n; ++i) res.insert(res.end(), lst.begin(), lst.end());
    return var(std::move(res));
}
var mul__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'int' and 'set'");
}
var mul__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'int' and 'dict'");
}
var mul__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'int' and 'orderedset'");
}
var mul__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'int' and 'ordereddict'");
}
var mul__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'int' and 'graph'");
}
var mul__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'none'");
}
var mul__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'string'");
}
var mul__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'list'");
}
var mul__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'set'");
}
var mul__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'dict'");
}
var mul__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'orderedset'");
}
var mul__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'ordereddict'");
}
var mul__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'float' and 'graph'");
}
var mul__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'none'");
}
var mul__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    std::string s = a.var_get<std::string>();
    long long n = (long long)b.var_get<int>();
    if(n <= 0) return var(std::string(""));
    std::string res; res.reserve(s.size() * n);
    for(long long i=0; i<n; ++i) res += s;
    return var(res);
}
var mul__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'float'");
}
var mul__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'string'");
}
var mul__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'bool'");
}
var mul__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'double'");
}
var mul__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    std::string s = a.var_get<std::string>();
    long long n = (long long)b.var_get<long>();
    if(n <= 0) return var(std::string(""));
    std::string res; res.reserve(s.size() * n);
    for(long long i=0; i<n; ++i) res += s;
    return var(res);
}
var mul__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    std::string s = a.var_get<std::string>();
    long long n = (long long)b.var_get<long long>();
    if(n <= 0) return var(std::string(""));
    std::string res; res.reserve(s.size() * n);
    for(long long i=0; i<n; ++i) res += s;
    return var(res);
}
var mul__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'long_double'");
}
var mul__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'uint'");
}
var mul__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'ulong'");
}
var mul__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'ulong_long'");
}
var mul__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'list'");
}
var mul__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'set'");
}
var mul__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'dict'");
}
var mul__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'orderedset'");
}
var mul__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'ordereddict'");
}
var mul__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'string' and 'graph'");
}
var mul__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'none'");
}
var mul__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'string'");
}
var mul__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'list'");
}
var mul__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'set'");
}
var mul__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'dict'");
}
var mul__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'orderedset'");
}
var mul__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'ordereddict'");
}
var mul__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'bool' and 'graph'");
}
var mul__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'none'");
}
var mul__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'string'");
}
var mul__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'list'");
}
var mul__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'set'");
}
var mul__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'dict'");
}
var mul__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'orderedset'");
}
var mul__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'ordereddict'");
}
var mul__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'double' and 'graph'");
}
var mul__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long' and 'none'");
}
var mul__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    std::string s = b.var_get<std::string>();
    long long n = (long long)a.var_get<long>();
    if(n <= 0) return var(std::string(""));
    std::string res; res.reserve(s.size() * n);
    for(long long i=0; i<n; ++i) res += s;
    return var(res);
}
var mul__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& lst = b.var_get<pythonic::vars::List>();
    long long n = (long long)a.var_get<long>();
    if(n <= 0) return var(pythonic::vars::List{});
    pythonic::vars::List res; res.reserve(lst.size() * n);
    for(long long i=0; i<n; ++i) res.insert(res.end(), lst.begin(), lst.end());
    return var(std::move(res));
}
var mul__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long' and 'set'");
}
var mul__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long' and 'dict'");
}
var mul__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long' and 'orderedset'");
}
var mul__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long' and 'ordereddict'");
}
var mul__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long' and 'graph'");
}
var mul__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_long' and 'none'");
}
var mul__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    std::string s = b.var_get<std::string>();
    long long n = (long long)a.var_get<long long>();
    if(n <= 0) return var(std::string(""));
    std::string res; res.reserve(s.size() * n);
    for(long long i=0; i<n; ++i) res += s;
    return var(res);
}
var mul__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& lst = b.var_get<pythonic::vars::List>();
    long long n = (long long)a.var_get<long long>();
    if(n <= 0) return var(pythonic::vars::List{});
    pythonic::vars::List res; res.reserve(lst.size() * n);
    for(long long i=0; i<n; ++i) res.insert(res.end(), lst.begin(), lst.end());
    return var(std::move(res));
}
var mul__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_long' and 'set'");
}
var mul__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_long' and 'dict'");
}
var mul__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_long' and 'orderedset'");
}
var mul__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_long' and 'ordereddict'");
}
var mul__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_long' and 'graph'");
}
var mul__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'none'");
}
var mul__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'string'");
}
var mul__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'list'");
}
var mul__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'set'");
}
var mul__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'dict'");
}
var mul__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'orderedset'");
}
var mul__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'ordereddict'");
}
var mul__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'long_double' and 'graph'");
}
var mul__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'none'");
}
var mul__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'string'");
}
var mul__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'list'");
}
var mul__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'set'");
}
var mul__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'dict'");
}
var mul__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'orderedset'");
}
var mul__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'ordereddict'");
}
var mul__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'uint' and 'graph'");
}
var mul__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'none'");
}
var mul__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'string'");
}
var mul__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'list'");
}
var mul__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'set'");
}
var mul__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'dict'");
}
var mul__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'orderedset'");
}
var mul__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'ordereddict'");
}
var mul__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong' and 'graph'");
}
var mul__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'none'");
}
var mul__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'string'");
}
var mul__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric mul with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la * lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mul_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mul_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) * static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mul__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'list'");
}
var mul__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'set'");
}
var mul__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'dict'");
}
var mul__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'orderedset'");
}
var mul__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'ordereddict'");
}
var mul__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ulong_long' and 'graph'");
}
var mul__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'none'");
}
var mul__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& lst = a.var_get<pythonic::vars::List>();
    long long n = (long long)b.var_get<int>();
    if(n <= 0) return var(pythonic::vars::List{});
    pythonic::vars::List res; res.reserve(lst.size() * n);
    for(long long i=0; i<n; ++i) res.insert(res.end(), lst.begin(), lst.end());
    return var(std::move(res));
}
var mul__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'float'");
}
var mul__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'string'");
}
var mul__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'bool'");
}
var mul__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'double'");
}
var mul__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& lst = a.var_get<pythonic::vars::List>();
    long long n = (long long)b.var_get<long>();
    if(n <= 0) return var(pythonic::vars::List{});
    pythonic::vars::List res; res.reserve(lst.size() * n);
    for(long long i=0; i<n; ++i) res.insert(res.end(), lst.begin(), lst.end());
    return var(std::move(res));
}
var mul__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto& lst = a.var_get<pythonic::vars::List>();
    long long n = (long long)b.var_get<long long>();
    if(n <= 0) return var(pythonic::vars::List{});
    pythonic::vars::List res; res.reserve(lst.size() * n);
    for(long long i=0; i<n; ++i) res.insert(res.end(), lst.begin(), lst.end());
    return var(std::move(res));
}
var mul__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'long_double'");
}
var mul__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'uint'");
}
var mul__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'ulong'");
}
var mul__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'ulong_long'");
}
var mul__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'list'");
}
var mul__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'set'");
}
var mul__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'dict'");
}
var mul__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'orderedset'");
}
var mul__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'ordereddict'");
}
var mul__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'list' and 'graph'");
}
var mul__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'none'");
}
var mul__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'int'");
}
var mul__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'float'");
}
var mul__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'string'");
}
var mul__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'bool'");
}
var mul__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'double'");
}
var mul__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'long'");
}
var mul__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'long_long'");
}
var mul__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'long_double'");
}
var mul__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'uint'");
}
var mul__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'ulong'");
}
var mul__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'ulong_long'");
}
var mul__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'list'");
}
var mul__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'set'");
}
var mul__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'dict'");
}
var mul__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'orderedset'");
}
var mul__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'ordereddict'");
}
var mul__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'set' and 'graph'");
}
var mul__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'none'");
}
var mul__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'int'");
}
var mul__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'float'");
}
var mul__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'string'");
}
var mul__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'bool'");
}
var mul__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'double'");
}
var mul__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'long'");
}
var mul__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'long_long'");
}
var mul__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'long_double'");
}
var mul__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'uint'");
}
var mul__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'ulong'");
}
var mul__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'ulong_long'");
}
var mul__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'list'");
}
var mul__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'set'");
}
var mul__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'dict'");
}
var mul__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'orderedset'");
}
var mul__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'ordereddict'");
}
var mul__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'dict' and 'graph'");
}
var mul__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'none'");
}
var mul__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'int'");
}
var mul__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'float'");
}
var mul__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'string'");
}
var mul__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'bool'");
}
var mul__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'double'");
}
var mul__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'long'");
}
var mul__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'long_long'");
}
var mul__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'long_double'");
}
var mul__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'uint'");
}
var mul__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'ulong'");
}
var mul__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'ulong_long'");
}
var mul__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'list'");
}
var mul__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'set'");
}
var mul__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'dict'");
}
var mul__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'orderedset'");
}
var mul__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'ordereddict'");
}
var mul__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'orderedset' and 'graph'");
}
var mul__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'none'");
}
var mul__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'int'");
}
var mul__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'float'");
}
var mul__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'string'");
}
var mul__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'bool'");
}
var mul__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'double'");
}
var mul__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'long'");
}
var mul__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'long_long'");
}
var mul__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'long_double'");
}
var mul__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'uint'");
}
var mul__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'ulong'");
}
var mul__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'ulong_long'");
}
var mul__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'list'");
}
var mul__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'set'");
}
var mul__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'dict'");
}
var mul__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'orderedset'");
}
var mul__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'ordereddict'");
}
var mul__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'ordereddict' and 'graph'");
}
var mul__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'none'");
}
var mul__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'int'");
}
var mul__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'float'");
}
var mul__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'string'");
}
var mul__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'bool'");
}
var mul__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'double'");
}
var mul__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'long'");
}
var mul__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'long_long'");
}
var mul__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'long_double'");
}
var mul__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'uint'");
}
var mul__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'ulong'");
}
var mul__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'ulong_long'");
}
var mul__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'list'");
}
var mul__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'set'");
}
var mul__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'dict'");
}
var mul__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'orderedset'");
}
var mul__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'ordereddict'");
}
var mul__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for *: 'graph' and 'graph'");
}

// Stub definitions for div
var div__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'none'");
}
var div__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'int'");
}
var div__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'float'");
}
var div__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'string'");
}
var div__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'bool'");
}
var div__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'double'");
}
var div__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'long'");
}
var div__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'long_long'");
}
var div__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'long_double'");
}
var div__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'uint'");
}
var div__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'ulong'");
}
var div__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'ulong_long'");
}
var div__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'list'");
}
var div__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'set'");
}
var div__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'dict'");
}
var div__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'orderedset'");
}
var div__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'ordereddict'");
}
var div__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'none' and 'graph'");
}
var div__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'none'");
}
var div__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'string'");
}
var div__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'list'");
}
var div__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'set'");
}
var div__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'dict'");
}
var div__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'orderedset'");
}
var div__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'ordereddict'");
}
var div__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'int' and 'graph'");
}
var div__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'none'");
}
var div__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'string'");
}
var div__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'list'");
}
var div__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'set'");
}
var div__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'dict'");
}
var div__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'orderedset'");
}
var div__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'ordereddict'");
}
var div__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'float' and 'graph'");
}
var div__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'none'");
}
var div__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'int'");
}
var div__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'float'");
}
var div__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'string'");
}
var div__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'bool'");
}
var div__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'double'");
}
var div__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'long'");
}
var div__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'long_long'");
}
var div__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'long_double'");
}
var div__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'uint'");
}
var div__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'ulong'");
}
var div__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'ulong_long'");
}
var div__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'list'");
}
var div__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'set'");
}
var div__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'dict'");
}
var div__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'orderedset'");
}
var div__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'ordereddict'");
}
var div__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'string' and 'graph'");
}
var div__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'none'");
}
var div__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'string'");
}
var div__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'list'");
}
var div__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'set'");
}
var div__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'dict'");
}
var div__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'orderedset'");
}
var div__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'ordereddict'");
}
var div__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'bool' and 'graph'");
}
var div__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'none'");
}
var div__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'string'");
}
var div__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'list'");
}
var div__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'set'");
}
var div__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'dict'");
}
var div__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'orderedset'");
}
var div__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'ordereddict'");
}
var div__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'double' and 'graph'");
}
var div__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'none'");
}
var div__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'string'");
}
var div__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'list'");
}
var div__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'set'");
}
var div__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'dict'");
}
var div__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'orderedset'");
}
var div__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'ordereddict'");
}
var div__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long' and 'graph'");
}
var div__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'none'");
}
var div__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'string'");
}
var div__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'list'");
}
var div__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'set'");
}
var div__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'dict'");
}
var div__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'orderedset'");
}
var div__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'ordereddict'");
}
var div__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_long' and 'graph'");
}
var div__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'none'");
}
var div__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'string'");
}
var div__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'list'");
}
var div__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'set'");
}
var div__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'dict'");
}
var div__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'orderedset'");
}
var div__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'ordereddict'");
}
var div__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'long_double' and 'graph'");
}
var div__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'none'");
}
var div__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'string'");
}
var div__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'list'");
}
var div__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'set'");
}
var div__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'dict'");
}
var div__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'orderedset'");
}
var div__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'ordereddict'");
}
var div__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'uint' and 'graph'");
}
var div__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'none'");
}
var div__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'string'");
}
var div__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'list'");
}
var div__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'set'");
}
var div__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'dict'");
}
var div__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'orderedset'");
}
var div__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'ordereddict'");
}
var div__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong' and 'graph'");
}
var div__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'none'");
}
var div__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'string'");
}
var div__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    // Numeric div with policy-aware handling
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la / lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::div_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::div_wrap(la, lb);
        return var(res);
    } else {
        long double result = static_cast<long double>(la) / static_cast<long double>(lb);
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var div__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'list'");
}
var div__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'set'");
}
var div__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'dict'");
}
var div__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'orderedset'");
}
var div__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'ordereddict'");
}
var div__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ulong_long' and 'graph'");
}
var div__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'none'");
}
var div__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'int'");
}
var div__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'float'");
}
var div__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'string'");
}
var div__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'bool'");
}
var div__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'double'");
}
var div__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'long'");
}
var div__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'long_long'");
}
var div__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'long_double'");
}
var div__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'uint'");
}
var div__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'ulong'");
}
var div__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'ulong_long'");
}
var div__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'list'");
}
var div__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'set'");
}
var div__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'dict'");
}
var div__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'orderedset'");
}
var div__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'ordereddict'");
}
var div__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'list' and 'graph'");
}
var div__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'none'");
}
var div__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'int'");
}
var div__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'float'");
}
var div__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'string'");
}
var div__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'bool'");
}
var div__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'double'");
}
var div__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'long'");
}
var div__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'long_long'");
}
var div__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'long_double'");
}
var div__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'uint'");
}
var div__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'ulong'");
}
var div__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'ulong_long'");
}
var div__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'list'");
}
var div__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'set'");
}
var div__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'dict'");
}
var div__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'orderedset'");
}
var div__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'ordereddict'");
}
var div__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'set' and 'graph'");
}
var div__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'none'");
}
var div__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'int'");
}
var div__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'float'");
}
var div__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'string'");
}
var div__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'bool'");
}
var div__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'double'");
}
var div__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'long'");
}
var div__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'long_long'");
}
var div__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'long_double'");
}
var div__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'uint'");
}
var div__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'ulong'");
}
var div__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'ulong_long'");
}
var div__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'list'");
}
var div__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'set'");
}
var div__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'dict'");
}
var div__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'orderedset'");
}
var div__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'ordereddict'");
}
var div__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'dict' and 'graph'");
}
var div__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'none'");
}
var div__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'int'");
}
var div__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'float'");
}
var div__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'string'");
}
var div__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'bool'");
}
var div__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'double'");
}
var div__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'long'");
}
var div__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'long_long'");
}
var div__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'long_double'");
}
var div__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'uint'");
}
var div__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'ulong'");
}
var div__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'ulong_long'");
}
var div__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'list'");
}
var div__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'set'");
}
var div__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'dict'");
}
var div__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'orderedset'");
}
var div__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'ordereddict'");
}
var div__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'orderedset' and 'graph'");
}
var div__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'none'");
}
var div__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'int'");
}
var div__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'float'");
}
var div__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'string'");
}
var div__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'bool'");
}
var div__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'double'");
}
var div__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'long'");
}
var div__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'long_long'");
}
var div__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'long_double'");
}
var div__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'uint'");
}
var div__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'ulong'");
}
var div__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'ulong_long'");
}
var div__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'list'");
}
var div__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'set'");
}
var div__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'dict'");
}
var div__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'orderedset'");
}
var div__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'ordereddict'");
}
var div__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'ordereddict' and 'graph'");
}
var div__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'none'");
}
var div__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'int'");
}
var div__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'float'");
}
var div__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'string'");
}
var div__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'bool'");
}
var div__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'double'");
}
var div__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'long'");
}
var div__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'long_long'");
}
var div__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'long_double'");
}
var div__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'uint'");
}
var div__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'ulong'");
}
var div__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'ulong_long'");
}
var div__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'list'");
}
var div__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'set'");
}
var div__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'dict'");
}
var div__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'orderedset'");
}
var div__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'ordereddict'");
}
var div__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for /: 'graph' and 'graph'");
}

// Stub definitions for mod
var mod__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'none'");
}
var mod__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'int'");
}
var mod__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'float'");
}
var mod__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'string'");
}
var mod__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'bool'");
}
var mod__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'double'");
}
var mod__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'long'");
}
var mod__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'long_long'");
}
var mod__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'long_double'");
}
var mod__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'uint'");
}
var mod__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'ulong'");
}
var mod__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'ulong_long'");
}
var mod__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'list'");
}
var mod__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'set'");
}
var mod__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'dict'");
}
var mod__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'orderedset'");
}
var mod__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'ordereddict'");
}
var mod__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'none' and 'graph'");
}
var mod__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'none'");
}
var mod__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'string'");
}
var mod__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_INT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'list'");
}
var mod__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'set'");
}
var mod__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'dict'");
}
var mod__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'orderedset'");
}
var mod__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'ordereddict'");
}
var mod__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'int' and 'graph'");
}
var mod__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'none'");
}
var mod__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'string'");
}
var mod__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_FLOAT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'list'");
}
var mod__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'set'");
}
var mod__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'dict'");
}
var mod__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'orderedset'");
}
var mod__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'ordereddict'");
}
var mod__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'float' and 'graph'");
}
var mod__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'none'");
}
var mod__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'int'");
}
var mod__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'float'");
}
var mod__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'string'");
}
var mod__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'bool'");
}
var mod__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'double'");
}
var mod__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'long'");
}
var mod__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'long_long'");
}
var mod__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'long_double'");
}
var mod__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'uint'");
}
var mod__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'ulong'");
}
var mod__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'ulong_long'");
}
var mod__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'list'");
}
var mod__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'set'");
}
var mod__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'dict'");
}
var mod__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'orderedset'");
}
var mod__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'ordereddict'");
}
var mod__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'string' and 'graph'");
}
var mod__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'none'");
}
var mod__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'string'");
}
var mod__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(0, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(0, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'list'");
}
var mod__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'set'");
}
var mod__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'dict'");
}
var mod__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'orderedset'");
}
var mod__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'ordereddict'");
}
var mod__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'bool' and 'graph'");
}
var mod__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'none'");
}
var mod__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'string'");
}
var mod__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'list'");
}
var mod__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'set'");
}
var mod__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'dict'");
}
var mod__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'orderedset'");
}
var mod__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'ordereddict'");
}
var mod__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'double' and 'graph'");
}
var mod__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'none'");
}
var mod__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'string'");
}
var mod__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'list'");
}
var mod__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'set'");
}
var mod__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'dict'");
}
var mod__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'orderedset'");
}
var mod__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'ordereddict'");
}
var mod__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long' and 'graph'");
}
var mod__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'none'");
}
var mod__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'string'");
}
var mod__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'list'");
}
var mod__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'set'");
}
var mod__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'dict'");
}
var mod__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'orderedset'");
}
var mod__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'ordereddict'");
}
var mod__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_long' and 'graph'");
}
var mod__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'none'");
}
var mod__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'string'");
}
var mod__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_LONG_DOUBLE, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'list'");
}
var mod__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'set'");
}
var mod__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'dict'");
}
var mod__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'orderedset'");
}
var mod__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'ordereddict'");
}
var mod__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'long_double' and 'graph'");
}
var mod__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'none'");
}
var mod__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'string'");
}
var mod__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_UINT, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'list'");
}
var mod__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'set'");
}
var mod__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'dict'");
}
var mod__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'orderedset'");
}
var mod__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'ordereddict'");
}
var mod__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'uint' and 'graph'");
}
var mod__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'none'");
}
var mod__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'string'");
}
var mod__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'list'");
}
var mod__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'set'");
}
var mod__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'dict'");
}
var mod__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'orderedset'");
}
var mod__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'ordereddict'");
}
var mod__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong' and 'graph'");
}
var mod__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'none'");
}
var mod__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_INT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        float res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_FLOAT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'string'");
}
var mod__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, 0);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Signed;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    if (static_cast<long double>(lb) == 0.0L) throw pythonic::PythonicZeroDivisionError("float division by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them || policy == pythonic::overflow::Overflow::Throw || policy == pythonic::overflow::Overflow::Wrap) {
        long double res = std::fmod(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Has_float;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_LONG_DOUBLE);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_UINT);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    if (lb == 0) throw pythonic::PythonicZeroDivisionError("integer division or modulo by zero");
    if (policy == pythonic::overflow::Overflow::None_of_them) {
        return var(la % lb);
    } else if (policy == pythonic::overflow::Overflow::Throw) {
        auto res = pythonic::overflow::mod_throw(la, lb);
        return var(res);
    } else if (policy == pythonic::overflow::Overflow::Wrap) {
        auto res = pythonic::overflow::mod_wrap(la, lb);
        return var(res);
    } else {
        long double result = std::fmod(static_cast<long double>(la), static_cast<long double>(lb));
        auto ptype = pythonic::promotion::Both_unsigned;
        int min_rank = std::max(pythonic::promotion::RANK_ULONG_LONG, pythonic::promotion::RANK_ULONG_LONG);
        return pythonic::promotion::smart_promote(result, ptype, smallest_fit, min_rank, false);
    }
}
var mod__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'list'");
}
var mod__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'set'");
}
var mod__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'dict'");
}
var mod__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'orderedset'");
}
var mod__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'ordereddict'");
}
var mod__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ulong_long' and 'graph'");
}
var mod__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'none'");
}
var mod__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'int'");
}
var mod__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'float'");
}
var mod__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'string'");
}
var mod__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'bool'");
}
var mod__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'double'");
}
var mod__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'long'");
}
var mod__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'long_long'");
}
var mod__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'long_double'");
}
var mod__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'uint'");
}
var mod__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'ulong'");
}
var mod__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'ulong_long'");
}
var mod__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'list'");
}
var mod__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'set'");
}
var mod__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'dict'");
}
var mod__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'orderedset'");
}
var mod__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'ordereddict'");
}
var mod__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'list' and 'graph'");
}
var mod__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'none'");
}
var mod__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'int'");
}
var mod__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'float'");
}
var mod__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'string'");
}
var mod__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'bool'");
}
var mod__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'double'");
}
var mod__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'long'");
}
var mod__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'long_long'");
}
var mod__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'long_double'");
}
var mod__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'uint'");
}
var mod__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'ulong'");
}
var mod__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'ulong_long'");
}
var mod__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'list'");
}
var mod__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'set'");
}
var mod__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'dict'");
}
var mod__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'orderedset'");
}
var mod__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'ordereddict'");
}
var mod__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'set' and 'graph'");
}
var mod__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'none'");
}
var mod__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'int'");
}
var mod__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'float'");
}
var mod__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'string'");
}
var mod__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'bool'");
}
var mod__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'double'");
}
var mod__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'long'");
}
var mod__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'long_long'");
}
var mod__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'long_double'");
}
var mod__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'uint'");
}
var mod__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'ulong'");
}
var mod__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'ulong_long'");
}
var mod__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'list'");
}
var mod__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'set'");
}
var mod__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'dict'");
}
var mod__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'orderedset'");
}
var mod__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'ordereddict'");
}
var mod__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'dict' and 'graph'");
}
var mod__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'none'");
}
var mod__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'int'");
}
var mod__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'float'");
}
var mod__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'string'");
}
var mod__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'bool'");
}
var mod__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'double'");
}
var mod__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'long'");
}
var mod__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'long_long'");
}
var mod__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'long_double'");
}
var mod__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'uint'");
}
var mod__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'ulong'");
}
var mod__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'ulong_long'");
}
var mod__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'list'");
}
var mod__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'set'");
}
var mod__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'dict'");
}
var mod__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'orderedset'");
}
var mod__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'ordereddict'");
}
var mod__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'orderedset' and 'graph'");
}
var mod__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'none'");
}
var mod__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'int'");
}
var mod__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'float'");
}
var mod__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'string'");
}
var mod__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'bool'");
}
var mod__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'double'");
}
var mod__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'long'");
}
var mod__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'long_long'");
}
var mod__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'long_double'");
}
var mod__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'uint'");
}
var mod__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'ulong'");
}
var mod__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'ulong_long'");
}
var mod__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'list'");
}
var mod__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'set'");
}
var mod__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'dict'");
}
var mod__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'orderedset'");
}
var mod__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'ordereddict'");
}
var mod__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'ordereddict' and 'graph'");
}
var mod__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'none'");
}
var mod__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'int'");
}
var mod__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'float'");
}
var mod__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'string'");
}
var mod__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'bool'");
}
var mod__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'double'");
}
var mod__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'long'");
}
var mod__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'long_long'");
}
var mod__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'long_double'");
}
var mod__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'uint'");
}
var mod__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'ulong'");
}
var mod__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'ulong_long'");
}
var mod__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'list'");
}
var mod__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'set'");
}
var mod__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'dict'");
}
var mod__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'orderedset'");
}
var mod__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'ordereddict'");
}
var mod__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for %: 'graph' and 'graph'");
}

// Stub definitions for eq
var eq__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'none'");
}
var eq__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'int'");
}
var eq__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'float'");
}
var eq__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'string'");
}
var eq__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'bool'");
}
var eq__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'double'");
}
var eq__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'long'");
}
var eq__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'long_long'");
}
var eq__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'long_double'");
}
var eq__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'uint'");
}
var eq__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'ulong'");
}
var eq__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'ulong_long'");
}
var eq__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'list'");
}
var eq__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'set'");
}
var eq__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'dict'");
}
var eq__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'orderedset'");
}
var eq__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'ordereddict'");
}
var eq__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'none' and 'graph'");
}
var eq__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'none'");
}
var eq__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la == lb);
}
var eq__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'string'");
}
var eq__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la == lb);
}
var eq__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la == lb);
}
var eq__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la == lb);
}
var eq__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'list'");
}
var eq__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'set'");
}
var eq__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'dict'");
}
var eq__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'orderedset'");
}
var eq__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'ordereddict'");
}
var eq__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'int' and 'graph'");
}
var eq__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'none'");
}
var eq__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    return var(la == lb);
}
var eq__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'string'");
}
var eq__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    return var(la == lb);
}
var eq__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    return var(la == lb);
}
var eq__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    return var(la == lb);
}
var eq__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'list'");
}
var eq__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'set'");
}
var eq__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'dict'");
}
var eq__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'orderedset'");
}
var eq__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'ordereddict'");
}
var eq__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'float' and 'graph'");
}
var eq__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'none'");
}
var eq__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'int'");
}
var eq__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'float'");
}
var eq__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() == b.var_get<std::string>());
}
var eq__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'bool'");
}
var eq__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'double'");
}
var eq__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'long'");
}
var eq__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'long_long'");
}
var eq__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'long_double'");
}
var eq__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'uint'");
}
var eq__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'ulong'");
}
var eq__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'ulong_long'");
}
var eq__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'list'");
}
var eq__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'set'");
}
var eq__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'dict'");
}
var eq__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'orderedset'");
}
var eq__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'ordereddict'");
}
var eq__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'string' and 'graph'");
}
var eq__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'none'");
}
var eq__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la == lb);
}
var eq__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'string'");
}
var eq__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la == lb);
}
var eq__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la == lb);
}
var eq__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la == lb);
}
var eq__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'list'");
}
var eq__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'set'");
}
var eq__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'dict'");
}
var eq__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'orderedset'");
}
var eq__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'ordereddict'");
}
var eq__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'bool' and 'graph'");
}
var eq__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'none'");
}
var eq__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    return var(la == lb);
}
var eq__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    return var(la == lb);
}
var eq__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'string'");
}
var eq__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    return var(la == lb);
}
var eq__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    return var(la == lb);
}
var eq__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    return var(la == lb);
}
var eq__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'list'");
}
var eq__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'set'");
}
var eq__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'dict'");
}
var eq__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'orderedset'");
}
var eq__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'ordereddict'");
}
var eq__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'double' and 'graph'");
}
var eq__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'none'");
}
var eq__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la == lb);
}
var eq__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'string'");
}
var eq__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la == lb);
}
var eq__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la == lb);
}
var eq__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la == lb);
}
var eq__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'list'");
}
var eq__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'set'");
}
var eq__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'dict'");
}
var eq__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'orderedset'");
}
var eq__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'ordereddict'");
}
var eq__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long' and 'graph'");
}
var eq__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'none'");
}
var eq__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la == lb);
}
var eq__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'string'");
}
var eq__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la == lb);
}
var eq__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la == lb);
}
var eq__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la == lb);
}
var eq__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'list'");
}
var eq__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'set'");
}
var eq__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'dict'");
}
var eq__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'orderedset'");
}
var eq__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'ordereddict'");
}
var eq__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_long' and 'graph'");
}
var eq__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'none'");
}
var eq__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    return var(la == lb);
}
var eq__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    return var(la == lb);
}
var eq__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'string'");
}
var eq__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    return var(la == lb);
}
var eq__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    return var(la == lb);
}
var eq__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    return var(la == lb);
}
var eq__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    return var(la == lb);
}
var eq__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'list'");
}
var eq__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'set'");
}
var eq__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'dict'");
}
var eq__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'orderedset'");
}
var eq__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'ordereddict'");
}
var eq__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'long_double' and 'graph'");
}
var eq__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'none'");
}
var eq__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la == lb);
}
var eq__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'string'");
}
var eq__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la == lb);
}
var eq__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la == lb);
}
var eq__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la == lb);
}
var eq__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'list'");
}
var eq__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'set'");
}
var eq__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'dict'");
}
var eq__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'orderedset'");
}
var eq__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'ordereddict'");
}
var eq__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'uint' and 'graph'");
}
var eq__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'none'");
}
var eq__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la == lb);
}
var eq__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'string'");
}
var eq__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la == lb);
}
var eq__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la == lb);
}
var eq__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la == lb);
}
var eq__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'list'");
}
var eq__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'set'");
}
var eq__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'dict'");
}
var eq__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'orderedset'");
}
var eq__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'ordereddict'");
}
var eq__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong' and 'graph'");
}
var eq__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'none'");
}
var eq__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la == lb);
}
var eq__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la == lb);
}
var eq__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'string'");
}
var eq__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la == lb);
}
var eq__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la == lb);
}
var eq__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la == lb);
}
var eq__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la == lb);
}
var eq__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la == lb);
}
var eq__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la == lb);
}
var eq__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la == lb);
}
var eq__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la == lb);
}
var eq__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'list'");
}
var eq__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'set'");
}
var eq__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'dict'");
}
var eq__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'orderedset'");
}
var eq__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'ordereddict'");
}
var eq__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ulong_long' and 'graph'");
}
var eq__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'none'");
}
var eq__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'int'");
}
var eq__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'float'");
}
var eq__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'string'");
}
var eq__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'bool'");
}
var eq__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'double'");
}
var eq__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'long'");
}
var eq__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'long_long'");
}
var eq__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'long_double'");
}
var eq__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'uint'");
}
var eq__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'ulong'");
}
var eq__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'ulong_long'");
}
var eq__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lst1 = a.var_get<pythonic::vars::List>();
    const auto &lst2 = b.var_get<pythonic::vars::List>();
    if (lst1.size() != lst2.size()) return var(false);
    return var(std::equal(lst1.begin(), lst1.end(), lst2.begin(), lst2.end()));
}
var eq__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'set'");
}
var eq__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'dict'");
}
var eq__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'orderedset'");
}
var eq__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'ordereddict'");
}
var eq__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'list' and 'graph'");
}
var eq__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'none'");
}
var eq__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'int'");
}
var eq__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'float'");
}
var eq__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'string'");
}
var eq__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'bool'");
}
var eq__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'double'");
}
var eq__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'long'");
}
var eq__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'long_long'");
}
var eq__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'long_double'");
}
var eq__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'uint'");
}
var eq__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'ulong'");
}
var eq__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'ulong_long'");
}
var eq__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'list'");
}
var eq__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::Set>();
    const auto &set2 = b.var_get<pythonic::vars::Set>();
    if (set1.size() != set2.size()) return var(false);
    for (const auto &elem : set1) {
        if (set2.find(elem) == set2.end()) return var(false);
    }
    return var(true);
}
var eq__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'dict'");
}
var eq__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'orderedset'");
}
var eq__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'ordereddict'");
}
var eq__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'set' and 'graph'");
}
var eq__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'none'");
}
var eq__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'int'");
}
var eq__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'float'");
}
var eq__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'string'");
}
var eq__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'bool'");
}
var eq__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'double'");
}
var eq__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'long'");
}
var eq__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'long_long'");
}
var eq__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'long_double'");
}
var eq__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'uint'");
}
var eq__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'ulong'");
}
var eq__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'ulong_long'");
}
var eq__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'list'");
}
var eq__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'set'");
}
var eq__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::Dict>();
    const auto &dict2 = b.var_get<pythonic::vars::Dict>();
    if (dict1.size() != dict2.size()) return var(false);
    for (const auto &kv : dict1) {
        const auto &key = kv.first; const auto &val = kv.second;
        auto it = dict2.find(key);
        if (it == dict2.end() || !static_cast<bool>(val == it->second)) return var(false);
    }
    return var(true);
}
var eq__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'orderedset'");
}
var eq__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'ordereddict'");
}
var eq__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'dict' and 'graph'");
}
var eq__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'none'");
}
var eq__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'int'");
}
var eq__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'float'");
}
var eq__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'string'");
}
var eq__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'bool'");
}
var eq__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'double'");
}
var eq__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'long'");
}
var eq__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'long_long'");
}
var eq__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'long_double'");
}
var eq__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'uint'");
}
var eq__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'ulong'");
}
var eq__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'ulong_long'");
}
var eq__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'list'");
}
var eq__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'set'");
}
var eq__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'dict'");
}
var eq__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::OrderedSet>();
    const auto &set2 = b.var_get<pythonic::vars::OrderedSet>();
    return var(std::equal(set1.begin(), set1.end(), set2.begin(), set2.end()));
}
var eq__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'ordereddict'");
}
var eq__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'orderedset' and 'graph'");
}
var eq__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'none'");
}
var eq__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'int'");
}
var eq__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'float'");
}
var eq__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'string'");
}
var eq__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'bool'");
}
var eq__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'double'");
}
var eq__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'long'");
}
var eq__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'long_long'");
}
var eq__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'long_double'");
}
var eq__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'uint'");
}
var eq__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'ulong'");
}
var eq__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'ulong_long'");
}
var eq__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'list'");
}
var eq__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'set'");
}
var eq__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'dict'");
}
var eq__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'orderedset'");
}
var eq__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::OrderedDict>();
    const auto &dict2 = b.var_get<pythonic::vars::OrderedDict>();
    return var(std::equal(dict1.begin(), dict1.end(), dict2.begin(), dict2.end()));
}
var eq__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'ordereddict' and 'graph'");
}
var eq__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'none'");
}
var eq__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'int'");
}
var eq__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'float'");
}
var eq__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'string'");
}
var eq__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'bool'");
}
var eq__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'double'");
}
var eq__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'long'");
}
var eq__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'long_long'");
}
var eq__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'long_double'");
}
var eq__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'uint'");
}
var eq__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'ulong'");
}
var eq__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'ulong_long'");
}
var eq__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'list'");
}
var eq__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'set'");
}
var eq__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'dict'");
}
var eq__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'orderedset'");
}
var eq__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'ordereddict'");
}
var eq__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ==: 'graph' and 'graph'");
}

// Stub definitions for ne
var ne__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'none'");
}
var ne__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'int'");
}
var ne__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'float'");
}
var ne__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'string'");
}
var ne__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'bool'");
}
var ne__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'double'");
}
var ne__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'long'");
}
var ne__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'long_long'");
}
var ne__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'long_double'");
}
var ne__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'uint'");
}
var ne__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'ulong'");
}
var ne__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'ulong_long'");
}
var ne__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'list'");
}
var ne__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'set'");
}
var ne__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'dict'");
}
var ne__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'orderedset'");
}
var ne__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'ordereddict'");
}
var ne__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'none' and 'graph'");
}
var ne__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'none'");
}
var ne__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la != lb);
}
var ne__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'string'");
}
var ne__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la != lb);
}
var ne__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la != lb);
}
var ne__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la != lb);
}
var ne__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'list'");
}
var ne__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'set'");
}
var ne__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'dict'");
}
var ne__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'orderedset'");
}
var ne__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'ordereddict'");
}
var ne__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'int' and 'graph'");
}
var ne__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'none'");
}
var ne__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    return var(la != lb);
}
var ne__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'string'");
}
var ne__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    return var(la != lb);
}
var ne__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    return var(la != lb);
}
var ne__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    return var(la != lb);
}
var ne__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'list'");
}
var ne__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'set'");
}
var ne__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'dict'");
}
var ne__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'orderedset'");
}
var ne__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'ordereddict'");
}
var ne__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'float' and 'graph'");
}
var ne__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'none'");
}
var ne__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'int'");
}
var ne__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'float'");
}
var ne__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() != b.var_get<std::string>());
}
var ne__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'bool'");
}
var ne__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'double'");
}
var ne__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'long'");
}
var ne__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'long_long'");
}
var ne__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'long_double'");
}
var ne__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'uint'");
}
var ne__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'ulong'");
}
var ne__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'ulong_long'");
}
var ne__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'list'");
}
var ne__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'set'");
}
var ne__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'dict'");
}
var ne__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'orderedset'");
}
var ne__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'ordereddict'");
}
var ne__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'string' and 'graph'");
}
var ne__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'none'");
}
var ne__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la != lb);
}
var ne__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'string'");
}
var ne__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la != lb);
}
var ne__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la != lb);
}
var ne__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la != lb);
}
var ne__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'list'");
}
var ne__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'set'");
}
var ne__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'dict'");
}
var ne__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'orderedset'");
}
var ne__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'ordereddict'");
}
var ne__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'bool' and 'graph'");
}
var ne__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'none'");
}
var ne__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    return var(la != lb);
}
var ne__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    return var(la != lb);
}
var ne__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'string'");
}
var ne__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    return var(la != lb);
}
var ne__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    return var(la != lb);
}
var ne__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    return var(la != lb);
}
var ne__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'list'");
}
var ne__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'set'");
}
var ne__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'dict'");
}
var ne__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'orderedset'");
}
var ne__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'ordereddict'");
}
var ne__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'double' and 'graph'");
}
var ne__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'none'");
}
var ne__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la != lb);
}
var ne__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'string'");
}
var ne__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la != lb);
}
var ne__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la != lb);
}
var ne__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la != lb);
}
var ne__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'list'");
}
var ne__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'set'");
}
var ne__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'dict'");
}
var ne__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'orderedset'");
}
var ne__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'ordereddict'");
}
var ne__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long' and 'graph'");
}
var ne__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'none'");
}
var ne__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la != lb);
}
var ne__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'string'");
}
var ne__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la != lb);
}
var ne__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la != lb);
}
var ne__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la != lb);
}
var ne__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'list'");
}
var ne__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'set'");
}
var ne__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'dict'");
}
var ne__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'orderedset'");
}
var ne__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'ordereddict'");
}
var ne__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_long' and 'graph'");
}
var ne__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'none'");
}
var ne__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    return var(la != lb);
}
var ne__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    return var(la != lb);
}
var ne__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'string'");
}
var ne__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    return var(la != lb);
}
var ne__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    return var(la != lb);
}
var ne__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    return var(la != lb);
}
var ne__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    return var(la != lb);
}
var ne__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'list'");
}
var ne__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'set'");
}
var ne__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'dict'");
}
var ne__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'orderedset'");
}
var ne__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'ordereddict'");
}
var ne__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'long_double' and 'graph'");
}
var ne__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'none'");
}
var ne__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la != lb);
}
var ne__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'string'");
}
var ne__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la != lb);
}
var ne__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la != lb);
}
var ne__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la != lb);
}
var ne__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'list'");
}
var ne__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'set'");
}
var ne__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'dict'");
}
var ne__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'orderedset'");
}
var ne__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'ordereddict'");
}
var ne__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'uint' and 'graph'");
}
var ne__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'none'");
}
var ne__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la != lb);
}
var ne__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'string'");
}
var ne__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la != lb);
}
var ne__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la != lb);
}
var ne__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la != lb);
}
var ne__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'list'");
}
var ne__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'set'");
}
var ne__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'dict'");
}
var ne__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'orderedset'");
}
var ne__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'ordereddict'");
}
var ne__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong' and 'graph'");
}
var ne__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'none'");
}
var ne__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la != lb);
}
var ne__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la != lb);
}
var ne__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'string'");
}
var ne__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la != lb);
}
var ne__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la != lb);
}
var ne__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la != lb);
}
var ne__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la != lb);
}
var ne__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la != lb);
}
var ne__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la != lb);
}
var ne__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la != lb);
}
var ne__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la != lb);
}
var ne__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'list'");
}
var ne__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'set'");
}
var ne__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'dict'");
}
var ne__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'orderedset'");
}
var ne__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'ordereddict'");
}
var ne__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ulong_long' and 'graph'");
}
var ne__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'none'");
}
var ne__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'int'");
}
var ne__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'float'");
}
var ne__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'string'");
}
var ne__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'bool'");
}
var ne__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'double'");
}
var ne__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'long'");
}
var ne__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'long_long'");
}
var ne__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'long_double'");
}
var ne__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'uint'");
}
var ne__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'ulong'");
}
var ne__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'ulong_long'");
}
var ne__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lst1 = a.var_get<pythonic::vars::List>();
    const auto &lst2 = b.var_get<pythonic::vars::List>();
    if (lst1.size() != lst2.size()) return var(true);
    return var(!std::equal(lst1.begin(), lst1.end(), lst2.begin(), lst2.end()));
}
var ne__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'set'");
}
var ne__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'dict'");
}
var ne__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'orderedset'");
}
var ne__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'ordereddict'");
}
var ne__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'list' and 'graph'");
}
var ne__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'none'");
}
var ne__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'int'");
}
var ne__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'float'");
}
var ne__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'string'");
}
var ne__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'bool'");
}
var ne__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'double'");
}
var ne__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'long'");
}
var ne__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'long_long'");
}
var ne__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'long_double'");
}
var ne__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'uint'");
}
var ne__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'ulong'");
}
var ne__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'ulong_long'");
}
var ne__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'list'");
}
var ne__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::Set>();
    const auto &set2 = b.var_get<pythonic::vars::Set>();
    if (set1.size() != set2.size()) return var(true);
    for (const auto &elem : set1) {
        if (set2.find(elem) == set2.end()) return var(true);
    }
    return var(false);
}
var ne__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'dict'");
}
var ne__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'orderedset'");
}
var ne__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'ordereddict'");
}
var ne__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'set' and 'graph'");
}
var ne__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'none'");
}
var ne__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'int'");
}
var ne__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'float'");
}
var ne__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'string'");
}
var ne__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'bool'");
}
var ne__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'double'");
}
var ne__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'long'");
}
var ne__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'long_long'");
}
var ne__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'long_double'");
}
var ne__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'uint'");
}
var ne__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'ulong'");
}
var ne__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'ulong_long'");
}
var ne__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'list'");
}
var ne__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'set'");
}
var ne__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::Dict>();
    const auto &dict2 = b.var_get<pythonic::vars::Dict>();
    if (dict1.size() != dict2.size()) return var(true);
    for (const auto &kv : dict1) {
        const auto &key = kv.first; const auto &val = kv.second;
        auto it = dict2.find(key);
        if (it == dict2.end() || static_cast<bool>(val != it->second)) return var(true);
    }
    return var(false);
}
var ne__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'orderedset'");
}
var ne__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'ordereddict'");
}
var ne__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'dict' and 'graph'");
}
var ne__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'none'");
}
var ne__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'int'");
}
var ne__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'float'");
}
var ne__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'string'");
}
var ne__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'bool'");
}
var ne__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'double'");
}
var ne__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'long'");
}
var ne__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'long_long'");
}
var ne__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'long_double'");
}
var ne__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'uint'");
}
var ne__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'ulong'");
}
var ne__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'ulong_long'");
}
var ne__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'list'");
}
var ne__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'set'");
}
var ne__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'dict'");
}
var ne__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::OrderedSet>();
    const auto &set2 = b.var_get<pythonic::vars::OrderedSet>();
    return var(!std::equal(set1.begin(), set1.end(), set2.begin(), set2.end()));
}
var ne__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'ordereddict'");
}
var ne__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'orderedset' and 'graph'");
}
var ne__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'none'");
}
var ne__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'int'");
}
var ne__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'float'");
}
var ne__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'string'");
}
var ne__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'bool'");
}
var ne__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'double'");
}
var ne__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'long'");
}
var ne__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'long_long'");
}
var ne__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'long_double'");
}
var ne__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'uint'");
}
var ne__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'ulong'");
}
var ne__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'ulong_long'");
}
var ne__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'list'");
}
var ne__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'set'");
}
var ne__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'dict'");
}
var ne__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'orderedset'");
}
var ne__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::OrderedDict>();
    const auto &dict2 = b.var_get<pythonic::vars::OrderedDict>();
    return var(!std::equal(dict1.begin(), dict1.end(), dict2.begin(), dict2.end()));
}
var ne__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'ordereddict' and 'graph'");
}
var ne__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'none'");
}
var ne__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'int'");
}
var ne__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'float'");
}
var ne__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'string'");
}
var ne__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'bool'");
}
var ne__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'double'");
}
var ne__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'long'");
}
var ne__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'long_long'");
}
var ne__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'long_double'");
}
var ne__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'uint'");
}
var ne__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'ulong'");
}
var ne__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'ulong_long'");
}
var ne__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'list'");
}
var ne__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'set'");
}
var ne__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'dict'");
}
var ne__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'orderedset'");
}
var ne__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'ordereddict'");
}
var ne__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for !=: 'graph' and 'graph'");
}

// Stub definitions for gt
var gt__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'none'");
}
var gt__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'int'");
}
var gt__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'float'");
}
var gt__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'string'");
}
var gt__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'bool'");
}
var gt__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'double'");
}
var gt__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'long'");
}
var gt__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'long_long'");
}
var gt__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'long_double'");
}
var gt__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'uint'");
}
var gt__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'ulong'");
}
var gt__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'ulong_long'");
}
var gt__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'list'");
}
var gt__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'set'");
}
var gt__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'dict'");
}
var gt__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'orderedset'");
}
var gt__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'ordereddict'");
}
var gt__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'none' and 'graph'");
}
var gt__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'none'");
}
var gt__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la > lb);
}
var gt__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'string'");
}
var gt__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la > lb);
}
var gt__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la > lb);
}
var gt__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la > lb);
}
var gt__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'list'");
}
var gt__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'set'");
}
var gt__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'dict'");
}
var gt__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'orderedset'");
}
var gt__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'ordereddict'");
}
var gt__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'int' and 'graph'");
}
var gt__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'none'");
}
var gt__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    return var(la > lb);
}
var gt__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'string'");
}
var gt__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    return var(la > lb);
}
var gt__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    return var(la > lb);
}
var gt__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    return var(la > lb);
}
var gt__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'list'");
}
var gt__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'set'");
}
var gt__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'dict'");
}
var gt__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'orderedset'");
}
var gt__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'ordereddict'");
}
var gt__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'float' and 'graph'");
}
var gt__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'none'");
}
var gt__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'int'");
}
var gt__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'float'");
}
var gt__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() > b.var_get<std::string>());
}
var gt__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'bool'");
}
var gt__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'double'");
}
var gt__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'long'");
}
var gt__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'long_long'");
}
var gt__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'long_double'");
}
var gt__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'uint'");
}
var gt__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'ulong'");
}
var gt__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'ulong_long'");
}
var gt__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'list'");
}
var gt__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'set'");
}
var gt__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'dict'");
}
var gt__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'orderedset'");
}
var gt__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'ordereddict'");
}
var gt__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'string' and 'graph'");
}
var gt__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'none'");
}
var gt__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la > lb);
}
var gt__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'string'");
}
var gt__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la > lb);
}
var gt__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la > lb);
}
var gt__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la > lb);
}
var gt__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'list'");
}
var gt__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'set'");
}
var gt__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'dict'");
}
var gt__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'orderedset'");
}
var gt__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'ordereddict'");
}
var gt__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'bool' and 'graph'");
}
var gt__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'none'");
}
var gt__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    return var(la > lb);
}
var gt__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    return var(la > lb);
}
var gt__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'string'");
}
var gt__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    return var(la > lb);
}
var gt__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    return var(la > lb);
}
var gt__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    return var(la > lb);
}
var gt__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'list'");
}
var gt__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'set'");
}
var gt__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'dict'");
}
var gt__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'orderedset'");
}
var gt__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'ordereddict'");
}
var gt__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'double' and 'graph'");
}
var gt__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'none'");
}
var gt__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la > lb);
}
var gt__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'string'");
}
var gt__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la > lb);
}
var gt__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la > lb);
}
var gt__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la > lb);
}
var gt__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'list'");
}
var gt__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'set'");
}
var gt__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'dict'");
}
var gt__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'orderedset'");
}
var gt__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'ordereddict'");
}
var gt__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long' and 'graph'");
}
var gt__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'none'");
}
var gt__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la > lb);
}
var gt__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'string'");
}
var gt__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la > lb);
}
var gt__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la > lb);
}
var gt__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la > lb);
}
var gt__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'list'");
}
var gt__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'set'");
}
var gt__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'dict'");
}
var gt__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'orderedset'");
}
var gt__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'ordereddict'");
}
var gt__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_long' and 'graph'");
}
var gt__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'none'");
}
var gt__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    return var(la > lb);
}
var gt__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    return var(la > lb);
}
var gt__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'string'");
}
var gt__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    return var(la > lb);
}
var gt__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    return var(la > lb);
}
var gt__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    return var(la > lb);
}
var gt__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    return var(la > lb);
}
var gt__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'list'");
}
var gt__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'set'");
}
var gt__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'dict'");
}
var gt__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'orderedset'");
}
var gt__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'ordereddict'");
}
var gt__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'long_double' and 'graph'");
}
var gt__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'none'");
}
var gt__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la > lb);
}
var gt__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'string'");
}
var gt__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la > lb);
}
var gt__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la > lb);
}
var gt__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la > lb);
}
var gt__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'list'");
}
var gt__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'set'");
}
var gt__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'dict'");
}
var gt__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'orderedset'");
}
var gt__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'ordereddict'");
}
var gt__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'uint' and 'graph'");
}
var gt__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'none'");
}
var gt__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la > lb);
}
var gt__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'string'");
}
var gt__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la > lb);
}
var gt__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la > lb);
}
var gt__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la > lb);
}
var gt__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'list'");
}
var gt__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'set'");
}
var gt__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'dict'");
}
var gt__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'orderedset'");
}
var gt__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'ordereddict'");
}
var gt__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong' and 'graph'");
}
var gt__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'none'");
}
var gt__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la > lb);
}
var gt__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la > lb);
}
var gt__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'string'");
}
var gt__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la > lb);
}
var gt__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la > lb);
}
var gt__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la > lb);
}
var gt__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la > lb);
}
var gt__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la > lb);
}
var gt__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la > lb);
}
var gt__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la > lb);
}
var gt__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la > lb);
}
var gt__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'list'");
}
var gt__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'set'");
}
var gt__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'dict'");
}
var gt__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'orderedset'");
}
var gt__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'ordereddict'");
}
var gt__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ulong_long' and 'graph'");
}
var gt__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'none'");
}
var gt__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'int'");
}
var gt__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'float'");
}
var gt__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'string'");
}
var gt__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'bool'");
}
var gt__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'double'");
}
var gt__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'long'");
}
var gt__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'long_long'");
}
var gt__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'long_double'");
}
var gt__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'uint'");
}
var gt__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'ulong'");
}
var gt__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'ulong_long'");
}
var gt__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lst1 = a.var_get<pythonic::vars::List>();
    const auto &lst2 = b.var_get<pythonic::vars::List>();
    return var(std::lexicographical_compare(lst2.begin(), lst2.end(), lst1.begin(), lst1.end()));
}
var gt__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'set'");
}
var gt__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'dict'");
}
var gt__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'orderedset'");
}
var gt__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'ordereddict'");
}
var gt__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'list' and 'graph'");
}
var gt__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'none'");
}
var gt__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'int'");
}
var gt__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'float'");
}
var gt__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'string'");
}
var gt__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'bool'");
}
var gt__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'double'");
}
var gt__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'long'");
}
var gt__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'long_long'");
}
var gt__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'long_double'");
}
var gt__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'uint'");
}
var gt__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'ulong'");
}
var gt__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'ulong_long'");
}
var gt__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'list'");
}
var gt__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::Set>();
    const auto &set2 = b.var_get<pythonic::vars::Set>();
    if (set2.size() >= set1.size()) return var(false);
    for (const auto &elem : set2) {
        if (set1.find(elem) == set1.end()) return var(false);
    }
    return var(true);
}
var gt__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'dict'");
}
var gt__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'orderedset'");
}
var gt__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'ordereddict'");
}
var gt__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'set' and 'graph'");
}
var gt__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'none'");
}
var gt__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'int'");
}
var gt__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'float'");
}
var gt__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'string'");
}
var gt__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'bool'");
}
var gt__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'double'");
}
var gt__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'long'");
}
var gt__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'long_long'");
}
var gt__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'long_double'");
}
var gt__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'uint'");
}
var gt__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'ulong'");
}
var gt__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'ulong_long'");
}
var gt__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'list'");
}
var gt__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'set'");
}
var gt__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'dict'");
}
var gt__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'orderedset'");
}
var gt__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'ordereddict'");
}
var gt__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'dict' and 'graph'");
}
var gt__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'none'");
}
var gt__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'int'");
}
var gt__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'float'");
}
var gt__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'string'");
}
var gt__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'bool'");
}
var gt__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'double'");
}
var gt__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'long'");
}
var gt__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'long_long'");
}
var gt__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'long_double'");
}
var gt__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'uint'");
}
var gt__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'ulong'");
}
var gt__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'ulong_long'");
}
var gt__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'list'");
}
var gt__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'set'");
}
var gt__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'dict'");
}
var gt__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::OrderedSet>();
    const auto &set2 = b.var_get<pythonic::vars::OrderedSet>();
    return var(std::lexicographical_compare(set2.begin(), set2.end(), set1.begin(), set1.end()));
}
var gt__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'ordereddict'");
}
var gt__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'orderedset' and 'graph'");
}
var gt__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'none'");
}
var gt__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'int'");
}
var gt__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'float'");
}
var gt__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'string'");
}
var gt__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'bool'");
}
var gt__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'double'");
}
var gt__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'long'");
}
var gt__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'long_long'");
}
var gt__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'long_double'");
}
var gt__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'uint'");
}
var gt__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'ulong'");
}
var gt__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'ulong_long'");
}
var gt__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'list'");
}
var gt__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'set'");
}
var gt__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'dict'");
}
var gt__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'orderedset'");
}
var gt__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::OrderedDict>();
    const auto &dict2 = b.var_get<pythonic::vars::OrderedDict>();
    return var(std::lexicographical_compare(dict2.begin(), dict2.end(), dict1.begin(), dict1.end()));
}
var gt__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'ordereddict' and 'graph'");
}
var gt__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'none'");
}
var gt__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'int'");
}
var gt__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'float'");
}
var gt__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'string'");
}
var gt__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'bool'");
}
var gt__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'double'");
}
var gt__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'long'");
}
var gt__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'long_long'");
}
var gt__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'long_double'");
}
var gt__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'uint'");
}
var gt__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'ulong'");
}
var gt__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'ulong_long'");
}
var gt__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'list'");
}
var gt__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'set'");
}
var gt__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'dict'");
}
var gt__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'orderedset'");
}
var gt__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'ordereddict'");
}
var gt__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >: 'graph' and 'graph'");
}

// Stub definitions for ge
var ge__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'none'");
}
var ge__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'int'");
}
var ge__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'float'");
}
var ge__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'string'");
}
var ge__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'bool'");
}
var ge__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'double'");
}
var ge__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'long'");
}
var ge__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'long_long'");
}
var ge__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'long_double'");
}
var ge__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'uint'");
}
var ge__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'ulong'");
}
var ge__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'ulong_long'");
}
var ge__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'list'");
}
var ge__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'set'");
}
var ge__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'dict'");
}
var ge__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'orderedset'");
}
var ge__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'ordereddict'");
}
var ge__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'none' and 'graph'");
}
var ge__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'none'");
}
var ge__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la >= lb);
}
var ge__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'string'");
}
var ge__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >= lb);
}
var ge__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'list'");
}
var ge__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'set'");
}
var ge__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'dict'");
}
var ge__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'orderedset'");
}
var ge__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'ordereddict'");
}
var ge__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'int' and 'graph'");
}
var ge__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'none'");
}
var ge__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    return var(la >= lb);
}
var ge__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'string'");
}
var ge__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    return var(la >= lb);
}
var ge__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'list'");
}
var ge__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'set'");
}
var ge__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'dict'");
}
var ge__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'orderedset'");
}
var ge__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'ordereddict'");
}
var ge__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'float' and 'graph'");
}
var ge__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'none'");
}
var ge__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'int'");
}
var ge__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'float'");
}
var ge__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() >= b.var_get<std::string>());
}
var ge__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'bool'");
}
var ge__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'double'");
}
var ge__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'long'");
}
var ge__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'long_long'");
}
var ge__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'long_double'");
}
var ge__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'uint'");
}
var ge__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'ulong'");
}
var ge__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'ulong_long'");
}
var ge__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'list'");
}
var ge__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'set'");
}
var ge__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'dict'");
}
var ge__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'orderedset'");
}
var ge__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'ordereddict'");
}
var ge__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'string' and 'graph'");
}
var ge__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'none'");
}
var ge__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la >= lb);
}
var ge__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'string'");
}
var ge__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >= lb);
}
var ge__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'list'");
}
var ge__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'set'");
}
var ge__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'dict'");
}
var ge__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'orderedset'");
}
var ge__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'ordereddict'");
}
var ge__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'bool' and 'graph'");
}
var ge__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'none'");
}
var ge__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    return var(la >= lb);
}
var ge__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    return var(la >= lb);
}
var ge__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'string'");
}
var ge__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    return var(la >= lb);
}
var ge__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'list'");
}
var ge__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'set'");
}
var ge__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'dict'");
}
var ge__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'orderedset'");
}
var ge__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'ordereddict'");
}
var ge__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'double' and 'graph'");
}
var ge__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'none'");
}
var ge__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la >= lb);
}
var ge__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'string'");
}
var ge__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >= lb);
}
var ge__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'list'");
}
var ge__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'set'");
}
var ge__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'dict'");
}
var ge__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'orderedset'");
}
var ge__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'ordereddict'");
}
var ge__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long' and 'graph'");
}
var ge__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'none'");
}
var ge__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la >= lb);
}
var ge__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'string'");
}
var ge__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la >= lb);
}
var ge__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'list'");
}
var ge__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'set'");
}
var ge__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'dict'");
}
var ge__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'orderedset'");
}
var ge__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'ordereddict'");
}
var ge__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_long' and 'graph'");
}
var ge__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'none'");
}
var ge__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    return var(la >= lb);
}
var ge__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    return var(la >= lb);
}
var ge__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'string'");
}
var ge__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    return var(la >= lb);
}
var ge__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'list'");
}
var ge__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'set'");
}
var ge__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'dict'");
}
var ge__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'orderedset'");
}
var ge__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'ordereddict'");
}
var ge__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'long_double' and 'graph'");
}
var ge__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'none'");
}
var ge__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la >= lb);
}
var ge__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'string'");
}
var ge__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >= lb);
}
var ge__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'list'");
}
var ge__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'set'");
}
var ge__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'dict'");
}
var ge__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'orderedset'");
}
var ge__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'ordereddict'");
}
var ge__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'uint' and 'graph'");
}
var ge__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'none'");
}
var ge__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la >= lb);
}
var ge__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'string'");
}
var ge__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >= lb);
}
var ge__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'list'");
}
var ge__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'set'");
}
var ge__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'dict'");
}
var ge__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'orderedset'");
}
var ge__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'ordereddict'");
}
var ge__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong' and 'graph'");
}
var ge__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'none'");
}
var ge__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la >= lb);
}
var ge__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la >= lb);
}
var ge__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'string'");
}
var ge__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la >= lb);
}
var ge__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la >= lb);
}
var ge__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la >= lb);
}
var ge__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >= lb);
}
var ge__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la >= lb);
}
var ge__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la >= lb);
}
var ge__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la >= lb);
}
var ge__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >= lb);
}
var ge__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'list'");
}
var ge__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'set'");
}
var ge__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'dict'");
}
var ge__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'orderedset'");
}
var ge__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'ordereddict'");
}
var ge__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ulong_long' and 'graph'");
}
var ge__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'none'");
}
var ge__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'int'");
}
var ge__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'float'");
}
var ge__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'string'");
}
var ge__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'bool'");
}
var ge__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'double'");
}
var ge__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'long'");
}
var ge__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'long_long'");
}
var ge__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'long_double'");
}
var ge__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'uint'");
}
var ge__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'ulong'");
}
var ge__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'ulong_long'");
}
var ge__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lst1 = a.var_get<pythonic::vars::List>();
    const auto &lst2 = b.var_get<pythonic::vars::List>();
    return var(!std::lexicographical_compare(lst1.begin(), lst1.end(), lst2.begin(), lst2.end()));
}
var ge__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'set'");
}
var ge__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'dict'");
}
var ge__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'orderedset'");
}
var ge__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'ordereddict'");
}
var ge__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'list' and 'graph'");
}
var ge__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'none'");
}
var ge__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'int'");
}
var ge__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'float'");
}
var ge__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'string'");
}
var ge__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'bool'");
}
var ge__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'double'");
}
var ge__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'long'");
}
var ge__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'long_long'");
}
var ge__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'long_double'");
}
var ge__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'uint'");
}
var ge__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'ulong'");
}
var ge__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'ulong_long'");
}
var ge__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'list'");
}
var ge__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::Set>();
    const auto &set2 = b.var_get<pythonic::vars::Set>();
    for (const auto &elem : set2) {
        if (set1.find(elem) == set1.end()) return var(false);
    }
    return var(true);
}
var ge__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'dict'");
}
var ge__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'orderedset'");
}
var ge__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'ordereddict'");
}
var ge__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'set' and 'graph'");
}
var ge__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'none'");
}
var ge__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'int'");
}
var ge__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'float'");
}
var ge__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'string'");
}
var ge__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'bool'");
}
var ge__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'double'");
}
var ge__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'long'");
}
var ge__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'long_long'");
}
var ge__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'long_double'");
}
var ge__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'uint'");
}
var ge__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'ulong'");
}
var ge__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'ulong_long'");
}
var ge__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'list'");
}
var ge__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'set'");
}
var ge__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'dict'");
}
var ge__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'orderedset'");
}
var ge__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'ordereddict'");
}
var ge__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'dict' and 'graph'");
}
var ge__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'none'");
}
var ge__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'int'");
}
var ge__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'float'");
}
var ge__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'string'");
}
var ge__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'bool'");
}
var ge__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'double'");
}
var ge__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'long'");
}
var ge__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'long_long'");
}
var ge__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'long_double'");
}
var ge__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'uint'");
}
var ge__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'ulong'");
}
var ge__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'ulong_long'");
}
var ge__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'list'");
}
var ge__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'set'");
}
var ge__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'dict'");
}
var ge__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::OrderedSet>();
    const auto &set2 = b.var_get<pythonic::vars::OrderedSet>();
    return var(!std::lexicographical_compare(set1.begin(), set1.end(), set2.begin(), set2.end()));
}
var ge__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'ordereddict'");
}
var ge__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'orderedset' and 'graph'");
}
var ge__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'none'");
}
var ge__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'int'");
}
var ge__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'float'");
}
var ge__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'string'");
}
var ge__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'bool'");
}
var ge__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'double'");
}
var ge__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'long'");
}
var ge__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'long_long'");
}
var ge__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'long_double'");
}
var ge__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'uint'");
}
var ge__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'ulong'");
}
var ge__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'ulong_long'");
}
var ge__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'list'");
}
var ge__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'set'");
}
var ge__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'dict'");
}
var ge__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'orderedset'");
}
var ge__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::OrderedDict>();
    const auto &dict2 = b.var_get<pythonic::vars::OrderedDict>();
    return var(!std::lexicographical_compare(dict1.begin(), dict1.end(), dict2.begin(), dict2.end()));
}
var ge__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'ordereddict' and 'graph'");
}
var ge__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'none'");
}
var ge__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'int'");
}
var ge__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'float'");
}
var ge__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'string'");
}
var ge__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'bool'");
}
var ge__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'double'");
}
var ge__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'long'");
}
var ge__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'long_long'");
}
var ge__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'long_double'");
}
var ge__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'uint'");
}
var ge__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'ulong'");
}
var ge__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'ulong_long'");
}
var ge__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'list'");
}
var ge__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'set'");
}
var ge__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'dict'");
}
var ge__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'orderedset'");
}
var ge__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'ordereddict'");
}
var ge__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >=: 'graph' and 'graph'");
}

// Stub definitions for lt
var lt__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'none'");
}
var lt__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'int'");
}
var lt__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'float'");
}
var lt__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'string'");
}
var lt__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'bool'");
}
var lt__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'double'");
}
var lt__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'long'");
}
var lt__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'long_long'");
}
var lt__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'long_double'");
}
var lt__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'uint'");
}
var lt__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'ulong'");
}
var lt__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'ulong_long'");
}
var lt__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'list'");
}
var lt__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'set'");
}
var lt__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'dict'");
}
var lt__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'orderedset'");
}
var lt__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'ordereddict'");
}
var lt__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'none' and 'graph'");
}
var lt__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'none'");
}
var lt__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la < lb);
}
var lt__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'string'");
}
var lt__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la < lb);
}
var lt__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la < lb);
}
var lt__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la < lb);
}
var lt__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'list'");
}
var lt__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'set'");
}
var lt__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'dict'");
}
var lt__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'orderedset'");
}
var lt__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'ordereddict'");
}
var lt__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'int' and 'graph'");
}
var lt__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'none'");
}
var lt__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    return var(la < lb);
}
var lt__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'string'");
}
var lt__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    return var(la < lb);
}
var lt__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    return var(la < lb);
}
var lt__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    return var(la < lb);
}
var lt__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'list'");
}
var lt__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'set'");
}
var lt__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'dict'");
}
var lt__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'orderedset'");
}
var lt__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'ordereddict'");
}
var lt__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'float' and 'graph'");
}
var lt__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'none'");
}
var lt__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'int'");
}
var lt__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'float'");
}
var lt__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() < b.var_get<std::string>());
}
var lt__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'bool'");
}
var lt__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'double'");
}
var lt__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'long'");
}
var lt__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'long_long'");
}
var lt__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'long_double'");
}
var lt__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'uint'");
}
var lt__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'ulong'");
}
var lt__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'ulong_long'");
}
var lt__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'list'");
}
var lt__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'set'");
}
var lt__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'dict'");
}
var lt__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'orderedset'");
}
var lt__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'ordereddict'");
}
var lt__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'string' and 'graph'");
}
var lt__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'none'");
}
var lt__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la < lb);
}
var lt__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'string'");
}
var lt__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la < lb);
}
var lt__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la < lb);
}
var lt__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la < lb);
}
var lt__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'list'");
}
var lt__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'set'");
}
var lt__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'dict'");
}
var lt__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'orderedset'");
}
var lt__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'ordereddict'");
}
var lt__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'bool' and 'graph'");
}
var lt__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'none'");
}
var lt__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    return var(la < lb);
}
var lt__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    return var(la < lb);
}
var lt__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'string'");
}
var lt__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    return var(la < lb);
}
var lt__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    return var(la < lb);
}
var lt__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    return var(la < lb);
}
var lt__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'list'");
}
var lt__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'set'");
}
var lt__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'dict'");
}
var lt__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'orderedset'");
}
var lt__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'ordereddict'");
}
var lt__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'double' and 'graph'");
}
var lt__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'none'");
}
var lt__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la < lb);
}
var lt__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'string'");
}
var lt__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la < lb);
}
var lt__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la < lb);
}
var lt__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la < lb);
}
var lt__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'list'");
}
var lt__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'set'");
}
var lt__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'dict'");
}
var lt__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'orderedset'");
}
var lt__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'ordereddict'");
}
var lt__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long' and 'graph'");
}
var lt__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'none'");
}
var lt__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la < lb);
}
var lt__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'string'");
}
var lt__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la < lb);
}
var lt__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la < lb);
}
var lt__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la < lb);
}
var lt__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'list'");
}
var lt__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'set'");
}
var lt__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'dict'");
}
var lt__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'orderedset'");
}
var lt__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'ordereddict'");
}
var lt__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_long' and 'graph'");
}
var lt__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'none'");
}
var lt__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    return var(la < lb);
}
var lt__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    return var(la < lb);
}
var lt__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'string'");
}
var lt__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    return var(la < lb);
}
var lt__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    return var(la < lb);
}
var lt__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    return var(la < lb);
}
var lt__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    return var(la < lb);
}
var lt__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'list'");
}
var lt__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'set'");
}
var lt__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'dict'");
}
var lt__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'orderedset'");
}
var lt__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'ordereddict'");
}
var lt__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'long_double' and 'graph'");
}
var lt__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'none'");
}
var lt__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la < lb);
}
var lt__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'string'");
}
var lt__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la < lb);
}
var lt__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la < lb);
}
var lt__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la < lb);
}
var lt__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'list'");
}
var lt__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'set'");
}
var lt__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'dict'");
}
var lt__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'orderedset'");
}
var lt__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'ordereddict'");
}
var lt__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'uint' and 'graph'");
}
var lt__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'none'");
}
var lt__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la < lb);
}
var lt__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'string'");
}
var lt__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la < lb);
}
var lt__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la < lb);
}
var lt__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la < lb);
}
var lt__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'list'");
}
var lt__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'set'");
}
var lt__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'dict'");
}
var lt__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'orderedset'");
}
var lt__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'ordereddict'");
}
var lt__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong' and 'graph'");
}
var lt__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'none'");
}
var lt__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la < lb);
}
var lt__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la < lb);
}
var lt__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'string'");
}
var lt__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la < lb);
}
var lt__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la < lb);
}
var lt__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la < lb);
}
var lt__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la < lb);
}
var lt__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la < lb);
}
var lt__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la < lb);
}
var lt__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la < lb);
}
var lt__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la < lb);
}
var lt__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'list'");
}
var lt__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'set'");
}
var lt__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'dict'");
}
var lt__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'orderedset'");
}
var lt__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'ordereddict'");
}
var lt__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ulong_long' and 'graph'");
}
var lt__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'none'");
}
var lt__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'int'");
}
var lt__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'float'");
}
var lt__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'string'");
}
var lt__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'bool'");
}
var lt__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'double'");
}
var lt__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'long'");
}
var lt__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'long_long'");
}
var lt__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'long_double'");
}
var lt__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'uint'");
}
var lt__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'ulong'");
}
var lt__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'ulong_long'");
}
var lt__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lst1 = a.var_get<pythonic::vars::List>();
    const auto &lst2 = b.var_get<pythonic::vars::List>();
    return var(std::lexicographical_compare(lst1.begin(), lst1.end(), lst2.begin(), lst2.end()));
}
var lt__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'set'");
}
var lt__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'dict'");
}
var lt__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'orderedset'");
}
var lt__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'ordereddict'");
}
var lt__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'list' and 'graph'");
}
var lt__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'none'");
}
var lt__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'int'");
}
var lt__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'float'");
}
var lt__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'string'");
}
var lt__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'bool'");
}
var lt__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'double'");
}
var lt__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'long'");
}
var lt__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'long_long'");
}
var lt__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'long_double'");
}
var lt__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'uint'");
}
var lt__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'ulong'");
}
var lt__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'ulong_long'");
}
var lt__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'list'");
}
var lt__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::Set>();
    const auto &set2 = b.var_get<pythonic::vars::Set>();
    if (set1.size() >= set2.size()) return var(false);
    for (const auto &elem : set1) {
        if (set2.find(elem) == set2.end()) return var(false);
    }
    return var(true);
}
var lt__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'dict'");
}
var lt__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'orderedset'");
}
var lt__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'ordereddict'");
}
var lt__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'set' and 'graph'");
}
var lt__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'none'");
}
var lt__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'int'");
}
var lt__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'float'");
}
var lt__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'string'");
}
var lt__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'bool'");
}
var lt__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'double'");
}
var lt__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'long'");
}
var lt__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'long_long'");
}
var lt__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'long_double'");
}
var lt__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'uint'");
}
var lt__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'ulong'");
}
var lt__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'ulong_long'");
}
var lt__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'list'");
}
var lt__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'set'");
}
var lt__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'dict'");
}
var lt__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'orderedset'");
}
var lt__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'ordereddict'");
}
var lt__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'dict' and 'graph'");
}
var lt__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'none'");
}
var lt__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'int'");
}
var lt__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'float'");
}
var lt__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'string'");
}
var lt__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'bool'");
}
var lt__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'double'");
}
var lt__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'long'");
}
var lt__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'long_long'");
}
var lt__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'long_double'");
}
var lt__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'uint'");
}
var lt__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'ulong'");
}
var lt__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'ulong_long'");
}
var lt__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'list'");
}
var lt__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'set'");
}
var lt__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'dict'");
}
var lt__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::OrderedSet>();
    const auto &set2 = b.var_get<pythonic::vars::OrderedSet>();
    return var(std::lexicographical_compare(set1.begin(), set1.end(), set2.begin(), set2.end()));
}
var lt__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'ordereddict'");
}
var lt__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'orderedset' and 'graph'");
}
var lt__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'none'");
}
var lt__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'int'");
}
var lt__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'float'");
}
var lt__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'string'");
}
var lt__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'bool'");
}
var lt__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'double'");
}
var lt__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'long'");
}
var lt__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'long_long'");
}
var lt__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'long_double'");
}
var lt__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'uint'");
}
var lt__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'ulong'");
}
var lt__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'ulong_long'");
}
var lt__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'list'");
}
var lt__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'set'");
}
var lt__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'dict'");
}
var lt__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'orderedset'");
}
var lt__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::OrderedDict>();
    const auto &dict2 = b.var_get<pythonic::vars::OrderedDict>();
    return var(std::lexicographical_compare(dict1.begin(), dict1.end(), dict2.begin(), dict2.end()));
}
var lt__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'ordereddict' and 'graph'");
}
var lt__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'none'");
}
var lt__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'int'");
}
var lt__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'float'");
}
var lt__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'string'");
}
var lt__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'bool'");
}
var lt__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'double'");
}
var lt__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'long'");
}
var lt__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'long_long'");
}
var lt__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'long_double'");
}
var lt__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'uint'");
}
var lt__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'ulong'");
}
var lt__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'ulong_long'");
}
var lt__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'list'");
}
var lt__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'set'");
}
var lt__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'dict'");
}
var lt__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'orderedset'");
}
var lt__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'ordereddict'");
}
var lt__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <: 'graph' and 'graph'");
}

// Stub definitions for le
var le__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'none'");
}
var le__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'int'");
}
var le__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'float'");
}
var le__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'string'");
}
var le__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'bool'");
}
var le__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'double'");
}
var le__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'long'");
}
var le__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'long_long'");
}
var le__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'long_double'");
}
var le__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'uint'");
}
var le__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'ulong'");
}
var le__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'ulong_long'");
}
var le__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'list'");
}
var le__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'set'");
}
var le__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'dict'");
}
var le__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'orderedset'");
}
var le__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'ordereddict'");
}
var le__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'none' and 'graph'");
}
var le__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'none'");
}
var le__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la <= lb);
}
var le__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'string'");
}
var le__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la <= lb);
}
var le__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la <= lb);
}
var le__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la <= lb);
}
var le__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'list'");
}
var le__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'set'");
}
var le__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'dict'");
}
var le__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'orderedset'");
}
var le__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'ordereddict'");
}
var le__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'int' and 'graph'");
}
var le__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'none'");
}
var le__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<int>());
    return var(la <= lb);
}
var le__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'string'");
}
var le__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<bool>());
    return var(la <= lb);
}
var le__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<float>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long>());
    return var(la <= lb);
}
var le__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<long long>());
    return var(la <= lb);
}
var le__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<float>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<float>());
    float lb = static_cast<float>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'list'");
}
var le__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'set'");
}
var le__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'dict'");
}
var le__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'orderedset'");
}
var le__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'ordereddict'");
}
var le__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'float' and 'graph'");
}
var le__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'none'");
}
var le__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'int'");
}
var le__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'float'");
}
var le__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(a.var_get<std::string>() <= b.var_get<std::string>());
}
var le__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'bool'");
}
var le__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'double'");
}
var le__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'long'");
}
var le__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'long_long'");
}
var le__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'long_double'");
}
var le__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'uint'");
}
var le__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'ulong'");
}
var le__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'ulong_long'");
}
var le__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'list'");
}
var le__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'set'");
}
var le__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'dict'");
}
var le__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'orderedset'");
}
var le__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'ordereddict'");
}
var le__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'string' and 'graph'");
}
var le__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'none'");
}
var le__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la <= lb);
}
var le__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<bool>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'string'");
}
var le__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la <= lb);
}
var le__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<bool>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la <= lb);
}
var le__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la <= lb);
}
var le__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<bool>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'list'");
}
var le__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'set'");
}
var le__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'dict'");
}
var le__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'orderedset'");
}
var le__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'ordereddict'");
}
var le__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'bool' and 'graph'");
}
var le__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'none'");
}
var le__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<int>());
    return var(la <= lb);
}
var le__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<float>());
    return var(la <= lb);
}
var le__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'string'");
}
var le__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<bool>());
    return var(la <= lb);
}
var le__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long>());
    return var(la <= lb);
}
var le__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<long long>());
    return var(la <= lb);
}
var le__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<double>());
    double lb = static_cast<double>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'list'");
}
var le__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'set'");
}
var le__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'dict'");
}
var le__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'orderedset'");
}
var le__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'ordereddict'");
}
var le__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'double' and 'graph'");
}
var le__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'none'");
}
var le__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la <= lb);
}
var le__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'string'");
}
var le__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la <= lb);
}
var le__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la <= lb);
}
var le__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la <= lb);
}
var le__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'list'");
}
var le__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'set'");
}
var le__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'dict'");
}
var le__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'orderedset'");
}
var le__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'ordereddict'");
}
var le__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long' and 'graph'");
}
var le__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'none'");
}
var le__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la <= lb);
}
var le__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'string'");
}
var le__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la <= lb);
}
var le__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la <= lb);
}
var le__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la <= lb);
}
var le__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'list'");
}
var le__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'set'");
}
var le__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'dict'");
}
var le__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'orderedset'");
}
var le__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'ordereddict'");
}
var le__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_long' and 'graph'");
}
var le__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'none'");
}
var le__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<int>());
    return var(la <= lb);
}
var le__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<float>());
    return var(la <= lb);
}
var le__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'string'");
}
var le__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<bool>());
    return var(la <= lb);
}
var le__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<double>());
    return var(la <= lb);
}
var le__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long>());
    return var(la <= lb);
}
var le__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long long>());
    return var(la <= lb);
}
var le__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<long double>());
    long double lb = static_cast<long double>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'list'");
}
var le__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'set'");
}
var le__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'dict'");
}
var le__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'orderedset'");
}
var le__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'ordereddict'");
}
var le__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'long_double' and 'graph'");
}
var le__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'none'");
}
var le__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la <= lb);
}
var le__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned int>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'string'");
}
var le__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<unsigned int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la <= lb);
}
var le__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned int>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la <= lb);
}
var le__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la <= lb);
}
var le__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned int>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'list'");
}
var le__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'set'");
}
var le__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'dict'");
}
var le__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'orderedset'");
}
var le__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'ordereddict'");
}
var le__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'uint' and 'graph'");
}
var le__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'none'");
}
var le__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la <= lb);
}
var le__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'string'");
}
var le__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la <= lb);
}
var le__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<unsigned long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la <= lb);
}
var le__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la <= lb);
}
var le__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'list'");
}
var le__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'set'");
}
var le__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'dict'");
}
var le__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'orderedset'");
}
var le__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'ordereddict'");
}
var le__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong' and 'graph'");
}
var le__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'none'");
}
var le__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la <= lb);
}
var le__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    float la = static_cast<float>(a.var_get<unsigned long long>());
    float lb = static_cast<float>(b.var_get<float>());
    return var(la <= lb);
}
var le__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'string'");
}
var le__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la <= lb);
}
var le__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    double la = static_cast<double>(a.var_get<unsigned long long>());
    double lb = static_cast<double>(b.var_get<double>());
    return var(la <= lb);
}
var le__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la <= lb);
}
var le__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<unsigned long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la <= lb);
}
var le__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long double la = static_cast<long double>(a.var_get<unsigned long long>());
    long double lb = static_cast<long double>(b.var_get<long double>());
    return var(la <= lb);
}
var le__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la <= lb);
}
var le__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la <= lb);
}
var le__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la <= lb);
}
var le__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'list'");
}
var le__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'set'");
}
var le__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'dict'");
}
var le__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'orderedset'");
}
var le__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'ordereddict'");
}
var le__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ulong_long' and 'graph'");
}
var le__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'none'");
}
var le__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'int'");
}
var le__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'float'");
}
var le__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'string'");
}
var le__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'bool'");
}
var le__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'double'");
}
var le__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'long'");
}
var le__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'long_long'");
}
var le__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'long_double'");
}
var le__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'uint'");
}
var le__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'ulong'");
}
var le__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'ulong_long'");
}
var le__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lst1 = a.var_get<pythonic::vars::List>();
    const auto &lst2 = b.var_get<pythonic::vars::List>();
    return var(!std::lexicographical_compare(lst2.begin(), lst2.end(), lst1.begin(), lst1.end()));
}
var le__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'set'");
}
var le__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'dict'");
}
var le__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'orderedset'");
}
var le__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'ordereddict'");
}
var le__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'list' and 'graph'");
}
var le__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'none'");
}
var le__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'int'");
}
var le__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'float'");
}
var le__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'string'");
}
var le__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'bool'");
}
var le__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'double'");
}
var le__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'long'");
}
var le__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'long_long'");
}
var le__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'long_double'");
}
var le__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'uint'");
}
var le__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'ulong'");
}
var le__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'ulong_long'");
}
var le__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'list'");
}
var le__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::Set>();
    const auto &set2 = b.var_get<pythonic::vars::Set>();
    for (const auto &elem : set1) {
        if (set2.find(elem) == set2.end()) return var(false);
    }
    return var(true);
}
var le__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'dict'");
}
var le__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'orderedset'");
}
var le__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'ordereddict'");
}
var le__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'set' and 'graph'");
}
var le__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'none'");
}
var le__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'int'");
}
var le__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'float'");
}
var le__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'string'");
}
var le__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'bool'");
}
var le__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'double'");
}
var le__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'long'");
}
var le__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'long_long'");
}
var le__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'long_double'");
}
var le__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'uint'");
}
var le__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'ulong'");
}
var le__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'ulong_long'");
}
var le__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'list'");
}
var le__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'set'");
}
var le__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'dict'");
}
var le__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'orderedset'");
}
var le__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'ordereddict'");
}
var le__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'dict' and 'graph'");
}
var le__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'none'");
}
var le__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'int'");
}
var le__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'float'");
}
var le__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'string'");
}
var le__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'bool'");
}
var le__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'double'");
}
var le__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'long'");
}
var le__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'long_long'");
}
var le__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'long_double'");
}
var le__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'uint'");
}
var le__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'ulong'");
}
var le__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'ulong_long'");
}
var le__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'list'");
}
var le__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'set'");
}
var le__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'dict'");
}
var le__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &set1 = a.var_get<pythonic::vars::OrderedSet>();
    const auto &set2 = b.var_get<pythonic::vars::OrderedSet>();
    return var(!std::lexicographical_compare(set2.begin(), set2.end(), set1.begin(), set1.end()));
}
var le__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'ordereddict'");
}
var le__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'orderedset' and 'graph'");
}
var le__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'none'");
}
var le__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'int'");
}
var le__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'float'");
}
var le__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'string'");
}
var le__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'bool'");
}
var le__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'double'");
}
var le__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'long'");
}
var le__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'long_long'");
}
var le__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'long_double'");
}
var le__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'uint'");
}
var le__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'ulong'");
}
var le__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'ulong_long'");
}
var le__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'list'");
}
var le__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'set'");
}
var le__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'dict'");
}
var le__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'orderedset'");
}
var le__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &dict1 = a.var_get<pythonic::vars::OrderedDict>();
    const auto &dict2 = b.var_get<pythonic::vars::OrderedDict>();
    return var(!std::lexicographical_compare(dict2.begin(), dict2.end(), dict1.begin(), dict1.end()));
}
var le__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'ordereddict' and 'graph'");
}
var le__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'none'");
}
var le__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'int'");
}
var le__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'float'");
}
var le__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'string'");
}
var le__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'bool'");
}
var le__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'double'");
}
var le__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'long'");
}
var le__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'long_long'");
}
var le__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'long_double'");
}
var le__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'uint'");
}
var le__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'ulong'");
}
var le__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'ulong_long'");
}
var le__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'list'");
}
var le__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'set'");
}
var le__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'dict'");
}
var le__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'orderedset'");
}
var le__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'ordereddict'");
}
var le__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <=: 'graph' and 'graph'");
}

// Stub definitions for band
var band__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'none'");
}
var band__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'int'");
}
var band__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'float'");
}
var band__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'string'");
}
var band__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'bool'");
}
var band__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'double'");
}
var band__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'long'");
}
var band__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'long_long'");
}
var band__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'long_double'");
}
var band__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'uint'");
}
var band__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'ulong'");
}
var band__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'ulong_long'");
}
var band__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'list'");
}
var band__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'set'");
}
var band__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'dict'");
}
var band__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'orderedset'");
}
var band__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'ordereddict'");
}
var band__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'none' and 'graph'");
}
var band__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'none'");
}
var band__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la & lb);
}
var band__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'float'");
}
var band__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'string'");
}
var band__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la & lb);
}
var band__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'double'");
}
var band__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la & lb);
}
var band__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la & lb);
}
var band__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'long_double'");
}
var band__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la & lb);
}
var band__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la & lb);
}
var band__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la & lb);
}
var band__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'list'");
}
var band__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'set'");
}
var band__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'dict'");
}
var band__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'orderedset'");
}
var band__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'ordereddict'");
}
var band__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'int' and 'graph'");
}
var band__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'none'");
}
var band__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'int'");
}
var band__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'float'");
}
var band__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'string'");
}
var band__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'bool'");
}
var band__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'double'");
}
var band__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'long'");
}
var band__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'long_long'");
}
var band__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'long_double'");
}
var band__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'uint'");
}
var band__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'ulong'");
}
var band__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'ulong_long'");
}
var band__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'list'");
}
var band__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'set'");
}
var band__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'dict'");
}
var band__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'orderedset'");
}
var band__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'ordereddict'");
}
var band__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'float' and 'graph'");
}
var band__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'none'");
}
var band__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'int'");
}
var band__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'float'");
}
var band__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'string'");
}
var band__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'bool'");
}
var band__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'double'");
}
var band__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'long'");
}
var band__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'long_long'");
}
var band__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'long_double'");
}
var band__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'uint'");
}
var band__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'ulong'");
}
var band__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'ulong_long'");
}
var band__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'list'");
}
var band__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'set'");
}
var band__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'dict'");
}
var band__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'orderedset'");
}
var band__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'ordereddict'");
}
var band__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'string' and 'graph'");
}
var band__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'none'");
}
var band__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la & lb);
}
var band__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'float'");
}
var band__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'string'");
}
var band__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(static_cast<bool>(a.var_get<bool>() & b.var_get<bool>()));
}
var band__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'double'");
}
var band__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la & lb);
}
var band__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la & lb);
}
var band__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'long_double'");
}
var band__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<bool>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la & lb);
}
var band__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la & lb);
}
var band__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la & lb);
}
var band__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'list'");
}
var band__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'set'");
}
var band__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'dict'");
}
var band__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'orderedset'");
}
var band__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'ordereddict'");
}
var band__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'bool' and 'graph'");
}
var band__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'none'");
}
var band__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'int'");
}
var band__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'float'");
}
var band__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'string'");
}
var band__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'bool'");
}
var band__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'double'");
}
var band__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'long'");
}
var band__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'long_long'");
}
var band__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'long_double'");
}
var band__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'uint'");
}
var band__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'ulong'");
}
var band__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'ulong_long'");
}
var band__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'list'");
}
var band__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'set'");
}
var band__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'dict'");
}
var band__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'orderedset'");
}
var band__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'ordereddict'");
}
var band__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'double' and 'graph'");
}
var band__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'none'");
}
var band__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la & lb);
}
var band__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'float'");
}
var band__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'string'");
}
var band__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la & lb);
}
var band__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'double'");
}
var band__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la & lb);
}
var band__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la & lb);
}
var band__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'long_double'");
}
var band__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la & lb);
}
var band__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la & lb);
}
var band__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la & lb);
}
var band__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'list'");
}
var band__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'set'");
}
var band__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'dict'");
}
var band__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'orderedset'");
}
var band__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'ordereddict'");
}
var band__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long' and 'graph'");
}
var band__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'none'");
}
var band__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la & lb);
}
var band__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'float'");
}
var band__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'string'");
}
var band__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la & lb);
}
var band__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'double'");
}
var band__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la & lb);
}
var band__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la & lb);
}
var band__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'long_double'");
}
var band__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la & lb);
}
var band__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la & lb);
}
var band__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la & lb);
}
var band__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'list'");
}
var band__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'set'");
}
var band__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'dict'");
}
var band__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'orderedset'");
}
var band__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'ordereddict'");
}
var band__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_long' and 'graph'");
}
var band__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'none'");
}
var band__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'int'");
}
var band__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'float'");
}
var band__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'string'");
}
var band__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'bool'");
}
var band__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'double'");
}
var band__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'long'");
}
var band__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'long_long'");
}
var band__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'long_double'");
}
var band__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'uint'");
}
var band__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'ulong'");
}
var band__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'ulong_long'");
}
var band__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'list'");
}
var band__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'set'");
}
var band__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'dict'");
}
var band__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'orderedset'");
}
var band__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'ordereddict'");
}
var band__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'long_double' and 'graph'");
}
var band__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'none'");
}
var band__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<int>());
    return var(la & lb);
}
var band__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'float'");
}
var band__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'string'");
}
var band__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<bool>());
    return var(la & lb);
}
var band__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'double'");
}
var band__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long>());
    return var(la & lb);
}
var band__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long long>());
    return var(la & lb);
}
var band__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'long_double'");
}
var band__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la & lb);
}
var band__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la & lb);
}
var band__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la & lb);
}
var band__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'list'");
}
var band__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'set'");
}
var band__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'dict'");
}
var band__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'orderedset'");
}
var band__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'ordereddict'");
}
var band__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'uint' and 'graph'");
}
var band__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'none'");
}
var band__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la & lb);
}
var band__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'float'");
}
var band__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'string'");
}
var band__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la & lb);
}
var band__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'double'");
}
var band__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long>());
    return var(la & lb);
}
var band__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long long>());
    return var(la & lb);
}
var band__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'long_double'");
}
var band__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la & lb);
}
var band__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la & lb);
}
var band__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la & lb);
}
var band__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'list'");
}
var band__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'set'");
}
var band__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'dict'");
}
var band__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'orderedset'");
}
var band__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'ordereddict'");
}
var band__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong' and 'graph'");
}
var band__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'none'");
}
var band__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la & lb);
}
var band__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'float'");
}
var band__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'string'");
}
var band__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la & lb);
}
var band__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'double'");
}
var band__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la & lb);
}
var band__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long long>());
    return var(la & lb);
}
var band__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'long_double'");
}
var band__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la & lb);
}
var band__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la & lb);
}
var band__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la & lb);
}
var band__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'list'");
}
var band__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'set'");
}
var band__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'dict'");
}
var band__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'orderedset'");
}
var band__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'ordereddict'");
}
var band__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ulong_long' and 'graph'");
}
var band__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'none'");
}
var band__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'int'");
}
var band__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'float'");
}
var band__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'string'");
}
var band__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'bool'");
}
var band__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'double'");
}
var band__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'long'");
}
var band__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'long_long'");
}
var band__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'long_double'");
}
var band__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'uint'");
}
var band__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'ulong'");
}
var band__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'ulong_long'");
}
var band__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::List>();
    const auto &rhs = b.var_get<pythonic::vars::List>();
    pythonic::vars::List result;
    pythonic::vars::Set rhs_set(rhs.begin(), rhs.end());
    for (const auto &item : lhs) {
        if (rhs_set.find(item) != rhs_set.end()) {
            result.push_back(item);
        }
    }
    return var(std::move(result));
}
var band__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'set'");
}
var band__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'dict'");
}
var band__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'orderedset'");
}
var band__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'ordereddict'");
}
var band__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'list' and 'graph'");
}
var band__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'none'");
}
var band__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'int'");
}
var band__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'float'");
}
var band__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'string'");
}
var band__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'bool'");
}
var band__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'double'");
}
var band__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'long'");
}
var band__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'long_long'");
}
var band__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'long_double'");
}
var band__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'uint'");
}
var band__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'ulong'");
}
var band__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'ulong_long'");
}
var band__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'list'");
}
var band__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::Set>();
    const auto &rhs = b.var_get<pythonic::vars::Set>();
    pythonic::vars::Set result;
    for (const auto &item : lhs) {
        if (rhs.find(item) != rhs.end()) {
            result.insert(item);
        }
    }
    return var(std::move(result));
}
var band__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'dict'");
}
var band__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'orderedset'");
}
var band__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'ordereddict'");
}
var band__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'set' and 'graph'");
}
var band__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'none'");
}
var band__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'int'");
}
var band__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'float'");
}
var band__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'string'");
}
var band__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'bool'");
}
var band__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'double'");
}
var band__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'long'");
}
var band__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'long_long'");
}
var band__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'long_double'");
}
var band__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'uint'");
}
var band__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'ulong'");
}
var band__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'ulong_long'");
}
var band__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'list'");
}
var band__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'set'");
}
var band__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::Dict>();
    const auto &rhs = b.var_get<pythonic::vars::Dict>();
    pythonic::vars::Dict result;
    for (const auto &[key, val] : lhs) {
        if (rhs.find(key) != rhs.end()) {
            result[key] = val;
        }
    }
    return var(std::move(result));
}
var band__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'orderedset'");
}
var band__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'ordereddict'");
}
var band__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'dict' and 'graph'");
}
var band__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'none'");
}
var band__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'int'");
}
var band__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'float'");
}
var band__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'string'");
}
var band__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'bool'");
}
var band__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'double'");
}
var band__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'long'");
}
var band__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'long_long'");
}
var band__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'long_double'");
}
var band__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'uint'");
}
var band__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'ulong'");
}
var band__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'ulong_long'");
}
var band__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'list'");
}
var band__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'set'");
}
var band__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'dict'");
}
var band__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::OrderedSet>();
    const auto &rhs = b.var_get<pythonic::vars::OrderedSet>();
    pythonic::vars::OrderedSet result;
    auto it_lhs = lhs.begin();
    auto it_rhs = rhs.begin();
    while (it_lhs != lhs.end() && it_rhs != rhs.end()) {
        if (*it_lhs < *it_rhs) {
            ++it_lhs;
        } else if (*it_rhs < *it_lhs) {
            ++it_rhs;
        } else {
            result.insert(*it_lhs);
            ++it_lhs;
            ++it_rhs;
        }
    }
    return var(std::move(result));
}
var band__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'ordereddict'");
}
var band__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'orderedset' and 'graph'");
}
var band__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'none'");
}
var band__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'int'");
}
var band__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'float'");
}
var band__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'string'");
}
var band__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'bool'");
}
var band__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'double'");
}
var band__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'long'");
}
var band__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'long_long'");
}
var band__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'long_double'");
}
var band__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'uint'");
}
var band__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'ulong'");
}
var band__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'ulong_long'");
}
var band__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'list'");
}
var band__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'set'");
}
var band__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'dict'");
}
var band__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'orderedset'");
}
var band__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::OrderedDict>();
    const auto &rhs = b.var_get<pythonic::vars::OrderedDict>();
    pythonic::vars::OrderedDict result;
    for (const auto &[key, val] : lhs) {
        if (rhs.find(key) != rhs.end()) {
            result[key] = val;
        }
    }
    return var(std::move(result));
}
var band__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'ordereddict' and 'graph'");
}
var band__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'none'");
}
var band__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'int'");
}
var band__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'float'");
}
var band__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'string'");
}
var band__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'bool'");
}
var band__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'double'");
}
var band__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'long'");
}
var band__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'long_long'");
}
var band__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'long_double'");
}
var band__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'uint'");
}
var band__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'ulong'");
}
var band__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'ulong_long'");
}
var band__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'list'");
}
var band__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'set'");
}
var band__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'dict'");
}
var band__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'orderedset'");
}
var band__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'ordereddict'");
}
var band__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for &: 'graph' and 'graph'");
}

// Stub definitions for bor
var bor__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'none'");
}
var bor__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'int'");
}
var bor__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'float'");
}
var bor__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'string'");
}
var bor__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'bool'");
}
var bor__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'double'");
}
var bor__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'long'");
}
var bor__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'long_long'");
}
var bor__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'long_double'");
}
var bor__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'uint'");
}
var bor__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'ulong'");
}
var bor__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'ulong_long'");
}
var bor__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'list'");
}
var bor__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'set'");
}
var bor__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'dict'");
}
var bor__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'orderedset'");
}
var bor__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'ordereddict'");
}
var bor__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'none' and 'graph'");
}
var bor__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'none'");
}
var bor__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la | lb);
}
var bor__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'float'");
}
var bor__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'string'");
}
var bor__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la | lb);
}
var bor__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'double'");
}
var bor__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la | lb);
}
var bor__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la | lb);
}
var bor__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'long_double'");
}
var bor__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la | lb);
}
var bor__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la | lb);
}
var bor__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la | lb);
}
var bor__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'list'");
}
var bor__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'set'");
}
var bor__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'dict'");
}
var bor__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'orderedset'");
}
var bor__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'ordereddict'");
}
var bor__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'int' and 'graph'");
}
var bor__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'none'");
}
var bor__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'int'");
}
var bor__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'float'");
}
var bor__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'string'");
}
var bor__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'bool'");
}
var bor__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'double'");
}
var bor__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'long'");
}
var bor__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'long_long'");
}
var bor__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'long_double'");
}
var bor__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'uint'");
}
var bor__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'ulong'");
}
var bor__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'ulong_long'");
}
var bor__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'list'");
}
var bor__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'set'");
}
var bor__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'dict'");
}
var bor__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'orderedset'");
}
var bor__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'ordereddict'");
}
var bor__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'float' and 'graph'");
}
var bor__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'none'");
}
var bor__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'int'");
}
var bor__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'float'");
}
var bor__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'string'");
}
var bor__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'bool'");
}
var bor__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'double'");
}
var bor__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'long'");
}
var bor__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'long_long'");
}
var bor__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'long_double'");
}
var bor__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'uint'");
}
var bor__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'ulong'");
}
var bor__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'ulong_long'");
}
var bor__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'list'");
}
var bor__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'set'");
}
var bor__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'dict'");
}
var bor__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'orderedset'");
}
var bor__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'ordereddict'");
}
var bor__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'string' and 'graph'");
}
var bor__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'none'");
}
var bor__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la | lb);
}
var bor__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'float'");
}
var bor__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'string'");
}
var bor__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(static_cast<bool>(a.var_get<bool>() | b.var_get<bool>()));
}
var bor__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'double'");
}
var bor__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la | lb);
}
var bor__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la | lb);
}
var bor__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'long_double'");
}
var bor__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<bool>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la | lb);
}
var bor__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la | lb);
}
var bor__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la | lb);
}
var bor__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'list'");
}
var bor__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'set'");
}
var bor__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'dict'");
}
var bor__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'orderedset'");
}
var bor__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'ordereddict'");
}
var bor__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'bool' and 'graph'");
}
var bor__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'none'");
}
var bor__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'int'");
}
var bor__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'float'");
}
var bor__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'string'");
}
var bor__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'bool'");
}
var bor__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'double'");
}
var bor__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'long'");
}
var bor__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'long_long'");
}
var bor__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'long_double'");
}
var bor__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'uint'");
}
var bor__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'ulong'");
}
var bor__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'ulong_long'");
}
var bor__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'list'");
}
var bor__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'set'");
}
var bor__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'dict'");
}
var bor__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'orderedset'");
}
var bor__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'ordereddict'");
}
var bor__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'double' and 'graph'");
}
var bor__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'none'");
}
var bor__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la | lb);
}
var bor__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'float'");
}
var bor__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'string'");
}
var bor__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la | lb);
}
var bor__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'double'");
}
var bor__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la | lb);
}
var bor__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la | lb);
}
var bor__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'long_double'");
}
var bor__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la | lb);
}
var bor__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la | lb);
}
var bor__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la | lb);
}
var bor__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'list'");
}
var bor__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'set'");
}
var bor__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'dict'");
}
var bor__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'orderedset'");
}
var bor__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'ordereddict'");
}
var bor__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long' and 'graph'");
}
var bor__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'none'");
}
var bor__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la | lb);
}
var bor__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'float'");
}
var bor__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'string'");
}
var bor__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la | lb);
}
var bor__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'double'");
}
var bor__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la | lb);
}
var bor__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la | lb);
}
var bor__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'long_double'");
}
var bor__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la | lb);
}
var bor__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la | lb);
}
var bor__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la | lb);
}
var bor__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'list'");
}
var bor__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'set'");
}
var bor__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'dict'");
}
var bor__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'orderedset'");
}
var bor__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'ordereddict'");
}
var bor__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_long' and 'graph'");
}
var bor__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'none'");
}
var bor__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'int'");
}
var bor__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'float'");
}
var bor__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'string'");
}
var bor__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'bool'");
}
var bor__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'double'");
}
var bor__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'long'");
}
var bor__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'long_long'");
}
var bor__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'long_double'");
}
var bor__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'uint'");
}
var bor__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'ulong'");
}
var bor__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'ulong_long'");
}
var bor__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'list'");
}
var bor__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'set'");
}
var bor__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'dict'");
}
var bor__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'orderedset'");
}
var bor__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'ordereddict'");
}
var bor__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'long_double' and 'graph'");
}
var bor__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'none'");
}
var bor__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<int>());
    return var(la | lb);
}
var bor__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'float'");
}
var bor__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'string'");
}
var bor__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<bool>());
    return var(la | lb);
}
var bor__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'double'");
}
var bor__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long>());
    return var(la | lb);
}
var bor__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long long>());
    return var(la | lb);
}
var bor__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'long_double'");
}
var bor__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la | lb);
}
var bor__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la | lb);
}
var bor__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la | lb);
}
var bor__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'list'");
}
var bor__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'set'");
}
var bor__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'dict'");
}
var bor__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'orderedset'");
}
var bor__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'ordereddict'");
}
var bor__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'uint' and 'graph'");
}
var bor__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'none'");
}
var bor__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la | lb);
}
var bor__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'float'");
}
var bor__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'string'");
}
var bor__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la | lb);
}
var bor__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'double'");
}
var bor__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long>());
    return var(la | lb);
}
var bor__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long long>());
    return var(la | lb);
}
var bor__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'long_double'");
}
var bor__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la | lb);
}
var bor__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la | lb);
}
var bor__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la | lb);
}
var bor__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'list'");
}
var bor__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'set'");
}
var bor__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'dict'");
}
var bor__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'orderedset'");
}
var bor__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'ordereddict'");
}
var bor__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong' and 'graph'");
}
var bor__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'none'");
}
var bor__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la | lb);
}
var bor__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'float'");
}
var bor__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'string'");
}
var bor__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la | lb);
}
var bor__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'double'");
}
var bor__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la | lb);
}
var bor__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long long>());
    return var(la | lb);
}
var bor__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'long_double'");
}
var bor__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la | lb);
}
var bor__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la | lb);
}
var bor__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la | lb);
}
var bor__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'list'");
}
var bor__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'set'");
}
var bor__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'dict'");
}
var bor__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'orderedset'");
}
var bor__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'ordereddict'");
}
var bor__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ulong_long' and 'graph'");
}
var bor__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'none'");
}
var bor__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'int'");
}
var bor__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'float'");
}
var bor__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'string'");
}
var bor__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'bool'");
}
var bor__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'double'");
}
var bor__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'long'");
}
var bor__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'long_long'");
}
var bor__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'long_double'");
}
var bor__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'uint'");
}
var bor__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'ulong'");
}
var bor__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'ulong_long'");
}
var bor__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::List>();
    const auto &rhs = b.var_get<pythonic::vars::List>();
    pythonic::vars::List result;
    result.reserve(lhs.size() + rhs.size());
    result.insert(result.end(), lhs.begin(), lhs.end());
    result.insert(result.end(), rhs.begin(), rhs.end());
    return var(std::move(result));
}
var bor__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'set'");
}
var bor__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'dict'");
}
var bor__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'orderedset'");
}
var bor__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'ordereddict'");
}
var bor__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'list' and 'graph'");
}
var bor__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'none'");
}
var bor__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'int'");
}
var bor__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'float'");
}
var bor__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'string'");
}
var bor__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'bool'");
}
var bor__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'double'");
}
var bor__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'long'");
}
var bor__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'long_long'");
}
var bor__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'long_double'");
}
var bor__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'uint'");
}
var bor__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'ulong'");
}
var bor__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'ulong_long'");
}
var bor__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'list'");
}
var bor__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::Set>();
    const auto &rhs = b.var_get<pythonic::vars::Set>();
    pythonic::vars::Set result = lhs;
    result.insert(rhs.begin(), rhs.end());
    return var(std::move(result));
}
var bor__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'dict'");
}
var bor__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'orderedset'");
}
var bor__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'ordereddict'");
}
var bor__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'set' and 'graph'");
}
var bor__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'none'");
}
var bor__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'int'");
}
var bor__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'float'");
}
var bor__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'string'");
}
var bor__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'bool'");
}
var bor__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'double'");
}
var bor__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'long'");
}
var bor__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'long_long'");
}
var bor__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'long_double'");
}
var bor__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'uint'");
}
var bor__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'ulong'");
}
var bor__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'ulong_long'");
}
var bor__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'list'");
}
var bor__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'set'");
}
var bor__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::Dict>();
    const auto &rhs = b.var_get<pythonic::vars::Dict>();
    pythonic::vars::Dict result = lhs;
    for (const auto &[key, val] : rhs) {
        result[key] = val;
    }
    return var(std::move(result));
}
var bor__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'orderedset'");
}
var bor__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'ordereddict'");
}
var bor__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'dict' and 'graph'");
}
var bor__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'none'");
}
var bor__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'int'");
}
var bor__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'float'");
}
var bor__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'string'");
}
var bor__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'bool'");
}
var bor__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'double'");
}
var bor__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'long'");
}
var bor__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'long_long'");
}
var bor__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'long_double'");
}
var bor__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'uint'");
}
var bor__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'ulong'");
}
var bor__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'ulong_long'");
}
var bor__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'list'");
}
var bor__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'set'");
}
var bor__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'dict'");
}
var bor__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::OrderedSet>();
    const auto &rhs = b.var_get<pythonic::vars::OrderedSet>();
    pythonic::vars::OrderedSet result;
    auto it_lhs = lhs.begin();
    auto it_rhs = rhs.begin();
    while (it_lhs != lhs.end() && it_rhs != rhs.end()) {
        if (*it_lhs < *it_rhs) {
            result.insert(*it_lhs);
            ++it_lhs;
        } else if (*it_rhs < *it_lhs) {
            result.insert(*it_rhs);
            ++it_rhs;
        } else {
            result.insert(*it_lhs);
            ++it_lhs;
            ++it_rhs;
        }
    }
    while (it_lhs != lhs.end()) {
        result.insert(*it_lhs);
        ++it_lhs;
    }
    while (it_rhs != rhs.end()) {
        result.insert(*it_rhs);
        ++it_rhs;
    }
    return var(std::move(result));
}
var bor__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'ordereddict'");
}
var bor__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'orderedset' and 'graph'");
}
var bor__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'none'");
}
var bor__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'int'");
}
var bor__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'float'");
}
var bor__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'string'");
}
var bor__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'bool'");
}
var bor__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'double'");
}
var bor__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'long'");
}
var bor__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'long_long'");
}
var bor__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'long_double'");
}
var bor__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'uint'");
}
var bor__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'ulong'");
}
var bor__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'ulong_long'");
}
var bor__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'list'");
}
var bor__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'set'");
}
var bor__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'dict'");
}
var bor__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'orderedset'");
}
var bor__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::OrderedDict>();
    const auto &rhs = b.var_get<pythonic::vars::OrderedDict>();
    pythonic::vars::OrderedDict result = lhs;
    for (const auto &[key, val] : rhs) {
        result[key] = val;
    }
    return var(std::move(result));
}
var bor__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'ordereddict' and 'graph'");
}
var bor__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'none'");
}
var bor__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'int'");
}
var bor__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'float'");
}
var bor__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'string'");
}
var bor__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'bool'");
}
var bor__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'double'");
}
var bor__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'long'");
}
var bor__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'long_long'");
}
var bor__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'long_double'");
}
var bor__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'uint'");
}
var bor__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'ulong'");
}
var bor__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'ulong_long'");
}
var bor__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'list'");
}
var bor__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'set'");
}
var bor__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'dict'");
}
var bor__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'orderedset'");
}
var bor__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'ordereddict'");
}
var bor__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for |: 'graph' and 'graph'");
}

// Stub definitions for bxor
var bxor__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'none'");
}
var bxor__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'int'");
}
var bxor__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'float'");
}
var bxor__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'string'");
}
var bxor__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'bool'");
}
var bxor__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'double'");
}
var bxor__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'long'");
}
var bxor__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'long_long'");
}
var bxor__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'long_double'");
}
var bxor__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'uint'");
}
var bxor__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'ulong'");
}
var bxor__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'ulong_long'");
}
var bxor__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'list'");
}
var bxor__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'set'");
}
var bxor__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'dict'");
}
var bxor__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'orderedset'");
}
var bxor__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'ordereddict'");
}
var bxor__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'none' and 'graph'");
}
var bxor__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'none'");
}
var bxor__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la ^ lb);
}
var bxor__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'float'");
}
var bxor__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'string'");
}
var bxor__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la ^ lb);
}
var bxor__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'double'");
}
var bxor__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la ^ lb);
}
var bxor__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la ^ lb);
}
var bxor__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'long_double'");
}
var bxor__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la ^ lb);
}
var bxor__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la ^ lb);
}
var bxor__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la ^ lb);
}
var bxor__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'list'");
}
var bxor__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'set'");
}
var bxor__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'dict'");
}
var bxor__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'orderedset'");
}
var bxor__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'ordereddict'");
}
var bxor__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'int' and 'graph'");
}
var bxor__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'none'");
}
var bxor__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'int'");
}
var bxor__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'float'");
}
var bxor__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'string'");
}
var bxor__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'bool'");
}
var bxor__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'double'");
}
var bxor__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'long'");
}
var bxor__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'long_long'");
}
var bxor__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'long_double'");
}
var bxor__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'uint'");
}
var bxor__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'ulong'");
}
var bxor__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'ulong_long'");
}
var bxor__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'list'");
}
var bxor__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'set'");
}
var bxor__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'dict'");
}
var bxor__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'orderedset'");
}
var bxor__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'ordereddict'");
}
var bxor__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'float' and 'graph'");
}
var bxor__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'none'");
}
var bxor__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'int'");
}
var bxor__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'float'");
}
var bxor__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'string'");
}
var bxor__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'bool'");
}
var bxor__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'double'");
}
var bxor__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'long'");
}
var bxor__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'long_long'");
}
var bxor__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'long_double'");
}
var bxor__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'uint'");
}
var bxor__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'ulong'");
}
var bxor__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'ulong_long'");
}
var bxor__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'list'");
}
var bxor__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'set'");
}
var bxor__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'dict'");
}
var bxor__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'orderedset'");
}
var bxor__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'ordereddict'");
}
var bxor__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'string' and 'graph'");
}
var bxor__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'none'");
}
var bxor__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la ^ lb);
}
var bxor__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'float'");
}
var bxor__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'string'");
}
var bxor__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    return var(static_cast<bool>(a.var_get<bool>() ^ b.var_get<bool>()));
}
var bxor__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'double'");
}
var bxor__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la ^ lb);
}
var bxor__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la ^ lb);
}
var bxor__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'long_double'");
}
var bxor__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<bool>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la ^ lb);
}
var bxor__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la ^ lb);
}
var bxor__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la ^ lb);
}
var bxor__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'list'");
}
var bxor__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'set'");
}
var bxor__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'dict'");
}
var bxor__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'orderedset'");
}
var bxor__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'ordereddict'");
}
var bxor__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'bool' and 'graph'");
}
var bxor__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'none'");
}
var bxor__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'int'");
}
var bxor__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'float'");
}
var bxor__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'string'");
}
var bxor__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'bool'");
}
var bxor__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'double'");
}
var bxor__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'long'");
}
var bxor__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'long_long'");
}
var bxor__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'long_double'");
}
var bxor__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'uint'");
}
var bxor__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'ulong'");
}
var bxor__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'ulong_long'");
}
var bxor__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'list'");
}
var bxor__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'set'");
}
var bxor__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'dict'");
}
var bxor__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'orderedset'");
}
var bxor__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'ordereddict'");
}
var bxor__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'double' and 'graph'");
}
var bxor__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'none'");
}
var bxor__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la ^ lb);
}
var bxor__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'float'");
}
var bxor__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'string'");
}
var bxor__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la ^ lb);
}
var bxor__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'double'");
}
var bxor__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la ^ lb);
}
var bxor__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la ^ lb);
}
var bxor__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'long_double'");
}
var bxor__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la ^ lb);
}
var bxor__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la ^ lb);
}
var bxor__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la ^ lb);
}
var bxor__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'list'");
}
var bxor__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'set'");
}
var bxor__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'dict'");
}
var bxor__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'orderedset'");
}
var bxor__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'ordereddict'");
}
var bxor__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long' and 'graph'");
}
var bxor__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'none'");
}
var bxor__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la ^ lb);
}
var bxor__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'float'");
}
var bxor__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'string'");
}
var bxor__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la ^ lb);
}
var bxor__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'double'");
}
var bxor__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la ^ lb);
}
var bxor__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la ^ lb);
}
var bxor__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'long_double'");
}
var bxor__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la ^ lb);
}
var bxor__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la ^ lb);
}
var bxor__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la ^ lb);
}
var bxor__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'list'");
}
var bxor__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'set'");
}
var bxor__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'dict'");
}
var bxor__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'orderedset'");
}
var bxor__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'ordereddict'");
}
var bxor__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_long' and 'graph'");
}
var bxor__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'none'");
}
var bxor__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'int'");
}
var bxor__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'float'");
}
var bxor__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'string'");
}
var bxor__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'bool'");
}
var bxor__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'double'");
}
var bxor__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'long'");
}
var bxor__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'long_long'");
}
var bxor__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'long_double'");
}
var bxor__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'uint'");
}
var bxor__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'ulong'");
}
var bxor__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'ulong_long'");
}
var bxor__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'list'");
}
var bxor__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'set'");
}
var bxor__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'dict'");
}
var bxor__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'orderedset'");
}
var bxor__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'ordereddict'");
}
var bxor__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'long_double' and 'graph'");
}
var bxor__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'none'");
}
var bxor__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<int>());
    return var(la ^ lb);
}
var bxor__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'float'");
}
var bxor__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'string'");
}
var bxor__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<bool>());
    return var(la ^ lb);
}
var bxor__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'double'");
}
var bxor__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long>());
    return var(la ^ lb);
}
var bxor__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long long>());
    return var(la ^ lb);
}
var bxor__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'long_double'");
}
var bxor__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la ^ lb);
}
var bxor__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la ^ lb);
}
var bxor__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la ^ lb);
}
var bxor__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'list'");
}
var bxor__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'set'");
}
var bxor__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'dict'");
}
var bxor__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'orderedset'");
}
var bxor__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'ordereddict'");
}
var bxor__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'uint' and 'graph'");
}
var bxor__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'none'");
}
var bxor__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la ^ lb);
}
var bxor__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'float'");
}
var bxor__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'string'");
}
var bxor__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la ^ lb);
}
var bxor__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'double'");
}
var bxor__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long>());
    return var(la ^ lb);
}
var bxor__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long long>());
    return var(la ^ lb);
}
var bxor__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'long_double'");
}
var bxor__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la ^ lb);
}
var bxor__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la ^ lb);
}
var bxor__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la ^ lb);
}
var bxor__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'list'");
}
var bxor__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'set'");
}
var bxor__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'dict'");
}
var bxor__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'orderedset'");
}
var bxor__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'ordereddict'");
}
var bxor__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong' and 'graph'");
}
var bxor__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'none'");
}
var bxor__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la ^ lb);
}
var bxor__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'float'");
}
var bxor__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'string'");
}
var bxor__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la ^ lb);
}
var bxor__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'double'");
}
var bxor__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la ^ lb);
}
var bxor__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long long>());
    return var(la ^ lb);
}
var bxor__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'long_double'");
}
var bxor__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la ^ lb);
}
var bxor__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la ^ lb);
}
var bxor__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la ^ lb);
}
var bxor__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'list'");
}
var bxor__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'set'");
}
var bxor__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'dict'");
}
var bxor__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'orderedset'");
}
var bxor__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'ordereddict'");
}
var bxor__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ulong_long' and 'graph'");
}
var bxor__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'none'");
}
var bxor__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'int'");
}
var bxor__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'float'");
}
var bxor__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'string'");
}
var bxor__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'bool'");
}
var bxor__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'double'");
}
var bxor__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'long'");
}
var bxor__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'long_long'");
}
var bxor__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'long_double'");
}
var bxor__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'uint'");
}
var bxor__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'ulong'");
}
var bxor__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'ulong_long'");
}
var bxor__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::List>();
    const auto &rhs = b.var_get<pythonic::vars::List>();
    pythonic::vars::List result;
    pythonic::vars::Set lhs_set(lhs.begin(), lhs.end());
    pythonic::vars::Set rhs_set(rhs.begin(), rhs.end());
    for (const auto &item : lhs) {
        if (rhs_set.find(item) == rhs_set.end()) {
            result.push_back(item);
        }
    }
    for (const auto &item : rhs) {
        if (lhs_set.find(item) == lhs_set.end()) {
            result.push_back(item);
        }
    }
    return var(std::move(result));
}
var bxor__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'set'");
}
var bxor__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'dict'");
}
var bxor__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'orderedset'");
}
var bxor__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'ordereddict'");
}
var bxor__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'list' and 'graph'");
}
var bxor__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'none'");
}
var bxor__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'int'");
}
var bxor__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'float'");
}
var bxor__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'string'");
}
var bxor__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'bool'");
}
var bxor__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'double'");
}
var bxor__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'long'");
}
var bxor__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'long_long'");
}
var bxor__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'long_double'");
}
var bxor__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'uint'");
}
var bxor__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'ulong'");
}
var bxor__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'ulong_long'");
}
var bxor__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'list'");
}
var bxor__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::Set>();
    const auto &rhs = b.var_get<pythonic::vars::Set>();
    pythonic::vars::Set result;
    for (const auto &item : lhs) {
        if (rhs.find(item) == rhs.end()) {
            result.insert(item);
        }
    }
    for (const auto &item : rhs) {
        if (lhs.find(item) == lhs.end()) {
            result.insert(item);
        }
    }
    return var(std::move(result));
}
var bxor__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'dict'");
}
var bxor__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'orderedset'");
}
var bxor__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'ordereddict'");
}
var bxor__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'set' and 'graph'");
}
var bxor__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'none'");
}
var bxor__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'int'");
}
var bxor__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'float'");
}
var bxor__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'string'");
}
var bxor__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'bool'");
}
var bxor__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'double'");
}
var bxor__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'long'");
}
var bxor__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'long_long'");
}
var bxor__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'long_double'");
}
var bxor__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'uint'");
}
var bxor__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'ulong'");
}
var bxor__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'ulong_long'");
}
var bxor__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'list'");
}
var bxor__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'set'");
}
var bxor__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'dict'");
}
var bxor__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'orderedset'");
}
var bxor__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'ordereddict'");
}
var bxor__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'dict' and 'graph'");
}
var bxor__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'none'");
}
var bxor__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'int'");
}
var bxor__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'float'");
}
var bxor__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'string'");
}
var bxor__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'bool'");
}
var bxor__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'double'");
}
var bxor__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'long'");
}
var bxor__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'long_long'");
}
var bxor__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'long_double'");
}
var bxor__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'uint'");
}
var bxor__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'ulong'");
}
var bxor__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'ulong_long'");
}
var bxor__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'list'");
}
var bxor__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'set'");
}
var bxor__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'dict'");
}
var bxor__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    const auto &lhs = a.var_get<pythonic::vars::OrderedSet>();
    const auto &rhs = b.var_get<pythonic::vars::OrderedSet>();
    pythonic::vars::OrderedSet result;
    auto it_lhs = lhs.begin();
    auto it_rhs = rhs.begin();
    while (it_lhs != lhs.end() && it_rhs != rhs.end()) {
        if (*it_lhs < *it_rhs) {
            result.insert(*it_lhs);
            ++it_lhs;
        } else if (*it_rhs < *it_lhs) {
            result.insert(*it_rhs);
            ++it_rhs;
        } else {
            ++it_lhs;
            ++it_rhs;
        }
    }
    while (it_lhs != lhs.end()) {
        result.insert(*it_lhs);
        ++it_lhs;
    }
    while (it_rhs != rhs.end()) {
        result.insert(*it_rhs);
        ++it_rhs;
    }
    return var(std::move(result));
}
var bxor__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'ordereddict'");
}
var bxor__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'orderedset' and 'graph'");
}
var bxor__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'none'");
}
var bxor__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'int'");
}
var bxor__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'float'");
}
var bxor__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'string'");
}
var bxor__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'bool'");
}
var bxor__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'double'");
}
var bxor__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'long'");
}
var bxor__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'long_long'");
}
var bxor__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'long_double'");
}
var bxor__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'uint'");
}
var bxor__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'ulong'");
}
var bxor__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'ulong_long'");
}
var bxor__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'list'");
}
var bxor__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'set'");
}
var bxor__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'dict'");
}
var bxor__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'orderedset'");
}
var bxor__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'ordereddict'");
}
var bxor__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'ordereddict' and 'graph'");
}
var bxor__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'none'");
}
var bxor__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'int'");
}
var bxor__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'float'");
}
var bxor__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'string'");
}
var bxor__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'bool'");
}
var bxor__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'double'");
}
var bxor__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'long'");
}
var bxor__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'long_long'");
}
var bxor__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'long_double'");
}
var bxor__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'uint'");
}
var bxor__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'ulong'");
}
var bxor__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'ulong_long'");
}
var bxor__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'list'");
}
var bxor__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'set'");
}
var bxor__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'dict'");
}
var bxor__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'orderedset'");
}
var bxor__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'ordereddict'");
}
var bxor__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for ^: 'graph' and 'graph'");
}

// Stub definitions for shl
var shl__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'none'");
}
var shl__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'int'");
}
var shl__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'float'");
}
var shl__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'string'");
}
var shl__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'bool'");
}
var shl__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'double'");
}
var shl__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'long'");
}
var shl__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'long_long'");
}
var shl__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'long_double'");
}
var shl__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'uint'");
}
var shl__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'ulong'");
}
var shl__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'ulong_long'");
}
var shl__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'list'");
}
var shl__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'set'");
}
var shl__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'dict'");
}
var shl__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'orderedset'");
}
var shl__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'ordereddict'");
}
var shl__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'none' and 'graph'");
}
var shl__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'none'");
}
var shl__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la << lb);
}
var shl__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'float'");
}
var shl__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'string'");
}
var shl__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la << lb);
}
var shl__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'double'");
}
var shl__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la << lb);
}
var shl__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la << lb);
}
var shl__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'long_double'");
}
var shl__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la << lb);
}
var shl__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la << lb);
}
var shl__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la << lb);
}
var shl__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'list'");
}
var shl__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'set'");
}
var shl__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'dict'");
}
var shl__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'orderedset'");
}
var shl__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'ordereddict'");
}
var shl__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'int' and 'graph'");
}
var shl__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'none'");
}
var shl__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'int'");
}
var shl__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'float'");
}
var shl__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'string'");
}
var shl__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'bool'");
}
var shl__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'double'");
}
var shl__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'long'");
}
var shl__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'long_long'");
}
var shl__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'long_double'");
}
var shl__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'uint'");
}
var shl__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'ulong'");
}
var shl__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'ulong_long'");
}
var shl__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'list'");
}
var shl__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'set'");
}
var shl__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'dict'");
}
var shl__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'orderedset'");
}
var shl__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'ordereddict'");
}
var shl__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'float' and 'graph'");
}
var shl__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'none'");
}
var shl__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'int'");
}
var shl__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'float'");
}
var shl__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'string'");
}
var shl__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'bool'");
}
var shl__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'double'");
}
var shl__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'long'");
}
var shl__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'long_long'");
}
var shl__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'long_double'");
}
var shl__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'uint'");
}
var shl__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'ulong'");
}
var shl__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'ulong_long'");
}
var shl__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'list'");
}
var shl__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'set'");
}
var shl__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'dict'");
}
var shl__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'orderedset'");
}
var shl__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'ordereddict'");
}
var shl__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'string' and 'graph'");
}
var shl__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'none'");
}
var shl__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la << lb);
}
var shl__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'float'");
}
var shl__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'string'");
}
var shl__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la << lb);
}
var shl__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'double'");
}
var shl__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la << lb);
}
var shl__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la << lb);
}
var shl__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'long_double'");
}
var shl__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<bool>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la << lb);
}
var shl__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la << lb);
}
var shl__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la << lb);
}
var shl__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'list'");
}
var shl__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'set'");
}
var shl__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'dict'");
}
var shl__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'orderedset'");
}
var shl__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'ordereddict'");
}
var shl__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'bool' and 'graph'");
}
var shl__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'none'");
}
var shl__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'int'");
}
var shl__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'float'");
}
var shl__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'string'");
}
var shl__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'bool'");
}
var shl__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'double'");
}
var shl__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'long'");
}
var shl__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'long_long'");
}
var shl__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'long_double'");
}
var shl__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'uint'");
}
var shl__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'ulong'");
}
var shl__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'ulong_long'");
}
var shl__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'list'");
}
var shl__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'set'");
}
var shl__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'dict'");
}
var shl__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'orderedset'");
}
var shl__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'ordereddict'");
}
var shl__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'double' and 'graph'");
}
var shl__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'none'");
}
var shl__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la << lb);
}
var shl__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'float'");
}
var shl__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'string'");
}
var shl__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la << lb);
}
var shl__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'double'");
}
var shl__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la << lb);
}
var shl__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la << lb);
}
var shl__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'long_double'");
}
var shl__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la << lb);
}
var shl__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la << lb);
}
var shl__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la << lb);
}
var shl__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'list'");
}
var shl__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'set'");
}
var shl__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'dict'");
}
var shl__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'orderedset'");
}
var shl__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'ordereddict'");
}
var shl__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long' and 'graph'");
}
var shl__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'none'");
}
var shl__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la << lb);
}
var shl__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'float'");
}
var shl__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'string'");
}
var shl__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la << lb);
}
var shl__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'double'");
}
var shl__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la << lb);
}
var shl__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la << lb);
}
var shl__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'long_double'");
}
var shl__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la << lb);
}
var shl__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la << lb);
}
var shl__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la << lb);
}
var shl__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'list'");
}
var shl__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'set'");
}
var shl__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'dict'");
}
var shl__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'orderedset'");
}
var shl__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'ordereddict'");
}
var shl__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_long' and 'graph'");
}
var shl__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'none'");
}
var shl__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'int'");
}
var shl__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'float'");
}
var shl__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'string'");
}
var shl__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'bool'");
}
var shl__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'double'");
}
var shl__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'long'");
}
var shl__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'long_long'");
}
var shl__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'long_double'");
}
var shl__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'uint'");
}
var shl__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'ulong'");
}
var shl__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'ulong_long'");
}
var shl__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'list'");
}
var shl__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'set'");
}
var shl__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'dict'");
}
var shl__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'orderedset'");
}
var shl__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'ordereddict'");
}
var shl__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'long_double' and 'graph'");
}
var shl__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'none'");
}
var shl__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<int>());
    return var(la << lb);
}
var shl__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'float'");
}
var shl__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'string'");
}
var shl__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<bool>());
    return var(la << lb);
}
var shl__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'double'");
}
var shl__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long>());
    return var(la << lb);
}
var shl__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long long>());
    return var(la << lb);
}
var shl__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'long_double'");
}
var shl__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la << lb);
}
var shl__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la << lb);
}
var shl__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la << lb);
}
var shl__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'list'");
}
var shl__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'set'");
}
var shl__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'dict'");
}
var shl__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'orderedset'");
}
var shl__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'ordereddict'");
}
var shl__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'uint' and 'graph'");
}
var shl__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'none'");
}
var shl__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la << lb);
}
var shl__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'float'");
}
var shl__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'string'");
}
var shl__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la << lb);
}
var shl__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'double'");
}
var shl__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long>());
    return var(la << lb);
}
var shl__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long long>());
    return var(la << lb);
}
var shl__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'long_double'");
}
var shl__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la << lb);
}
var shl__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la << lb);
}
var shl__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la << lb);
}
var shl__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'list'");
}
var shl__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'set'");
}
var shl__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'dict'");
}
var shl__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'orderedset'");
}
var shl__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'ordereddict'");
}
var shl__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong' and 'graph'");
}
var shl__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'none'");
}
var shl__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la << lb);
}
var shl__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'float'");
}
var shl__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'string'");
}
var shl__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la << lb);
}
var shl__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'double'");
}
var shl__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la << lb);
}
var shl__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long long>());
    return var(la << lb);
}
var shl__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'long_double'");
}
var shl__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la << lb);
}
var shl__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la << lb);
}
var shl__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la << lb);
}
var shl__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'list'");
}
var shl__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'set'");
}
var shl__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'dict'");
}
var shl__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'orderedset'");
}
var shl__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'ordereddict'");
}
var shl__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ulong_long' and 'graph'");
}
var shl__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'none'");
}
var shl__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'int'");
}
var shl__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'float'");
}
var shl__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'string'");
}
var shl__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'bool'");
}
var shl__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'double'");
}
var shl__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'long'");
}
var shl__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'long_long'");
}
var shl__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'long_double'");
}
var shl__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'uint'");
}
var shl__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'ulong'");
}
var shl__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'ulong_long'");
}
var shl__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'list'");
}
var shl__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'set'");
}
var shl__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'dict'");
}
var shl__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'orderedset'");
}
var shl__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'ordereddict'");
}
var shl__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'list' and 'graph'");
}
var shl__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'none'");
}
var shl__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'int'");
}
var shl__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'float'");
}
var shl__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'string'");
}
var shl__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'bool'");
}
var shl__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'double'");
}
var shl__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'long'");
}
var shl__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'long_long'");
}
var shl__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'long_double'");
}
var shl__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'uint'");
}
var shl__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'ulong'");
}
var shl__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'ulong_long'");
}
var shl__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'list'");
}
var shl__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'set'");
}
var shl__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'dict'");
}
var shl__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'orderedset'");
}
var shl__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'ordereddict'");
}
var shl__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'set' and 'graph'");
}
var shl__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'none'");
}
var shl__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'int'");
}
var shl__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'float'");
}
var shl__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'string'");
}
var shl__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'bool'");
}
var shl__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'double'");
}
var shl__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'long'");
}
var shl__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'long_long'");
}
var shl__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'long_double'");
}
var shl__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'uint'");
}
var shl__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'ulong'");
}
var shl__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'ulong_long'");
}
var shl__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'list'");
}
var shl__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'set'");
}
var shl__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'dict'");
}
var shl__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'orderedset'");
}
var shl__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'ordereddict'");
}
var shl__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'dict' and 'graph'");
}
var shl__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'none'");
}
var shl__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'int'");
}
var shl__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'float'");
}
var shl__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'string'");
}
var shl__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'bool'");
}
var shl__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'double'");
}
var shl__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'long'");
}
var shl__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'long_long'");
}
var shl__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'long_double'");
}
var shl__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'uint'");
}
var shl__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'ulong'");
}
var shl__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'ulong_long'");
}
var shl__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'list'");
}
var shl__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'set'");
}
var shl__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'dict'");
}
var shl__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'orderedset'");
}
var shl__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'ordereddict'");
}
var shl__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'orderedset' and 'graph'");
}
var shl__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'none'");
}
var shl__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'int'");
}
var shl__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'float'");
}
var shl__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'string'");
}
var shl__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'bool'");
}
var shl__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'double'");
}
var shl__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'long'");
}
var shl__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'long_long'");
}
var shl__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'long_double'");
}
var shl__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'uint'");
}
var shl__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'ulong'");
}
var shl__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'ulong_long'");
}
var shl__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'list'");
}
var shl__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'set'");
}
var shl__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'dict'");
}
var shl__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'orderedset'");
}
var shl__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'ordereddict'");
}
var shl__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'ordereddict' and 'graph'");
}
var shl__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'none'");
}
var shl__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'int'");
}
var shl__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'float'");
}
var shl__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'string'");
}
var shl__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'bool'");
}
var shl__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'double'");
}
var shl__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'long'");
}
var shl__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'long_long'");
}
var shl__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'long_double'");
}
var shl__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'uint'");
}
var shl__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'ulong'");
}
var shl__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'ulong_long'");
}
var shl__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'list'");
}
var shl__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'set'");
}
var shl__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'dict'");
}
var shl__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'orderedset'");
}
var shl__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'ordereddict'");
}
var shl__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for <<: 'graph' and 'graph'");
}

// Stub definitions for shr
var shr__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'none'");
}
var shr__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'int'");
}
var shr__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'float'");
}
var shr__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'string'");
}
var shr__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'bool'");
}
var shr__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'double'");
}
var shr__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'long'");
}
var shr__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'long_long'");
}
var shr__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'long_double'");
}
var shr__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'uint'");
}
var shr__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'ulong'");
}
var shr__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'ulong_long'");
}
var shr__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'list'");
}
var shr__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'set'");
}
var shr__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'dict'");
}
var shr__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'orderedset'");
}
var shr__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'ordereddict'");
}
var shr__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'none' and 'graph'");
}
var shr__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'none'");
}
var shr__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la >> lb);
}
var shr__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'float'");
}
var shr__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'string'");
}
var shr__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<int>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la >> lb);
}
var shr__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'double'");
}
var shr__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<int>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >> lb);
}
var shr__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<int>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >> lb);
}
var shr__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'long_double'");
}
var shr__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la >> lb);
}
var shr__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >> lb);
}
var shr__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >> lb);
}
var shr__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'list'");
}
var shr__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'set'");
}
var shr__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'dict'");
}
var shr__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'orderedset'");
}
var shr__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'ordereddict'");
}
var shr__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'int' and 'graph'");
}
var shr__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'none'");
}
var shr__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'int'");
}
var shr__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'float'");
}
var shr__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'string'");
}
var shr__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'bool'");
}
var shr__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'double'");
}
var shr__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'long'");
}
var shr__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'long_long'");
}
var shr__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'long_double'");
}
var shr__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'uint'");
}
var shr__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'ulong'");
}
var shr__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'ulong_long'");
}
var shr__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'list'");
}
var shr__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'set'");
}
var shr__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'dict'");
}
var shr__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'orderedset'");
}
var shr__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'ordereddict'");
}
var shr__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'float' and 'graph'");
}
var shr__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'none'");
}
var shr__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'int'");
}
var shr__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'float'");
}
var shr__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'string'");
}
var shr__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'bool'");
}
var shr__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'double'");
}
var shr__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'long'");
}
var shr__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'long_long'");
}
var shr__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'long_double'");
}
var shr__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'uint'");
}
var shr__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'ulong'");
}
var shr__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'ulong_long'");
}
var shr__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'list'");
}
var shr__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'set'");
}
var shr__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'dict'");
}
var shr__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'orderedset'");
}
var shr__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'ordereddict'");
}
var shr__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'string' and 'graph'");
}
var shr__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'none'");
}
var shr__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<int>());
    return var(la >> lb);
}
var shr__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'float'");
}
var shr__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'string'");
}
var shr__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    int la = static_cast<int>(a.var_get<bool>());
    int lb = static_cast<int>(b.var_get<bool>());
    return var(la >> lb);
}
var shr__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'double'");
}
var shr__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<bool>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >> lb);
}
var shr__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<bool>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >> lb);
}
var shr__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'long_double'");
}
var shr__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<bool>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la >> lb);
}
var shr__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<bool>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >> lb);
}
var shr__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<bool>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >> lb);
}
var shr__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'list'");
}
var shr__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'set'");
}
var shr__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'dict'");
}
var shr__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'orderedset'");
}
var shr__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'ordereddict'");
}
var shr__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'bool' and 'graph'");
}
var shr__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'none'");
}
var shr__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'int'");
}
var shr__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'float'");
}
var shr__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'string'");
}
var shr__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'bool'");
}
var shr__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'double'");
}
var shr__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'long'");
}
var shr__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'long_long'");
}
var shr__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'long_double'");
}
var shr__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'uint'");
}
var shr__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'ulong'");
}
var shr__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'ulong_long'");
}
var shr__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'list'");
}
var shr__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'set'");
}
var shr__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'dict'");
}
var shr__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'orderedset'");
}
var shr__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'ordereddict'");
}
var shr__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'double' and 'graph'");
}
var shr__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'none'");
}
var shr__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<int>());
    return var(la >> lb);
}
var shr__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'float'");
}
var shr__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'string'");
}
var shr__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<bool>());
    return var(la >> lb);
}
var shr__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'double'");
}
var shr__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long la = static_cast<long>(a.var_get<long>());
    long lb = static_cast<long>(b.var_get<long>());
    return var(la >> lb);
}
var shr__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >> lb);
}
var shr__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'long_double'");
}
var shr__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la >> lb);
}
var shr__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >> lb);
}
var shr__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >> lb);
}
var shr__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'list'");
}
var shr__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'set'");
}
var shr__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'dict'");
}
var shr__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'orderedset'");
}
var shr__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'ordereddict'");
}
var shr__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long' and 'graph'");
}
var shr__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'none'");
}
var shr__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<int>());
    return var(la >> lb);
}
var shr__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'float'");
}
var shr__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'string'");
}
var shr__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<bool>());
    return var(la >> lb);
}
var shr__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'double'");
}
var shr__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long>());
    return var(la >> lb);
}
var shr__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    long long la = static_cast<long long>(a.var_get<long long>());
    long long lb = static_cast<long long>(b.var_get<long long>());
    return var(la >> lb);
}
var shr__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'long_double'");
}
var shr__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<long long>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la >> lb);
}
var shr__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<long long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >> lb);
}
var shr__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >> lb);
}
var shr__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'list'");
}
var shr__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'set'");
}
var shr__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'dict'");
}
var shr__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'orderedset'");
}
var shr__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'ordereddict'");
}
var shr__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_long' and 'graph'");
}
var shr__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'none'");
}
var shr__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'int'");
}
var shr__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'float'");
}
var shr__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'string'");
}
var shr__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'bool'");
}
var shr__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'double'");
}
var shr__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'long'");
}
var shr__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'long_long'");
}
var shr__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'long_double'");
}
var shr__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'uint'");
}
var shr__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'ulong'");
}
var shr__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'ulong_long'");
}
var shr__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'list'");
}
var shr__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'set'");
}
var shr__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'dict'");
}
var shr__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'orderedset'");
}
var shr__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'ordereddict'");
}
var shr__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'long_double' and 'graph'");
}
var shr__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'none'");
}
var shr__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<int>());
    return var(la >> lb);
}
var shr__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'float'");
}
var shr__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'string'");
}
var shr__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<bool>());
    return var(la >> lb);
}
var shr__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'double'");
}
var shr__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long>());
    return var(la >> lb);
}
var shr__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<long long>());
    return var(la >> lb);
}
var shr__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'long_double'");
}
var shr__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned int la = static_cast<unsigned int>(a.var_get<unsigned int>());
    unsigned int lb = static_cast<unsigned int>(b.var_get<unsigned int>());
    return var(la >> lb);
}
var shr__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned int>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >> lb);
}
var shr__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned int>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >> lb);
}
var shr__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'list'");
}
var shr__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'set'");
}
var shr__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'dict'");
}
var shr__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'orderedset'");
}
var shr__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'ordereddict'");
}
var shr__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'uint' and 'graph'");
}
var shr__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'none'");
}
var shr__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<int>());
    return var(la >> lb);
}
var shr__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'float'");
}
var shr__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'string'");
}
var shr__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<bool>());
    return var(la >> lb);
}
var shr__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'double'");
}
var shr__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long>());
    return var(la >> lb);
}
var shr__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<long long>());
    return var(la >> lb);
}
var shr__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'long_double'");
}
var shr__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned int>());
    return var(la >> lb);
}
var shr__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long la = static_cast<unsigned long>(a.var_get<unsigned long>());
    unsigned long lb = static_cast<unsigned long>(b.var_get<unsigned long>());
    return var(la >> lb);
}
var shr__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >> lb);
}
var shr__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'list'");
}
var shr__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'set'");
}
var shr__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'dict'");
}
var shr__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'orderedset'");
}
var shr__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'ordereddict'");
}
var shr__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong' and 'graph'");
}
var shr__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'none'");
}
var shr__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<int>());
    return var(la >> lb);
}
var shr__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'float'");
}
var shr__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'string'");
}
var shr__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<bool>());
    return var(la >> lb);
}
var shr__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'double'");
}
var shr__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long>());
    return var(la >> lb);
}
var shr__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<long long>());
    return var(la >> lb);
}
var shr__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'long_double'");
}
var shr__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned int>());
    return var(la >> lb);
}
var shr__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long>());
    return var(la >> lb);
}
var shr__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    unsigned long long la = static_cast<unsigned long long>(a.var_get<unsigned long long>());
    unsigned long long lb = static_cast<unsigned long long>(b.var_get<unsigned long long>());
    return var(la >> lb);
}
var shr__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'list'");
}
var shr__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'set'");
}
var shr__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'dict'");
}
var shr__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'orderedset'");
}
var shr__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'ordereddict'");
}
var shr__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ulong_long' and 'graph'");
}
var shr__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'none'");
}
var shr__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'int'");
}
var shr__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'float'");
}
var shr__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'string'");
}
var shr__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'bool'");
}
var shr__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'double'");
}
var shr__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'long'");
}
var shr__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'long_long'");
}
var shr__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'long_double'");
}
var shr__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'uint'");
}
var shr__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'ulong'");
}
var shr__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'ulong_long'");
}
var shr__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'list'");
}
var shr__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'set'");
}
var shr__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'dict'");
}
var shr__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'orderedset'");
}
var shr__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'ordereddict'");
}
var shr__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'list' and 'graph'");
}
var shr__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'none'");
}
var shr__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'int'");
}
var shr__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'float'");
}
var shr__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'string'");
}
var shr__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'bool'");
}
var shr__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'double'");
}
var shr__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'long'");
}
var shr__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'long_long'");
}
var shr__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'long_double'");
}
var shr__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'uint'");
}
var shr__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'ulong'");
}
var shr__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'ulong_long'");
}
var shr__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'list'");
}
var shr__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'set'");
}
var shr__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'dict'");
}
var shr__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'orderedset'");
}
var shr__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'ordereddict'");
}
var shr__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'set' and 'graph'");
}
var shr__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'none'");
}
var shr__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'int'");
}
var shr__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'float'");
}
var shr__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'string'");
}
var shr__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'bool'");
}
var shr__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'double'");
}
var shr__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'long'");
}
var shr__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'long_long'");
}
var shr__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'long_double'");
}
var shr__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'uint'");
}
var shr__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'ulong'");
}
var shr__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'ulong_long'");
}
var shr__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'list'");
}
var shr__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'set'");
}
var shr__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'dict'");
}
var shr__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'orderedset'");
}
var shr__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'ordereddict'");
}
var shr__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'dict' and 'graph'");
}
var shr__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'none'");
}
var shr__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'int'");
}
var shr__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'float'");
}
var shr__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'string'");
}
var shr__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'bool'");
}
var shr__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'double'");
}
var shr__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'long'");
}
var shr__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'long_long'");
}
var shr__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'long_double'");
}
var shr__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'uint'");
}
var shr__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'ulong'");
}
var shr__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'ulong_long'");
}
var shr__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'list'");
}
var shr__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'set'");
}
var shr__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'dict'");
}
var shr__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'orderedset'");
}
var shr__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'ordereddict'");
}
var shr__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'orderedset' and 'graph'");
}
var shr__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'none'");
}
var shr__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'int'");
}
var shr__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'float'");
}
var shr__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'string'");
}
var shr__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'bool'");
}
var shr__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'double'");
}
var shr__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'long'");
}
var shr__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'long_long'");
}
var shr__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'long_double'");
}
var shr__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'uint'");
}
var shr__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'ulong'");
}
var shr__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'ulong_long'");
}
var shr__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'list'");
}
var shr__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'set'");
}
var shr__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'dict'");
}
var shr__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'orderedset'");
}
var shr__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'ordereddict'");
}
var shr__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'ordereddict' and 'graph'");
}
var shr__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'none'");
}
var shr__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'int'");
}
var shr__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'float'");
}
var shr__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'string'");
}
var shr__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'bool'");
}
var shr__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'double'");
}
var shr__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'long'");
}
var shr__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'long_long'");
}
var shr__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'long_double'");
}
var shr__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'uint'");
}
var shr__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'ulong'");
}
var shr__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'ulong_long'");
}
var shr__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'list'");
}
var shr__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'set'");
}
var shr__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'dict'");
}
var shr__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'orderedset'");
}
var shr__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'ordereddict'");
}
var shr__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw pythonic::PythonicTypeError("TypeError: unsupported operand type(s) for >>: 'graph' and 'graph'");
}

// Stub definitions for land
var land__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and none");
}
var land__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and int");
}
var land__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and float");
}
var land__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and string");
}
var land__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and bool");
}
var land__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and double");
}
var land__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and long");
}
var land__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and long_long");
}
var land__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and long_double");
}
var land__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and uint");
}
var land__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and ulong");
}
var land__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and ulong_long");
}
var land__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and list");
}
var land__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and set");
}
var land__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and dict");
}
var land__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and orderedset");
}
var land__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and ordereddict");
}
var land__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for none and graph");
}
var land__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and none");
}
var land__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and int");
}
var land__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and float");
}
var land__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and string");
}
var land__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and bool");
}
var land__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and double");
}
var land__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and long");
}
var land__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and long_long");
}
var land__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and long_double");
}
var land__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and uint");
}
var land__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and ulong");
}
var land__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and ulong_long");
}
var land__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and list");
}
var land__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and set");
}
var land__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and dict");
}
var land__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and orderedset");
}
var land__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and ordereddict");
}
var land__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for int and graph");
}
var land__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and none");
}
var land__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and int");
}
var land__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and float");
}
var land__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and string");
}
var land__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and bool");
}
var land__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and double");
}
var land__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and long");
}
var land__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and long_long");
}
var land__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and long_double");
}
var land__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and uint");
}
var land__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and ulong");
}
var land__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and ulong_long");
}
var land__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and list");
}
var land__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and set");
}
var land__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and dict");
}
var land__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and orderedset");
}
var land__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and ordereddict");
}
var land__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for float and graph");
}
var land__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and none");
}
var land__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and int");
}
var land__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and float");
}
var land__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and string");
}
var land__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and bool");
}
var land__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and double");
}
var land__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and long");
}
var land__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and long_long");
}
var land__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and long_double");
}
var land__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and uint");
}
var land__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and ulong");
}
var land__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and ulong_long");
}
var land__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and list");
}
var land__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and set");
}
var land__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and dict");
}
var land__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and orderedset");
}
var land__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and ordereddict");
}
var land__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for string and graph");
}
var land__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and none");
}
var land__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and int");
}
var land__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and float");
}
var land__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and string");
}
var land__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and bool");
}
var land__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and double");
}
var land__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and long");
}
var land__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and long_long");
}
var land__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and long_double");
}
var land__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and uint");
}
var land__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and ulong");
}
var land__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and ulong_long");
}
var land__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and list");
}
var land__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and set");
}
var land__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and dict");
}
var land__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and orderedset");
}
var land__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and ordereddict");
}
var land__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for bool and graph");
}
var land__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and none");
}
var land__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and int");
}
var land__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and float");
}
var land__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and string");
}
var land__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and bool");
}
var land__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and double");
}
var land__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and long");
}
var land__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and long_long");
}
var land__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and long_double");
}
var land__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and uint");
}
var land__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and ulong");
}
var land__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and ulong_long");
}
var land__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and list");
}
var land__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and set");
}
var land__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and dict");
}
var land__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and orderedset");
}
var land__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and ordereddict");
}
var land__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for double and graph");
}
var land__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and none");
}
var land__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and int");
}
var land__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and float");
}
var land__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and string");
}
var land__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and bool");
}
var land__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and double");
}
var land__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and long");
}
var land__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and long_long");
}
var land__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and long_double");
}
var land__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and uint");
}
var land__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and ulong");
}
var land__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and ulong_long");
}
var land__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and list");
}
var land__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and set");
}
var land__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and dict");
}
var land__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and orderedset");
}
var land__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and ordereddict");
}
var land__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long and graph");
}
var land__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and none");
}
var land__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and int");
}
var land__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and float");
}
var land__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and string");
}
var land__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and bool");
}
var land__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and double");
}
var land__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and long");
}
var land__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and long_long");
}
var land__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and long_double");
}
var land__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and uint");
}
var land__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and ulong");
}
var land__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and ulong_long");
}
var land__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and list");
}
var land__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and set");
}
var land__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and dict");
}
var land__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and orderedset");
}
var land__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and ordereddict");
}
var land__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_long and graph");
}
var land__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and none");
}
var land__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and int");
}
var land__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and float");
}
var land__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and string");
}
var land__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and bool");
}
var land__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and double");
}
var land__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and long");
}
var land__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and long_long");
}
var land__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and long_double");
}
var land__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and uint");
}
var land__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and ulong");
}
var land__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and ulong_long");
}
var land__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and list");
}
var land__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and set");
}
var land__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and dict");
}
var land__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and orderedset");
}
var land__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and ordereddict");
}
var land__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for long_double and graph");
}
var land__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and none");
}
var land__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and int");
}
var land__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and float");
}
var land__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and string");
}
var land__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and bool");
}
var land__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and double");
}
var land__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and long");
}
var land__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and long_long");
}
var land__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and long_double");
}
var land__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and uint");
}
var land__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and ulong");
}
var land__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and ulong_long");
}
var land__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and list");
}
var land__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and set");
}
var land__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and dict");
}
var land__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and orderedset");
}
var land__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and ordereddict");
}
var land__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for uint and graph");
}
var land__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and none");
}
var land__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and int");
}
var land__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and float");
}
var land__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and string");
}
var land__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and bool");
}
var land__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and double");
}
var land__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and long");
}
var land__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and long_long");
}
var land__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and long_double");
}
var land__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and uint");
}
var land__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and ulong");
}
var land__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and ulong_long");
}
var land__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and list");
}
var land__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and set");
}
var land__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and dict");
}
var land__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and orderedset");
}
var land__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and ordereddict");
}
var land__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong and graph");
}
var land__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and none");
}
var land__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and int");
}
var land__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and float");
}
var land__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and string");
}
var land__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and bool");
}
var land__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and double");
}
var land__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and long");
}
var land__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and long_long");
}
var land__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and long_double");
}
var land__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and uint");
}
var land__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and ulong");
}
var land__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and ulong_long");
}
var land__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and list");
}
var land__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and set");
}
var land__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and dict");
}
var land__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and orderedset");
}
var land__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and ordereddict");
}
var land__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ulong_long and graph");
}
var land__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and none");
}
var land__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and int");
}
var land__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and float");
}
var land__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and string");
}
var land__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and bool");
}
var land__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and double");
}
var land__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and long");
}
var land__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and long_long");
}
var land__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and long_double");
}
var land__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and uint");
}
var land__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and ulong");
}
var land__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and ulong_long");
}
var land__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and list");
}
var land__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and set");
}
var land__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and dict");
}
var land__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and orderedset");
}
var land__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and ordereddict");
}
var land__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for list and graph");
}
var land__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and none");
}
var land__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and int");
}
var land__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and float");
}
var land__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and string");
}
var land__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and bool");
}
var land__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and double");
}
var land__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and long");
}
var land__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and long_long");
}
var land__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and long_double");
}
var land__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and uint");
}
var land__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and ulong");
}
var land__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and ulong_long");
}
var land__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and list");
}
var land__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and set");
}
var land__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and dict");
}
var land__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and orderedset");
}
var land__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and ordereddict");
}
var land__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for set and graph");
}
var land__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and none");
}
var land__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and int");
}
var land__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and float");
}
var land__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and string");
}
var land__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and bool");
}
var land__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and double");
}
var land__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and long");
}
var land__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and long_long");
}
var land__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and long_double");
}
var land__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and uint");
}
var land__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and ulong");
}
var land__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and ulong_long");
}
var land__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and list");
}
var land__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and set");
}
var land__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and dict");
}
var land__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and orderedset");
}
var land__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and ordereddict");
}
var land__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for dict and graph");
}
var land__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and none");
}
var land__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and int");
}
var land__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and float");
}
var land__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and string");
}
var land__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and bool");
}
var land__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and double");
}
var land__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and long");
}
var land__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and long_long");
}
var land__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and long_double");
}
var land__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and uint");
}
var land__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and ulong");
}
var land__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and ulong_long");
}
var land__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and list");
}
var land__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and set");
}
var land__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and dict");
}
var land__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and orderedset");
}
var land__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and ordereddict");
}
var land__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for orderedset and graph");
}
var land__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and none");
}
var land__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and int");
}
var land__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and float");
}
var land__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and string");
}
var land__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and bool");
}
var land__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and double");
}
var land__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and long");
}
var land__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and long_long");
}
var land__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and long_double");
}
var land__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and uint");
}
var land__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and ulong");
}
var land__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and ulong_long");
}
var land__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and list");
}
var land__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and set");
}
var land__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and dict");
}
var land__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and orderedset");
}
var land__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and ordereddict");
}
var land__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for ordereddict and graph");
}
var land__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and none");
}
var land__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and int");
}
var land__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and float");
}
var land__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and string");
}
var land__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and bool");
}
var land__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and double");
}
var land__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and long");
}
var land__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and long_long");
}
var land__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and long_double");
}
var land__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and uint");
}
var land__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and ulong");
}
var land__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and ulong_long");
}
var land__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and list");
}
var land__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and set");
}
var land__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and dict");
}
var land__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and orderedset");
}
var land__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and ordereddict");
}
var land__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: land for graph and graph");
}

// Stub definitions for lor
var lor__none__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and none");
}
var lor__none__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and int");
}
var lor__none__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and float");
}
var lor__none__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and string");
}
var lor__none__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and bool");
}
var lor__none__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and double");
}
var lor__none__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and long");
}
var lor__none__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and long_long");
}
var lor__none__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and long_double");
}
var lor__none__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and uint");
}
var lor__none__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and ulong");
}
var lor__none__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and ulong_long");
}
var lor__none__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and list");
}
var lor__none__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and set");
}
var lor__none__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and dict");
}
var lor__none__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and orderedset");
}
var lor__none__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and ordereddict");
}
var lor__none__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for none and graph");
}
var lor__int__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and none");
}
var lor__int__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and int");
}
var lor__int__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and float");
}
var lor__int__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and string");
}
var lor__int__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and bool");
}
var lor__int__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and double");
}
var lor__int__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and long");
}
var lor__int__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and long_long");
}
var lor__int__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and long_double");
}
var lor__int__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and uint");
}
var lor__int__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and ulong");
}
var lor__int__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and ulong_long");
}
var lor__int__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and list");
}
var lor__int__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and set");
}
var lor__int__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and dict");
}
var lor__int__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and orderedset");
}
var lor__int__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and ordereddict");
}
var lor__int__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for int and graph");
}
var lor__float__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and none");
}
var lor__float__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and int");
}
var lor__float__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and float");
}
var lor__float__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and string");
}
var lor__float__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and bool");
}
var lor__float__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and double");
}
var lor__float__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and long");
}
var lor__float__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and long_long");
}
var lor__float__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and long_double");
}
var lor__float__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and uint");
}
var lor__float__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and ulong");
}
var lor__float__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and ulong_long");
}
var lor__float__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and list");
}
var lor__float__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and set");
}
var lor__float__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and dict");
}
var lor__float__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and orderedset");
}
var lor__float__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and ordereddict");
}
var lor__float__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for float and graph");
}
var lor__string__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and none");
}
var lor__string__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and int");
}
var lor__string__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and float");
}
var lor__string__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and string");
}
var lor__string__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and bool");
}
var lor__string__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and double");
}
var lor__string__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and long");
}
var lor__string__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and long_long");
}
var lor__string__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and long_double");
}
var lor__string__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and uint");
}
var lor__string__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and ulong");
}
var lor__string__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and ulong_long");
}
var lor__string__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and list");
}
var lor__string__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and set");
}
var lor__string__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and dict");
}
var lor__string__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and orderedset");
}
var lor__string__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and ordereddict");
}
var lor__string__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for string and graph");
}
var lor__bool__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and none");
}
var lor__bool__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and int");
}
var lor__bool__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and float");
}
var lor__bool__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and string");
}
var lor__bool__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and bool");
}
var lor__bool__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and double");
}
var lor__bool__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and long");
}
var lor__bool__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and long_long");
}
var lor__bool__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and long_double");
}
var lor__bool__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and uint");
}
var lor__bool__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and ulong");
}
var lor__bool__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and ulong_long");
}
var lor__bool__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and list");
}
var lor__bool__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and set");
}
var lor__bool__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and dict");
}
var lor__bool__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and orderedset");
}
var lor__bool__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and ordereddict");
}
var lor__bool__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for bool and graph");
}
var lor__double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and none");
}
var lor__double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and int");
}
var lor__double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and float");
}
var lor__double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and string");
}
var lor__double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and bool");
}
var lor__double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and double");
}
var lor__double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and long");
}
var lor__double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and long_long");
}
var lor__double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and long_double");
}
var lor__double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and uint");
}
var lor__double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and ulong");
}
var lor__double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and ulong_long");
}
var lor__double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and list");
}
var lor__double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and set");
}
var lor__double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and dict");
}
var lor__double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and orderedset");
}
var lor__double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and ordereddict");
}
var lor__double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for double and graph");
}
var lor__long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and none");
}
var lor__long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and int");
}
var lor__long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and float");
}
var lor__long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and string");
}
var lor__long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and bool");
}
var lor__long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and double");
}
var lor__long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and long");
}
var lor__long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and long_long");
}
var lor__long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and long_double");
}
var lor__long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and uint");
}
var lor__long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and ulong");
}
var lor__long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and ulong_long");
}
var lor__long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and list");
}
var lor__long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and set");
}
var lor__long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and dict");
}
var lor__long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and orderedset");
}
var lor__long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and ordereddict");
}
var lor__long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long and graph");
}
var lor__long_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and none");
}
var lor__long_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and int");
}
var lor__long_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and float");
}
var lor__long_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and string");
}
var lor__long_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and bool");
}
var lor__long_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and double");
}
var lor__long_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and long");
}
var lor__long_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and long_long");
}
var lor__long_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and long_double");
}
var lor__long_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and uint");
}
var lor__long_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and ulong");
}
var lor__long_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and ulong_long");
}
var lor__long_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and list");
}
var lor__long_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and set");
}
var lor__long_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and dict");
}
var lor__long_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and orderedset");
}
var lor__long_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and ordereddict");
}
var lor__long_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_long and graph");
}
var lor__long_double__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and none");
}
var lor__long_double__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and int");
}
var lor__long_double__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and float");
}
var lor__long_double__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and string");
}
var lor__long_double__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and bool");
}
var lor__long_double__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and double");
}
var lor__long_double__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and long");
}
var lor__long_double__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and long_long");
}
var lor__long_double__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and long_double");
}
var lor__long_double__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and uint");
}
var lor__long_double__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and ulong");
}
var lor__long_double__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and ulong_long");
}
var lor__long_double__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and list");
}
var lor__long_double__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and set");
}
var lor__long_double__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and dict");
}
var lor__long_double__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and orderedset");
}
var lor__long_double__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and ordereddict");
}
var lor__long_double__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for long_double and graph");
}
var lor__uint__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and none");
}
var lor__uint__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and int");
}
var lor__uint__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and float");
}
var lor__uint__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and string");
}
var lor__uint__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and bool");
}
var lor__uint__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and double");
}
var lor__uint__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and long");
}
var lor__uint__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and long_long");
}
var lor__uint__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and long_double");
}
var lor__uint__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and uint");
}
var lor__uint__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and ulong");
}
var lor__uint__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and ulong_long");
}
var lor__uint__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and list");
}
var lor__uint__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and set");
}
var lor__uint__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and dict");
}
var lor__uint__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and orderedset");
}
var lor__uint__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and ordereddict");
}
var lor__uint__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for uint and graph");
}
var lor__ulong__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and none");
}
var lor__ulong__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and int");
}
var lor__ulong__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and float");
}
var lor__ulong__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and string");
}
var lor__ulong__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and bool");
}
var lor__ulong__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and double");
}
var lor__ulong__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and long");
}
var lor__ulong__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and long_long");
}
var lor__ulong__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and long_double");
}
var lor__ulong__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and uint");
}
var lor__ulong__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and ulong");
}
var lor__ulong__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and ulong_long");
}
var lor__ulong__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and list");
}
var lor__ulong__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and set");
}
var lor__ulong__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and dict");
}
var lor__ulong__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and orderedset");
}
var lor__ulong__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and ordereddict");
}
var lor__ulong__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong and graph");
}
var lor__ulong_long__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and none");
}
var lor__ulong_long__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and int");
}
var lor__ulong_long__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and float");
}
var lor__ulong_long__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and string");
}
var lor__ulong_long__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and bool");
}
var lor__ulong_long__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and double");
}
var lor__ulong_long__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and long");
}
var lor__ulong_long__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and long_long");
}
var lor__ulong_long__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and long_double");
}
var lor__ulong_long__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and uint");
}
var lor__ulong_long__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and ulong");
}
var lor__ulong_long__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and ulong_long");
}
var lor__ulong_long__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and list");
}
var lor__ulong_long__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and set");
}
var lor__ulong_long__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and dict");
}
var lor__ulong_long__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and orderedset");
}
var lor__ulong_long__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and ordereddict");
}
var lor__ulong_long__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ulong_long and graph");
}
var lor__list__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and none");
}
var lor__list__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and int");
}
var lor__list__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and float");
}
var lor__list__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and string");
}
var lor__list__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and bool");
}
var lor__list__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and double");
}
var lor__list__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and long");
}
var lor__list__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and long_long");
}
var lor__list__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and long_double");
}
var lor__list__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and uint");
}
var lor__list__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and ulong");
}
var lor__list__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and ulong_long");
}
var lor__list__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and list");
}
var lor__list__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and set");
}
var lor__list__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and dict");
}
var lor__list__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and orderedset");
}
var lor__list__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and ordereddict");
}
var lor__list__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for list and graph");
}
var lor__set__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and none");
}
var lor__set__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and int");
}
var lor__set__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and float");
}
var lor__set__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and string");
}
var lor__set__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and bool");
}
var lor__set__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and double");
}
var lor__set__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and long");
}
var lor__set__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and long_long");
}
var lor__set__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and long_double");
}
var lor__set__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and uint");
}
var lor__set__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and ulong");
}
var lor__set__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and ulong_long");
}
var lor__set__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and list");
}
var lor__set__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and set");
}
var lor__set__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and dict");
}
var lor__set__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and orderedset");
}
var lor__set__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and ordereddict");
}
var lor__set__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for set and graph");
}
var lor__dict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and none");
}
var lor__dict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and int");
}
var lor__dict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and float");
}
var lor__dict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and string");
}
var lor__dict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and bool");
}
var lor__dict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and double");
}
var lor__dict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and long");
}
var lor__dict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and long_long");
}
var lor__dict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and long_double");
}
var lor__dict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and uint");
}
var lor__dict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and ulong");
}
var lor__dict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and ulong_long");
}
var lor__dict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and list");
}
var lor__dict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and set");
}
var lor__dict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and dict");
}
var lor__dict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and orderedset");
}
var lor__dict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and ordereddict");
}
var lor__dict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for dict and graph");
}
var lor__orderedset__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and none");
}
var lor__orderedset__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and int");
}
var lor__orderedset__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and float");
}
var lor__orderedset__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and string");
}
var lor__orderedset__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and bool");
}
var lor__orderedset__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and double");
}
var lor__orderedset__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and long");
}
var lor__orderedset__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and long_long");
}
var lor__orderedset__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and long_double");
}
var lor__orderedset__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and uint");
}
var lor__orderedset__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and ulong");
}
var lor__orderedset__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and ulong_long");
}
var lor__orderedset__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and list");
}
var lor__orderedset__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and set");
}
var lor__orderedset__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and dict");
}
var lor__orderedset__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and orderedset");
}
var lor__orderedset__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and ordereddict");
}
var lor__orderedset__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for orderedset and graph");
}
var lor__ordereddict__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and none");
}
var lor__ordereddict__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and int");
}
var lor__ordereddict__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and float");
}
var lor__ordereddict__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and string");
}
var lor__ordereddict__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and bool");
}
var lor__ordereddict__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and double");
}
var lor__ordereddict__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and long");
}
var lor__ordereddict__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and long_long");
}
var lor__ordereddict__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and long_double");
}
var lor__ordereddict__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and uint");
}
var lor__ordereddict__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and ulong");
}
var lor__ordereddict__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and ulong_long");
}
var lor__ordereddict__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and list");
}
var lor__ordereddict__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and set");
}
var lor__ordereddict__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and dict");
}
var lor__ordereddict__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and orderedset");
}
var lor__ordereddict__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and ordereddict");
}
var lor__ordereddict__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for ordereddict and graph");
}
var lor__graph__none(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and none");
}
var lor__graph__int(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and int");
}
var lor__graph__float(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and float");
}
var lor__graph__string(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and string");
}
var lor__graph__bool(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and bool");
}
var lor__graph__double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and double");
}
var lor__graph__long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and long");
}
var lor__graph__long_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and long_long");
}
var lor__graph__long_double(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and long_double");
}
var lor__graph__uint(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and uint");
}
var lor__graph__ulong(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and ulong");
}
var lor__graph__ulong_long(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and ulong_long");
}
var lor__graph__list(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and list");
}
var lor__graph__set(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and set");
}
var lor__graph__dict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and dict");
}
var lor__graph__orderedset(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and orderedset");
}
var lor__graph__ordereddict(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and ordereddict");
}
var lor__graph__graph(const var& a, const var& b, pythonic::overflow::Overflow policy, bool smallest_fit) {
    throw std::runtime_error("Not implemented: lor for graph and graph");
}

// OpTable initialization for Add
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Add>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::add__none__none, pythonic::dispatch::add__none__int, pythonic::dispatch::add__none__float, pythonic::dispatch::add__none__string, pythonic::dispatch::add__none__bool, pythonic::dispatch::add__none__double, pythonic::dispatch::add__none__long, pythonic::dispatch::add__none__long_long, pythonic::dispatch::add__none__long_double, pythonic::dispatch::add__none__uint, pythonic::dispatch::add__none__ulong, pythonic::dispatch::add__none__ulong_long, pythonic::dispatch::add__none__list, pythonic::dispatch::add__none__set, pythonic::dispatch::add__none__dict, pythonic::dispatch::add__none__orderedset, pythonic::dispatch::add__none__ordereddict, pythonic::dispatch::add__none__graph};
    t[1] = {pythonic::dispatch::add__int__none, pythonic::dispatch::add__int__int, pythonic::dispatch::add__int__float, pythonic::dispatch::add__int__string, pythonic::dispatch::add__int__bool, pythonic::dispatch::add__int__double, pythonic::dispatch::add__int__long, pythonic::dispatch::add__int__long_long, pythonic::dispatch::add__int__long_double, pythonic::dispatch::add__int__uint, pythonic::dispatch::add__int__ulong, pythonic::dispatch::add__int__ulong_long, pythonic::dispatch::add__int__list, pythonic::dispatch::add__int__set, pythonic::dispatch::add__int__dict, pythonic::dispatch::add__int__orderedset, pythonic::dispatch::add__int__ordereddict, pythonic::dispatch::add__int__graph};
    t[2] = {pythonic::dispatch::add__float__none, pythonic::dispatch::add__float__int, pythonic::dispatch::add__float__float, pythonic::dispatch::add__float__string, pythonic::dispatch::add__float__bool, pythonic::dispatch::add__float__double, pythonic::dispatch::add__float__long, pythonic::dispatch::add__float__long_long, pythonic::dispatch::add__float__long_double, pythonic::dispatch::add__float__uint, pythonic::dispatch::add__float__ulong, pythonic::dispatch::add__float__ulong_long, pythonic::dispatch::add__float__list, pythonic::dispatch::add__float__set, pythonic::dispatch::add__float__dict, pythonic::dispatch::add__float__orderedset, pythonic::dispatch::add__float__ordereddict, pythonic::dispatch::add__float__graph};
    t[3] = {pythonic::dispatch::add__string__none, pythonic::dispatch::add__string__int, pythonic::dispatch::add__string__float, pythonic::dispatch::add__string__string, pythonic::dispatch::add__string__bool, pythonic::dispatch::add__string__double, pythonic::dispatch::add__string__long, pythonic::dispatch::add__string__long_long, pythonic::dispatch::add__string__long_double, pythonic::dispatch::add__string__uint, pythonic::dispatch::add__string__ulong, pythonic::dispatch::add__string__ulong_long, pythonic::dispatch::add__string__list, pythonic::dispatch::add__string__set, pythonic::dispatch::add__string__dict, pythonic::dispatch::add__string__orderedset, pythonic::dispatch::add__string__ordereddict, pythonic::dispatch::add__string__graph};
    t[4] = {pythonic::dispatch::add__bool__none, pythonic::dispatch::add__bool__int, pythonic::dispatch::add__bool__float, pythonic::dispatch::add__bool__string, pythonic::dispatch::add__bool__bool, pythonic::dispatch::add__bool__double, pythonic::dispatch::add__bool__long, pythonic::dispatch::add__bool__long_long, pythonic::dispatch::add__bool__long_double, pythonic::dispatch::add__bool__uint, pythonic::dispatch::add__bool__ulong, pythonic::dispatch::add__bool__ulong_long, pythonic::dispatch::add__bool__list, pythonic::dispatch::add__bool__set, pythonic::dispatch::add__bool__dict, pythonic::dispatch::add__bool__orderedset, pythonic::dispatch::add__bool__ordereddict, pythonic::dispatch::add__bool__graph};
    t[5] = {pythonic::dispatch::add__double__none, pythonic::dispatch::add__double__int, pythonic::dispatch::add__double__float, pythonic::dispatch::add__double__string, pythonic::dispatch::add__double__bool, pythonic::dispatch::add__double__double, pythonic::dispatch::add__double__long, pythonic::dispatch::add__double__long_long, pythonic::dispatch::add__double__long_double, pythonic::dispatch::add__double__uint, pythonic::dispatch::add__double__ulong, pythonic::dispatch::add__double__ulong_long, pythonic::dispatch::add__double__list, pythonic::dispatch::add__double__set, pythonic::dispatch::add__double__dict, pythonic::dispatch::add__double__orderedset, pythonic::dispatch::add__double__ordereddict, pythonic::dispatch::add__double__graph};
    t[6] = {pythonic::dispatch::add__long__none, pythonic::dispatch::add__long__int, pythonic::dispatch::add__long__float, pythonic::dispatch::add__long__string, pythonic::dispatch::add__long__bool, pythonic::dispatch::add__long__double, pythonic::dispatch::add__long__long, pythonic::dispatch::add__long__long_long, pythonic::dispatch::add__long__long_double, pythonic::dispatch::add__long__uint, pythonic::dispatch::add__long__ulong, pythonic::dispatch::add__long__ulong_long, pythonic::dispatch::add__long__list, pythonic::dispatch::add__long__set, pythonic::dispatch::add__long__dict, pythonic::dispatch::add__long__orderedset, pythonic::dispatch::add__long__ordereddict, pythonic::dispatch::add__long__graph};
    t[7] = {pythonic::dispatch::add__long_long__none, pythonic::dispatch::add__long_long__int, pythonic::dispatch::add__long_long__float, pythonic::dispatch::add__long_long__string, pythonic::dispatch::add__long_long__bool, pythonic::dispatch::add__long_long__double, pythonic::dispatch::add__long_long__long, pythonic::dispatch::add__long_long__long_long, pythonic::dispatch::add__long_long__long_double, pythonic::dispatch::add__long_long__uint, pythonic::dispatch::add__long_long__ulong, pythonic::dispatch::add__long_long__ulong_long, pythonic::dispatch::add__long_long__list, pythonic::dispatch::add__long_long__set, pythonic::dispatch::add__long_long__dict, pythonic::dispatch::add__long_long__orderedset, pythonic::dispatch::add__long_long__ordereddict, pythonic::dispatch::add__long_long__graph};
    t[8] = {pythonic::dispatch::add__long_double__none, pythonic::dispatch::add__long_double__int, pythonic::dispatch::add__long_double__float, pythonic::dispatch::add__long_double__string, pythonic::dispatch::add__long_double__bool, pythonic::dispatch::add__long_double__double, pythonic::dispatch::add__long_double__long, pythonic::dispatch::add__long_double__long_long, pythonic::dispatch::add__long_double__long_double, pythonic::dispatch::add__long_double__uint, pythonic::dispatch::add__long_double__ulong, pythonic::dispatch::add__long_double__ulong_long, pythonic::dispatch::add__long_double__list, pythonic::dispatch::add__long_double__set, pythonic::dispatch::add__long_double__dict, pythonic::dispatch::add__long_double__orderedset, pythonic::dispatch::add__long_double__ordereddict, pythonic::dispatch::add__long_double__graph};
    t[9] = {pythonic::dispatch::add__uint__none, pythonic::dispatch::add__uint__int, pythonic::dispatch::add__uint__float, pythonic::dispatch::add__uint__string, pythonic::dispatch::add__uint__bool, pythonic::dispatch::add__uint__double, pythonic::dispatch::add__uint__long, pythonic::dispatch::add__uint__long_long, pythonic::dispatch::add__uint__long_double, pythonic::dispatch::add__uint__uint, pythonic::dispatch::add__uint__ulong, pythonic::dispatch::add__uint__ulong_long, pythonic::dispatch::add__uint__list, pythonic::dispatch::add__uint__set, pythonic::dispatch::add__uint__dict, pythonic::dispatch::add__uint__orderedset, pythonic::dispatch::add__uint__ordereddict, pythonic::dispatch::add__uint__graph};
    t[10] = {pythonic::dispatch::add__ulong__none, pythonic::dispatch::add__ulong__int, pythonic::dispatch::add__ulong__float, pythonic::dispatch::add__ulong__string, pythonic::dispatch::add__ulong__bool, pythonic::dispatch::add__ulong__double, pythonic::dispatch::add__ulong__long, pythonic::dispatch::add__ulong__long_long, pythonic::dispatch::add__ulong__long_double, pythonic::dispatch::add__ulong__uint, pythonic::dispatch::add__ulong__ulong, pythonic::dispatch::add__ulong__ulong_long, pythonic::dispatch::add__ulong__list, pythonic::dispatch::add__ulong__set, pythonic::dispatch::add__ulong__dict, pythonic::dispatch::add__ulong__orderedset, pythonic::dispatch::add__ulong__ordereddict, pythonic::dispatch::add__ulong__graph};
    t[11] = {pythonic::dispatch::add__ulong_long__none, pythonic::dispatch::add__ulong_long__int, pythonic::dispatch::add__ulong_long__float, pythonic::dispatch::add__ulong_long__string, pythonic::dispatch::add__ulong_long__bool, pythonic::dispatch::add__ulong_long__double, pythonic::dispatch::add__ulong_long__long, pythonic::dispatch::add__ulong_long__long_long, pythonic::dispatch::add__ulong_long__long_double, pythonic::dispatch::add__ulong_long__uint, pythonic::dispatch::add__ulong_long__ulong, pythonic::dispatch::add__ulong_long__ulong_long, pythonic::dispatch::add__ulong_long__list, pythonic::dispatch::add__ulong_long__set, pythonic::dispatch::add__ulong_long__dict, pythonic::dispatch::add__ulong_long__orderedset, pythonic::dispatch::add__ulong_long__ordereddict, pythonic::dispatch::add__ulong_long__graph};
    t[12] = {pythonic::dispatch::add__list__none, pythonic::dispatch::add__list__int, pythonic::dispatch::add__list__float, pythonic::dispatch::add__list__string, pythonic::dispatch::add__list__bool, pythonic::dispatch::add__list__double, pythonic::dispatch::add__list__long, pythonic::dispatch::add__list__long_long, pythonic::dispatch::add__list__long_double, pythonic::dispatch::add__list__uint, pythonic::dispatch::add__list__ulong, pythonic::dispatch::add__list__ulong_long, pythonic::dispatch::add__list__list, pythonic::dispatch::add__list__set, pythonic::dispatch::add__list__dict, pythonic::dispatch::add__list__orderedset, pythonic::dispatch::add__list__ordereddict, pythonic::dispatch::add__list__graph};
    t[13] = {pythonic::dispatch::add__set__none, pythonic::dispatch::add__set__int, pythonic::dispatch::add__set__float, pythonic::dispatch::add__set__string, pythonic::dispatch::add__set__bool, pythonic::dispatch::add__set__double, pythonic::dispatch::add__set__long, pythonic::dispatch::add__set__long_long, pythonic::dispatch::add__set__long_double, pythonic::dispatch::add__set__uint, pythonic::dispatch::add__set__ulong, pythonic::dispatch::add__set__ulong_long, pythonic::dispatch::add__set__list, pythonic::dispatch::add__set__set, pythonic::dispatch::add__set__dict, pythonic::dispatch::add__set__orderedset, pythonic::dispatch::add__set__ordereddict, pythonic::dispatch::add__set__graph};
    t[14] = {pythonic::dispatch::add__dict__none, pythonic::dispatch::add__dict__int, pythonic::dispatch::add__dict__float, pythonic::dispatch::add__dict__string, pythonic::dispatch::add__dict__bool, pythonic::dispatch::add__dict__double, pythonic::dispatch::add__dict__long, pythonic::dispatch::add__dict__long_long, pythonic::dispatch::add__dict__long_double, pythonic::dispatch::add__dict__uint, pythonic::dispatch::add__dict__ulong, pythonic::dispatch::add__dict__ulong_long, pythonic::dispatch::add__dict__list, pythonic::dispatch::add__dict__set, pythonic::dispatch::add__dict__dict, pythonic::dispatch::add__dict__orderedset, pythonic::dispatch::add__dict__ordereddict, pythonic::dispatch::add__dict__graph};
    t[15] = {pythonic::dispatch::add__orderedset__none, pythonic::dispatch::add__orderedset__int, pythonic::dispatch::add__orderedset__float, pythonic::dispatch::add__orderedset__string, pythonic::dispatch::add__orderedset__bool, pythonic::dispatch::add__orderedset__double, pythonic::dispatch::add__orderedset__long, pythonic::dispatch::add__orderedset__long_long, pythonic::dispatch::add__orderedset__long_double, pythonic::dispatch::add__orderedset__uint, pythonic::dispatch::add__orderedset__ulong, pythonic::dispatch::add__orderedset__ulong_long, pythonic::dispatch::add__orderedset__list, pythonic::dispatch::add__orderedset__set, pythonic::dispatch::add__orderedset__dict, pythonic::dispatch::add__orderedset__orderedset, pythonic::dispatch::add__orderedset__ordereddict, pythonic::dispatch::add__orderedset__graph};
    t[16] = {pythonic::dispatch::add__ordereddict__none, pythonic::dispatch::add__ordereddict__int, pythonic::dispatch::add__ordereddict__float, pythonic::dispatch::add__ordereddict__string, pythonic::dispatch::add__ordereddict__bool, pythonic::dispatch::add__ordereddict__double, pythonic::dispatch::add__ordereddict__long, pythonic::dispatch::add__ordereddict__long_long, pythonic::dispatch::add__ordereddict__long_double, pythonic::dispatch::add__ordereddict__uint, pythonic::dispatch::add__ordereddict__ulong, pythonic::dispatch::add__ordereddict__ulong_long, pythonic::dispatch::add__ordereddict__list, pythonic::dispatch::add__ordereddict__set, pythonic::dispatch::add__ordereddict__dict, pythonic::dispatch::add__ordereddict__orderedset, pythonic::dispatch::add__ordereddict__ordereddict, pythonic::dispatch::add__ordereddict__graph};
    t[17] = {pythonic::dispatch::add__graph__none, pythonic::dispatch::add__graph__int, pythonic::dispatch::add__graph__float, pythonic::dispatch::add__graph__string, pythonic::dispatch::add__graph__bool, pythonic::dispatch::add__graph__double, pythonic::dispatch::add__graph__long, pythonic::dispatch::add__graph__long_long, pythonic::dispatch::add__graph__long_double, pythonic::dispatch::add__graph__uint, pythonic::dispatch::add__graph__ulong, pythonic::dispatch::add__graph__ulong_long, pythonic::dispatch::add__graph__list, pythonic::dispatch::add__graph__set, pythonic::dispatch::add__graph__dict, pythonic::dispatch::add__graph__orderedset, pythonic::dispatch::add__graph__ordereddict, pythonic::dispatch::add__graph__graph};
    return t;
}();

// OpTable initialization for Sub
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Sub>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::sub__none__none, pythonic::dispatch::sub__none__int, pythonic::dispatch::sub__none__float, pythonic::dispatch::sub__none__string, pythonic::dispatch::sub__none__bool, pythonic::dispatch::sub__none__double, pythonic::dispatch::sub__none__long, pythonic::dispatch::sub__none__long_long, pythonic::dispatch::sub__none__long_double, pythonic::dispatch::sub__none__uint, pythonic::dispatch::sub__none__ulong, pythonic::dispatch::sub__none__ulong_long, pythonic::dispatch::sub__none__list, pythonic::dispatch::sub__none__set, pythonic::dispatch::sub__none__dict, pythonic::dispatch::sub__none__orderedset, pythonic::dispatch::sub__none__ordereddict, pythonic::dispatch::sub__none__graph};
    t[1] = {pythonic::dispatch::sub__int__none, pythonic::dispatch::sub__int__int, pythonic::dispatch::sub__int__float, pythonic::dispatch::sub__int__string, pythonic::dispatch::sub__int__bool, pythonic::dispatch::sub__int__double, pythonic::dispatch::sub__int__long, pythonic::dispatch::sub__int__long_long, pythonic::dispatch::sub__int__long_double, pythonic::dispatch::sub__int__uint, pythonic::dispatch::sub__int__ulong, pythonic::dispatch::sub__int__ulong_long, pythonic::dispatch::sub__int__list, pythonic::dispatch::sub__int__set, pythonic::dispatch::sub__int__dict, pythonic::dispatch::sub__int__orderedset, pythonic::dispatch::sub__int__ordereddict, pythonic::dispatch::sub__int__graph};
    t[2] = {pythonic::dispatch::sub__float__none, pythonic::dispatch::sub__float__int, pythonic::dispatch::sub__float__float, pythonic::dispatch::sub__float__string, pythonic::dispatch::sub__float__bool, pythonic::dispatch::sub__float__double, pythonic::dispatch::sub__float__long, pythonic::dispatch::sub__float__long_long, pythonic::dispatch::sub__float__long_double, pythonic::dispatch::sub__float__uint, pythonic::dispatch::sub__float__ulong, pythonic::dispatch::sub__float__ulong_long, pythonic::dispatch::sub__float__list, pythonic::dispatch::sub__float__set, pythonic::dispatch::sub__float__dict, pythonic::dispatch::sub__float__orderedset, pythonic::dispatch::sub__float__ordereddict, pythonic::dispatch::sub__float__graph};
    t[3] = {pythonic::dispatch::sub__string__none, pythonic::dispatch::sub__string__int, pythonic::dispatch::sub__string__float, pythonic::dispatch::sub__string__string, pythonic::dispatch::sub__string__bool, pythonic::dispatch::sub__string__double, pythonic::dispatch::sub__string__long, pythonic::dispatch::sub__string__long_long, pythonic::dispatch::sub__string__long_double, pythonic::dispatch::sub__string__uint, pythonic::dispatch::sub__string__ulong, pythonic::dispatch::sub__string__ulong_long, pythonic::dispatch::sub__string__list, pythonic::dispatch::sub__string__set, pythonic::dispatch::sub__string__dict, pythonic::dispatch::sub__string__orderedset, pythonic::dispatch::sub__string__ordereddict, pythonic::dispatch::sub__string__graph};
    t[4] = {pythonic::dispatch::sub__bool__none, pythonic::dispatch::sub__bool__int, pythonic::dispatch::sub__bool__float, pythonic::dispatch::sub__bool__string, pythonic::dispatch::sub__bool__bool, pythonic::dispatch::sub__bool__double, pythonic::dispatch::sub__bool__long, pythonic::dispatch::sub__bool__long_long, pythonic::dispatch::sub__bool__long_double, pythonic::dispatch::sub__bool__uint, pythonic::dispatch::sub__bool__ulong, pythonic::dispatch::sub__bool__ulong_long, pythonic::dispatch::sub__bool__list, pythonic::dispatch::sub__bool__set, pythonic::dispatch::sub__bool__dict, pythonic::dispatch::sub__bool__orderedset, pythonic::dispatch::sub__bool__ordereddict, pythonic::dispatch::sub__bool__graph};
    t[5] = {pythonic::dispatch::sub__double__none, pythonic::dispatch::sub__double__int, pythonic::dispatch::sub__double__float, pythonic::dispatch::sub__double__string, pythonic::dispatch::sub__double__bool, pythonic::dispatch::sub__double__double, pythonic::dispatch::sub__double__long, pythonic::dispatch::sub__double__long_long, pythonic::dispatch::sub__double__long_double, pythonic::dispatch::sub__double__uint, pythonic::dispatch::sub__double__ulong, pythonic::dispatch::sub__double__ulong_long, pythonic::dispatch::sub__double__list, pythonic::dispatch::sub__double__set, pythonic::dispatch::sub__double__dict, pythonic::dispatch::sub__double__orderedset, pythonic::dispatch::sub__double__ordereddict, pythonic::dispatch::sub__double__graph};
    t[6] = {pythonic::dispatch::sub__long__none, pythonic::dispatch::sub__long__int, pythonic::dispatch::sub__long__float, pythonic::dispatch::sub__long__string, pythonic::dispatch::sub__long__bool, pythonic::dispatch::sub__long__double, pythonic::dispatch::sub__long__long, pythonic::dispatch::sub__long__long_long, pythonic::dispatch::sub__long__long_double, pythonic::dispatch::sub__long__uint, pythonic::dispatch::sub__long__ulong, pythonic::dispatch::sub__long__ulong_long, pythonic::dispatch::sub__long__list, pythonic::dispatch::sub__long__set, pythonic::dispatch::sub__long__dict, pythonic::dispatch::sub__long__orderedset, pythonic::dispatch::sub__long__ordereddict, pythonic::dispatch::sub__long__graph};
    t[7] = {pythonic::dispatch::sub__long_long__none, pythonic::dispatch::sub__long_long__int, pythonic::dispatch::sub__long_long__float, pythonic::dispatch::sub__long_long__string, pythonic::dispatch::sub__long_long__bool, pythonic::dispatch::sub__long_long__double, pythonic::dispatch::sub__long_long__long, pythonic::dispatch::sub__long_long__long_long, pythonic::dispatch::sub__long_long__long_double, pythonic::dispatch::sub__long_long__uint, pythonic::dispatch::sub__long_long__ulong, pythonic::dispatch::sub__long_long__ulong_long, pythonic::dispatch::sub__long_long__list, pythonic::dispatch::sub__long_long__set, pythonic::dispatch::sub__long_long__dict, pythonic::dispatch::sub__long_long__orderedset, pythonic::dispatch::sub__long_long__ordereddict, pythonic::dispatch::sub__long_long__graph};
    t[8] = {pythonic::dispatch::sub__long_double__none, pythonic::dispatch::sub__long_double__int, pythonic::dispatch::sub__long_double__float, pythonic::dispatch::sub__long_double__string, pythonic::dispatch::sub__long_double__bool, pythonic::dispatch::sub__long_double__double, pythonic::dispatch::sub__long_double__long, pythonic::dispatch::sub__long_double__long_long, pythonic::dispatch::sub__long_double__long_double, pythonic::dispatch::sub__long_double__uint, pythonic::dispatch::sub__long_double__ulong, pythonic::dispatch::sub__long_double__ulong_long, pythonic::dispatch::sub__long_double__list, pythonic::dispatch::sub__long_double__set, pythonic::dispatch::sub__long_double__dict, pythonic::dispatch::sub__long_double__orderedset, pythonic::dispatch::sub__long_double__ordereddict, pythonic::dispatch::sub__long_double__graph};
    t[9] = {pythonic::dispatch::sub__uint__none, pythonic::dispatch::sub__uint__int, pythonic::dispatch::sub__uint__float, pythonic::dispatch::sub__uint__string, pythonic::dispatch::sub__uint__bool, pythonic::dispatch::sub__uint__double, pythonic::dispatch::sub__uint__long, pythonic::dispatch::sub__uint__long_long, pythonic::dispatch::sub__uint__long_double, pythonic::dispatch::sub__uint__uint, pythonic::dispatch::sub__uint__ulong, pythonic::dispatch::sub__uint__ulong_long, pythonic::dispatch::sub__uint__list, pythonic::dispatch::sub__uint__set, pythonic::dispatch::sub__uint__dict, pythonic::dispatch::sub__uint__orderedset, pythonic::dispatch::sub__uint__ordereddict, pythonic::dispatch::sub__uint__graph};
    t[10] = {pythonic::dispatch::sub__ulong__none, pythonic::dispatch::sub__ulong__int, pythonic::dispatch::sub__ulong__float, pythonic::dispatch::sub__ulong__string, pythonic::dispatch::sub__ulong__bool, pythonic::dispatch::sub__ulong__double, pythonic::dispatch::sub__ulong__long, pythonic::dispatch::sub__ulong__long_long, pythonic::dispatch::sub__ulong__long_double, pythonic::dispatch::sub__ulong__uint, pythonic::dispatch::sub__ulong__ulong, pythonic::dispatch::sub__ulong__ulong_long, pythonic::dispatch::sub__ulong__list, pythonic::dispatch::sub__ulong__set, pythonic::dispatch::sub__ulong__dict, pythonic::dispatch::sub__ulong__orderedset, pythonic::dispatch::sub__ulong__ordereddict, pythonic::dispatch::sub__ulong__graph};
    t[11] = {pythonic::dispatch::sub__ulong_long__none, pythonic::dispatch::sub__ulong_long__int, pythonic::dispatch::sub__ulong_long__float, pythonic::dispatch::sub__ulong_long__string, pythonic::dispatch::sub__ulong_long__bool, pythonic::dispatch::sub__ulong_long__double, pythonic::dispatch::sub__ulong_long__long, pythonic::dispatch::sub__ulong_long__long_long, pythonic::dispatch::sub__ulong_long__long_double, pythonic::dispatch::sub__ulong_long__uint, pythonic::dispatch::sub__ulong_long__ulong, pythonic::dispatch::sub__ulong_long__ulong_long, pythonic::dispatch::sub__ulong_long__list, pythonic::dispatch::sub__ulong_long__set, pythonic::dispatch::sub__ulong_long__dict, pythonic::dispatch::sub__ulong_long__orderedset, pythonic::dispatch::sub__ulong_long__ordereddict, pythonic::dispatch::sub__ulong_long__graph};
    t[12] = {pythonic::dispatch::sub__list__none, pythonic::dispatch::sub__list__int, pythonic::dispatch::sub__list__float, pythonic::dispatch::sub__list__string, pythonic::dispatch::sub__list__bool, pythonic::dispatch::sub__list__double, pythonic::dispatch::sub__list__long, pythonic::dispatch::sub__list__long_long, pythonic::dispatch::sub__list__long_double, pythonic::dispatch::sub__list__uint, pythonic::dispatch::sub__list__ulong, pythonic::dispatch::sub__list__ulong_long, pythonic::dispatch::sub__list__list, pythonic::dispatch::sub__list__set, pythonic::dispatch::sub__list__dict, pythonic::dispatch::sub__list__orderedset, pythonic::dispatch::sub__list__ordereddict, pythonic::dispatch::sub__list__graph};
    t[13] = {pythonic::dispatch::sub__set__none, pythonic::dispatch::sub__set__int, pythonic::dispatch::sub__set__float, pythonic::dispatch::sub__set__string, pythonic::dispatch::sub__set__bool, pythonic::dispatch::sub__set__double, pythonic::dispatch::sub__set__long, pythonic::dispatch::sub__set__long_long, pythonic::dispatch::sub__set__long_double, pythonic::dispatch::sub__set__uint, pythonic::dispatch::sub__set__ulong, pythonic::dispatch::sub__set__ulong_long, pythonic::dispatch::sub__set__list, pythonic::dispatch::sub__set__set, pythonic::dispatch::sub__set__dict, pythonic::dispatch::sub__set__orderedset, pythonic::dispatch::sub__set__ordereddict, pythonic::dispatch::sub__set__graph};
    t[14] = {pythonic::dispatch::sub__dict__none, pythonic::dispatch::sub__dict__int, pythonic::dispatch::sub__dict__float, pythonic::dispatch::sub__dict__string, pythonic::dispatch::sub__dict__bool, pythonic::dispatch::sub__dict__double, pythonic::dispatch::sub__dict__long, pythonic::dispatch::sub__dict__long_long, pythonic::dispatch::sub__dict__long_double, pythonic::dispatch::sub__dict__uint, pythonic::dispatch::sub__dict__ulong, pythonic::dispatch::sub__dict__ulong_long, pythonic::dispatch::sub__dict__list, pythonic::dispatch::sub__dict__set, pythonic::dispatch::sub__dict__dict, pythonic::dispatch::sub__dict__orderedset, pythonic::dispatch::sub__dict__ordereddict, pythonic::dispatch::sub__dict__graph};
    t[15] = {pythonic::dispatch::sub__orderedset__none, pythonic::dispatch::sub__orderedset__int, pythonic::dispatch::sub__orderedset__float, pythonic::dispatch::sub__orderedset__string, pythonic::dispatch::sub__orderedset__bool, pythonic::dispatch::sub__orderedset__double, pythonic::dispatch::sub__orderedset__long, pythonic::dispatch::sub__orderedset__long_long, pythonic::dispatch::sub__orderedset__long_double, pythonic::dispatch::sub__orderedset__uint, pythonic::dispatch::sub__orderedset__ulong, pythonic::dispatch::sub__orderedset__ulong_long, pythonic::dispatch::sub__orderedset__list, pythonic::dispatch::sub__orderedset__set, pythonic::dispatch::sub__orderedset__dict, pythonic::dispatch::sub__orderedset__orderedset, pythonic::dispatch::sub__orderedset__ordereddict, pythonic::dispatch::sub__orderedset__graph};
    t[16] = {pythonic::dispatch::sub__ordereddict__none, pythonic::dispatch::sub__ordereddict__int, pythonic::dispatch::sub__ordereddict__float, pythonic::dispatch::sub__ordereddict__string, pythonic::dispatch::sub__ordereddict__bool, pythonic::dispatch::sub__ordereddict__double, pythonic::dispatch::sub__ordereddict__long, pythonic::dispatch::sub__ordereddict__long_long, pythonic::dispatch::sub__ordereddict__long_double, pythonic::dispatch::sub__ordereddict__uint, pythonic::dispatch::sub__ordereddict__ulong, pythonic::dispatch::sub__ordereddict__ulong_long, pythonic::dispatch::sub__ordereddict__list, pythonic::dispatch::sub__ordereddict__set, pythonic::dispatch::sub__ordereddict__dict, pythonic::dispatch::sub__ordereddict__orderedset, pythonic::dispatch::sub__ordereddict__ordereddict, pythonic::dispatch::sub__ordereddict__graph};
    t[17] = {pythonic::dispatch::sub__graph__none, pythonic::dispatch::sub__graph__int, pythonic::dispatch::sub__graph__float, pythonic::dispatch::sub__graph__string, pythonic::dispatch::sub__graph__bool, pythonic::dispatch::sub__graph__double, pythonic::dispatch::sub__graph__long, pythonic::dispatch::sub__graph__long_long, pythonic::dispatch::sub__graph__long_double, pythonic::dispatch::sub__graph__uint, pythonic::dispatch::sub__graph__ulong, pythonic::dispatch::sub__graph__ulong_long, pythonic::dispatch::sub__graph__list, pythonic::dispatch::sub__graph__set, pythonic::dispatch::sub__graph__dict, pythonic::dispatch::sub__graph__orderedset, pythonic::dispatch::sub__graph__ordereddict, pythonic::dispatch::sub__graph__graph};
    return t;
}();

// OpTable initialization for Mul
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Mul>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::mul__none__none, pythonic::dispatch::mul__none__int, pythonic::dispatch::mul__none__float, pythonic::dispatch::mul__none__string, pythonic::dispatch::mul__none__bool, pythonic::dispatch::mul__none__double, pythonic::dispatch::mul__none__long, pythonic::dispatch::mul__none__long_long, pythonic::dispatch::mul__none__long_double, pythonic::dispatch::mul__none__uint, pythonic::dispatch::mul__none__ulong, pythonic::dispatch::mul__none__ulong_long, pythonic::dispatch::mul__none__list, pythonic::dispatch::mul__none__set, pythonic::dispatch::mul__none__dict, pythonic::dispatch::mul__none__orderedset, pythonic::dispatch::mul__none__ordereddict, pythonic::dispatch::mul__none__graph};
    t[1] = {pythonic::dispatch::mul__int__none, pythonic::dispatch::mul__int__int, pythonic::dispatch::mul__int__float, pythonic::dispatch::mul__int__string, pythonic::dispatch::mul__int__bool, pythonic::dispatch::mul__int__double, pythonic::dispatch::mul__int__long, pythonic::dispatch::mul__int__long_long, pythonic::dispatch::mul__int__long_double, pythonic::dispatch::mul__int__uint, pythonic::dispatch::mul__int__ulong, pythonic::dispatch::mul__int__ulong_long, pythonic::dispatch::mul__int__list, pythonic::dispatch::mul__int__set, pythonic::dispatch::mul__int__dict, pythonic::dispatch::mul__int__orderedset, pythonic::dispatch::mul__int__ordereddict, pythonic::dispatch::mul__int__graph};
    t[2] = {pythonic::dispatch::mul__float__none, pythonic::dispatch::mul__float__int, pythonic::dispatch::mul__float__float, pythonic::dispatch::mul__float__string, pythonic::dispatch::mul__float__bool, pythonic::dispatch::mul__float__double, pythonic::dispatch::mul__float__long, pythonic::dispatch::mul__float__long_long, pythonic::dispatch::mul__float__long_double, pythonic::dispatch::mul__float__uint, pythonic::dispatch::mul__float__ulong, pythonic::dispatch::mul__float__ulong_long, pythonic::dispatch::mul__float__list, pythonic::dispatch::mul__float__set, pythonic::dispatch::mul__float__dict, pythonic::dispatch::mul__float__orderedset, pythonic::dispatch::mul__float__ordereddict, pythonic::dispatch::mul__float__graph};
    t[3] = {pythonic::dispatch::mul__string__none, pythonic::dispatch::mul__string__int, pythonic::dispatch::mul__string__float, pythonic::dispatch::mul__string__string, pythonic::dispatch::mul__string__bool, pythonic::dispatch::mul__string__double, pythonic::dispatch::mul__string__long, pythonic::dispatch::mul__string__long_long, pythonic::dispatch::mul__string__long_double, pythonic::dispatch::mul__string__uint, pythonic::dispatch::mul__string__ulong, pythonic::dispatch::mul__string__ulong_long, pythonic::dispatch::mul__string__list, pythonic::dispatch::mul__string__set, pythonic::dispatch::mul__string__dict, pythonic::dispatch::mul__string__orderedset, pythonic::dispatch::mul__string__ordereddict, pythonic::dispatch::mul__string__graph};
    t[4] = {pythonic::dispatch::mul__bool__none, pythonic::dispatch::mul__bool__int, pythonic::dispatch::mul__bool__float, pythonic::dispatch::mul__bool__string, pythonic::dispatch::mul__bool__bool, pythonic::dispatch::mul__bool__double, pythonic::dispatch::mul__bool__long, pythonic::dispatch::mul__bool__long_long, pythonic::dispatch::mul__bool__long_double, pythonic::dispatch::mul__bool__uint, pythonic::dispatch::mul__bool__ulong, pythonic::dispatch::mul__bool__ulong_long, pythonic::dispatch::mul__bool__list, pythonic::dispatch::mul__bool__set, pythonic::dispatch::mul__bool__dict, pythonic::dispatch::mul__bool__orderedset, pythonic::dispatch::mul__bool__ordereddict, pythonic::dispatch::mul__bool__graph};
    t[5] = {pythonic::dispatch::mul__double__none, pythonic::dispatch::mul__double__int, pythonic::dispatch::mul__double__float, pythonic::dispatch::mul__double__string, pythonic::dispatch::mul__double__bool, pythonic::dispatch::mul__double__double, pythonic::dispatch::mul__double__long, pythonic::dispatch::mul__double__long_long, pythonic::dispatch::mul__double__long_double, pythonic::dispatch::mul__double__uint, pythonic::dispatch::mul__double__ulong, pythonic::dispatch::mul__double__ulong_long, pythonic::dispatch::mul__double__list, pythonic::dispatch::mul__double__set, pythonic::dispatch::mul__double__dict, pythonic::dispatch::mul__double__orderedset, pythonic::dispatch::mul__double__ordereddict, pythonic::dispatch::mul__double__graph};
    t[6] = {pythonic::dispatch::mul__long__none, pythonic::dispatch::mul__long__int, pythonic::dispatch::mul__long__float, pythonic::dispatch::mul__long__string, pythonic::dispatch::mul__long__bool, pythonic::dispatch::mul__long__double, pythonic::dispatch::mul__long__long, pythonic::dispatch::mul__long__long_long, pythonic::dispatch::mul__long__long_double, pythonic::dispatch::mul__long__uint, pythonic::dispatch::mul__long__ulong, pythonic::dispatch::mul__long__ulong_long, pythonic::dispatch::mul__long__list, pythonic::dispatch::mul__long__set, pythonic::dispatch::mul__long__dict, pythonic::dispatch::mul__long__orderedset, pythonic::dispatch::mul__long__ordereddict, pythonic::dispatch::mul__long__graph};
    t[7] = {pythonic::dispatch::mul__long_long__none, pythonic::dispatch::mul__long_long__int, pythonic::dispatch::mul__long_long__float, pythonic::dispatch::mul__long_long__string, pythonic::dispatch::mul__long_long__bool, pythonic::dispatch::mul__long_long__double, pythonic::dispatch::mul__long_long__long, pythonic::dispatch::mul__long_long__long_long, pythonic::dispatch::mul__long_long__long_double, pythonic::dispatch::mul__long_long__uint, pythonic::dispatch::mul__long_long__ulong, pythonic::dispatch::mul__long_long__ulong_long, pythonic::dispatch::mul__long_long__list, pythonic::dispatch::mul__long_long__set, pythonic::dispatch::mul__long_long__dict, pythonic::dispatch::mul__long_long__orderedset, pythonic::dispatch::mul__long_long__ordereddict, pythonic::dispatch::mul__long_long__graph};
    t[8] = {pythonic::dispatch::mul__long_double__none, pythonic::dispatch::mul__long_double__int, pythonic::dispatch::mul__long_double__float, pythonic::dispatch::mul__long_double__string, pythonic::dispatch::mul__long_double__bool, pythonic::dispatch::mul__long_double__double, pythonic::dispatch::mul__long_double__long, pythonic::dispatch::mul__long_double__long_long, pythonic::dispatch::mul__long_double__long_double, pythonic::dispatch::mul__long_double__uint, pythonic::dispatch::mul__long_double__ulong, pythonic::dispatch::mul__long_double__ulong_long, pythonic::dispatch::mul__long_double__list, pythonic::dispatch::mul__long_double__set, pythonic::dispatch::mul__long_double__dict, pythonic::dispatch::mul__long_double__orderedset, pythonic::dispatch::mul__long_double__ordereddict, pythonic::dispatch::mul__long_double__graph};
    t[9] = {pythonic::dispatch::mul__uint__none, pythonic::dispatch::mul__uint__int, pythonic::dispatch::mul__uint__float, pythonic::dispatch::mul__uint__string, pythonic::dispatch::mul__uint__bool, pythonic::dispatch::mul__uint__double, pythonic::dispatch::mul__uint__long, pythonic::dispatch::mul__uint__long_long, pythonic::dispatch::mul__uint__long_double, pythonic::dispatch::mul__uint__uint, pythonic::dispatch::mul__uint__ulong, pythonic::dispatch::mul__uint__ulong_long, pythonic::dispatch::mul__uint__list, pythonic::dispatch::mul__uint__set, pythonic::dispatch::mul__uint__dict, pythonic::dispatch::mul__uint__orderedset, pythonic::dispatch::mul__uint__ordereddict, pythonic::dispatch::mul__uint__graph};
    t[10] = {pythonic::dispatch::mul__ulong__none, pythonic::dispatch::mul__ulong__int, pythonic::dispatch::mul__ulong__float, pythonic::dispatch::mul__ulong__string, pythonic::dispatch::mul__ulong__bool, pythonic::dispatch::mul__ulong__double, pythonic::dispatch::mul__ulong__long, pythonic::dispatch::mul__ulong__long_long, pythonic::dispatch::mul__ulong__long_double, pythonic::dispatch::mul__ulong__uint, pythonic::dispatch::mul__ulong__ulong, pythonic::dispatch::mul__ulong__ulong_long, pythonic::dispatch::mul__ulong__list, pythonic::dispatch::mul__ulong__set, pythonic::dispatch::mul__ulong__dict, pythonic::dispatch::mul__ulong__orderedset, pythonic::dispatch::mul__ulong__ordereddict, pythonic::dispatch::mul__ulong__graph};
    t[11] = {pythonic::dispatch::mul__ulong_long__none, pythonic::dispatch::mul__ulong_long__int, pythonic::dispatch::mul__ulong_long__float, pythonic::dispatch::mul__ulong_long__string, pythonic::dispatch::mul__ulong_long__bool, pythonic::dispatch::mul__ulong_long__double, pythonic::dispatch::mul__ulong_long__long, pythonic::dispatch::mul__ulong_long__long_long, pythonic::dispatch::mul__ulong_long__long_double, pythonic::dispatch::mul__ulong_long__uint, pythonic::dispatch::mul__ulong_long__ulong, pythonic::dispatch::mul__ulong_long__ulong_long, pythonic::dispatch::mul__ulong_long__list, pythonic::dispatch::mul__ulong_long__set, pythonic::dispatch::mul__ulong_long__dict, pythonic::dispatch::mul__ulong_long__orderedset, pythonic::dispatch::mul__ulong_long__ordereddict, pythonic::dispatch::mul__ulong_long__graph};
    t[12] = {pythonic::dispatch::mul__list__none, pythonic::dispatch::mul__list__int, pythonic::dispatch::mul__list__float, pythonic::dispatch::mul__list__string, pythonic::dispatch::mul__list__bool, pythonic::dispatch::mul__list__double, pythonic::dispatch::mul__list__long, pythonic::dispatch::mul__list__long_long, pythonic::dispatch::mul__list__long_double, pythonic::dispatch::mul__list__uint, pythonic::dispatch::mul__list__ulong, pythonic::dispatch::mul__list__ulong_long, pythonic::dispatch::mul__list__list, pythonic::dispatch::mul__list__set, pythonic::dispatch::mul__list__dict, pythonic::dispatch::mul__list__orderedset, pythonic::dispatch::mul__list__ordereddict, pythonic::dispatch::mul__list__graph};
    t[13] = {pythonic::dispatch::mul__set__none, pythonic::dispatch::mul__set__int, pythonic::dispatch::mul__set__float, pythonic::dispatch::mul__set__string, pythonic::dispatch::mul__set__bool, pythonic::dispatch::mul__set__double, pythonic::dispatch::mul__set__long, pythonic::dispatch::mul__set__long_long, pythonic::dispatch::mul__set__long_double, pythonic::dispatch::mul__set__uint, pythonic::dispatch::mul__set__ulong, pythonic::dispatch::mul__set__ulong_long, pythonic::dispatch::mul__set__list, pythonic::dispatch::mul__set__set, pythonic::dispatch::mul__set__dict, pythonic::dispatch::mul__set__orderedset, pythonic::dispatch::mul__set__ordereddict, pythonic::dispatch::mul__set__graph};
    t[14] = {pythonic::dispatch::mul__dict__none, pythonic::dispatch::mul__dict__int, pythonic::dispatch::mul__dict__float, pythonic::dispatch::mul__dict__string, pythonic::dispatch::mul__dict__bool, pythonic::dispatch::mul__dict__double, pythonic::dispatch::mul__dict__long, pythonic::dispatch::mul__dict__long_long, pythonic::dispatch::mul__dict__long_double, pythonic::dispatch::mul__dict__uint, pythonic::dispatch::mul__dict__ulong, pythonic::dispatch::mul__dict__ulong_long, pythonic::dispatch::mul__dict__list, pythonic::dispatch::mul__dict__set, pythonic::dispatch::mul__dict__dict, pythonic::dispatch::mul__dict__orderedset, pythonic::dispatch::mul__dict__ordereddict, pythonic::dispatch::mul__dict__graph};
    t[15] = {pythonic::dispatch::mul__orderedset__none, pythonic::dispatch::mul__orderedset__int, pythonic::dispatch::mul__orderedset__float, pythonic::dispatch::mul__orderedset__string, pythonic::dispatch::mul__orderedset__bool, pythonic::dispatch::mul__orderedset__double, pythonic::dispatch::mul__orderedset__long, pythonic::dispatch::mul__orderedset__long_long, pythonic::dispatch::mul__orderedset__long_double, pythonic::dispatch::mul__orderedset__uint, pythonic::dispatch::mul__orderedset__ulong, pythonic::dispatch::mul__orderedset__ulong_long, pythonic::dispatch::mul__orderedset__list, pythonic::dispatch::mul__orderedset__set, pythonic::dispatch::mul__orderedset__dict, pythonic::dispatch::mul__orderedset__orderedset, pythonic::dispatch::mul__orderedset__ordereddict, pythonic::dispatch::mul__orderedset__graph};
    t[16] = {pythonic::dispatch::mul__ordereddict__none, pythonic::dispatch::mul__ordereddict__int, pythonic::dispatch::mul__ordereddict__float, pythonic::dispatch::mul__ordereddict__string, pythonic::dispatch::mul__ordereddict__bool, pythonic::dispatch::mul__ordereddict__double, pythonic::dispatch::mul__ordereddict__long, pythonic::dispatch::mul__ordereddict__long_long, pythonic::dispatch::mul__ordereddict__long_double, pythonic::dispatch::mul__ordereddict__uint, pythonic::dispatch::mul__ordereddict__ulong, pythonic::dispatch::mul__ordereddict__ulong_long, pythonic::dispatch::mul__ordereddict__list, pythonic::dispatch::mul__ordereddict__set, pythonic::dispatch::mul__ordereddict__dict, pythonic::dispatch::mul__ordereddict__orderedset, pythonic::dispatch::mul__ordereddict__ordereddict, pythonic::dispatch::mul__ordereddict__graph};
    t[17] = {pythonic::dispatch::mul__graph__none, pythonic::dispatch::mul__graph__int, pythonic::dispatch::mul__graph__float, pythonic::dispatch::mul__graph__string, pythonic::dispatch::mul__graph__bool, pythonic::dispatch::mul__graph__double, pythonic::dispatch::mul__graph__long, pythonic::dispatch::mul__graph__long_long, pythonic::dispatch::mul__graph__long_double, pythonic::dispatch::mul__graph__uint, pythonic::dispatch::mul__graph__ulong, pythonic::dispatch::mul__graph__ulong_long, pythonic::dispatch::mul__graph__list, pythonic::dispatch::mul__graph__set, pythonic::dispatch::mul__graph__dict, pythonic::dispatch::mul__graph__orderedset, pythonic::dispatch::mul__graph__ordereddict, pythonic::dispatch::mul__graph__graph};
    return t;
}();

// OpTable initialization for Div
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Div>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::div__none__none, pythonic::dispatch::div__none__int, pythonic::dispatch::div__none__float, pythonic::dispatch::div__none__string, pythonic::dispatch::div__none__bool, pythonic::dispatch::div__none__double, pythonic::dispatch::div__none__long, pythonic::dispatch::div__none__long_long, pythonic::dispatch::div__none__long_double, pythonic::dispatch::div__none__uint, pythonic::dispatch::div__none__ulong, pythonic::dispatch::div__none__ulong_long, pythonic::dispatch::div__none__list, pythonic::dispatch::div__none__set, pythonic::dispatch::div__none__dict, pythonic::dispatch::div__none__orderedset, pythonic::dispatch::div__none__ordereddict, pythonic::dispatch::div__none__graph};
    t[1] = {pythonic::dispatch::div__int__none, pythonic::dispatch::div__int__int, pythonic::dispatch::div__int__float, pythonic::dispatch::div__int__string, pythonic::dispatch::div__int__bool, pythonic::dispatch::div__int__double, pythonic::dispatch::div__int__long, pythonic::dispatch::div__int__long_long, pythonic::dispatch::div__int__long_double, pythonic::dispatch::div__int__uint, pythonic::dispatch::div__int__ulong, pythonic::dispatch::div__int__ulong_long, pythonic::dispatch::div__int__list, pythonic::dispatch::div__int__set, pythonic::dispatch::div__int__dict, pythonic::dispatch::div__int__orderedset, pythonic::dispatch::div__int__ordereddict, pythonic::dispatch::div__int__graph};
    t[2] = {pythonic::dispatch::div__float__none, pythonic::dispatch::div__float__int, pythonic::dispatch::div__float__float, pythonic::dispatch::div__float__string, pythonic::dispatch::div__float__bool, pythonic::dispatch::div__float__double, pythonic::dispatch::div__float__long, pythonic::dispatch::div__float__long_long, pythonic::dispatch::div__float__long_double, pythonic::dispatch::div__float__uint, pythonic::dispatch::div__float__ulong, pythonic::dispatch::div__float__ulong_long, pythonic::dispatch::div__float__list, pythonic::dispatch::div__float__set, pythonic::dispatch::div__float__dict, pythonic::dispatch::div__float__orderedset, pythonic::dispatch::div__float__ordereddict, pythonic::dispatch::div__float__graph};
    t[3] = {pythonic::dispatch::div__string__none, pythonic::dispatch::div__string__int, pythonic::dispatch::div__string__float, pythonic::dispatch::div__string__string, pythonic::dispatch::div__string__bool, pythonic::dispatch::div__string__double, pythonic::dispatch::div__string__long, pythonic::dispatch::div__string__long_long, pythonic::dispatch::div__string__long_double, pythonic::dispatch::div__string__uint, pythonic::dispatch::div__string__ulong, pythonic::dispatch::div__string__ulong_long, pythonic::dispatch::div__string__list, pythonic::dispatch::div__string__set, pythonic::dispatch::div__string__dict, pythonic::dispatch::div__string__orderedset, pythonic::dispatch::div__string__ordereddict, pythonic::dispatch::div__string__graph};
    t[4] = {pythonic::dispatch::div__bool__none, pythonic::dispatch::div__bool__int, pythonic::dispatch::div__bool__float, pythonic::dispatch::div__bool__string, pythonic::dispatch::div__bool__bool, pythonic::dispatch::div__bool__double, pythonic::dispatch::div__bool__long, pythonic::dispatch::div__bool__long_long, pythonic::dispatch::div__bool__long_double, pythonic::dispatch::div__bool__uint, pythonic::dispatch::div__bool__ulong, pythonic::dispatch::div__bool__ulong_long, pythonic::dispatch::div__bool__list, pythonic::dispatch::div__bool__set, pythonic::dispatch::div__bool__dict, pythonic::dispatch::div__bool__orderedset, pythonic::dispatch::div__bool__ordereddict, pythonic::dispatch::div__bool__graph};
    t[5] = {pythonic::dispatch::div__double__none, pythonic::dispatch::div__double__int, pythonic::dispatch::div__double__float, pythonic::dispatch::div__double__string, pythonic::dispatch::div__double__bool, pythonic::dispatch::div__double__double, pythonic::dispatch::div__double__long, pythonic::dispatch::div__double__long_long, pythonic::dispatch::div__double__long_double, pythonic::dispatch::div__double__uint, pythonic::dispatch::div__double__ulong, pythonic::dispatch::div__double__ulong_long, pythonic::dispatch::div__double__list, pythonic::dispatch::div__double__set, pythonic::dispatch::div__double__dict, pythonic::dispatch::div__double__orderedset, pythonic::dispatch::div__double__ordereddict, pythonic::dispatch::div__double__graph};
    t[6] = {pythonic::dispatch::div__long__none, pythonic::dispatch::div__long__int, pythonic::dispatch::div__long__float, pythonic::dispatch::div__long__string, pythonic::dispatch::div__long__bool, pythonic::dispatch::div__long__double, pythonic::dispatch::div__long__long, pythonic::dispatch::div__long__long_long, pythonic::dispatch::div__long__long_double, pythonic::dispatch::div__long__uint, pythonic::dispatch::div__long__ulong, pythonic::dispatch::div__long__ulong_long, pythonic::dispatch::div__long__list, pythonic::dispatch::div__long__set, pythonic::dispatch::div__long__dict, pythonic::dispatch::div__long__orderedset, pythonic::dispatch::div__long__ordereddict, pythonic::dispatch::div__long__graph};
    t[7] = {pythonic::dispatch::div__long_long__none, pythonic::dispatch::div__long_long__int, pythonic::dispatch::div__long_long__float, pythonic::dispatch::div__long_long__string, pythonic::dispatch::div__long_long__bool, pythonic::dispatch::div__long_long__double, pythonic::dispatch::div__long_long__long, pythonic::dispatch::div__long_long__long_long, pythonic::dispatch::div__long_long__long_double, pythonic::dispatch::div__long_long__uint, pythonic::dispatch::div__long_long__ulong, pythonic::dispatch::div__long_long__ulong_long, pythonic::dispatch::div__long_long__list, pythonic::dispatch::div__long_long__set, pythonic::dispatch::div__long_long__dict, pythonic::dispatch::div__long_long__orderedset, pythonic::dispatch::div__long_long__ordereddict, pythonic::dispatch::div__long_long__graph};
    t[8] = {pythonic::dispatch::div__long_double__none, pythonic::dispatch::div__long_double__int, pythonic::dispatch::div__long_double__float, pythonic::dispatch::div__long_double__string, pythonic::dispatch::div__long_double__bool, pythonic::dispatch::div__long_double__double, pythonic::dispatch::div__long_double__long, pythonic::dispatch::div__long_double__long_long, pythonic::dispatch::div__long_double__long_double, pythonic::dispatch::div__long_double__uint, pythonic::dispatch::div__long_double__ulong, pythonic::dispatch::div__long_double__ulong_long, pythonic::dispatch::div__long_double__list, pythonic::dispatch::div__long_double__set, pythonic::dispatch::div__long_double__dict, pythonic::dispatch::div__long_double__orderedset, pythonic::dispatch::div__long_double__ordereddict, pythonic::dispatch::div__long_double__graph};
    t[9] = {pythonic::dispatch::div__uint__none, pythonic::dispatch::div__uint__int, pythonic::dispatch::div__uint__float, pythonic::dispatch::div__uint__string, pythonic::dispatch::div__uint__bool, pythonic::dispatch::div__uint__double, pythonic::dispatch::div__uint__long, pythonic::dispatch::div__uint__long_long, pythonic::dispatch::div__uint__long_double, pythonic::dispatch::div__uint__uint, pythonic::dispatch::div__uint__ulong, pythonic::dispatch::div__uint__ulong_long, pythonic::dispatch::div__uint__list, pythonic::dispatch::div__uint__set, pythonic::dispatch::div__uint__dict, pythonic::dispatch::div__uint__orderedset, pythonic::dispatch::div__uint__ordereddict, pythonic::dispatch::div__uint__graph};
    t[10] = {pythonic::dispatch::div__ulong__none, pythonic::dispatch::div__ulong__int, pythonic::dispatch::div__ulong__float, pythonic::dispatch::div__ulong__string, pythonic::dispatch::div__ulong__bool, pythonic::dispatch::div__ulong__double, pythonic::dispatch::div__ulong__long, pythonic::dispatch::div__ulong__long_long, pythonic::dispatch::div__ulong__long_double, pythonic::dispatch::div__ulong__uint, pythonic::dispatch::div__ulong__ulong, pythonic::dispatch::div__ulong__ulong_long, pythonic::dispatch::div__ulong__list, pythonic::dispatch::div__ulong__set, pythonic::dispatch::div__ulong__dict, pythonic::dispatch::div__ulong__orderedset, pythonic::dispatch::div__ulong__ordereddict, pythonic::dispatch::div__ulong__graph};
    t[11] = {pythonic::dispatch::div__ulong_long__none, pythonic::dispatch::div__ulong_long__int, pythonic::dispatch::div__ulong_long__float, pythonic::dispatch::div__ulong_long__string, pythonic::dispatch::div__ulong_long__bool, pythonic::dispatch::div__ulong_long__double, pythonic::dispatch::div__ulong_long__long, pythonic::dispatch::div__ulong_long__long_long, pythonic::dispatch::div__ulong_long__long_double, pythonic::dispatch::div__ulong_long__uint, pythonic::dispatch::div__ulong_long__ulong, pythonic::dispatch::div__ulong_long__ulong_long, pythonic::dispatch::div__ulong_long__list, pythonic::dispatch::div__ulong_long__set, pythonic::dispatch::div__ulong_long__dict, pythonic::dispatch::div__ulong_long__orderedset, pythonic::dispatch::div__ulong_long__ordereddict, pythonic::dispatch::div__ulong_long__graph};
    t[12] = {pythonic::dispatch::div__list__none, pythonic::dispatch::div__list__int, pythonic::dispatch::div__list__float, pythonic::dispatch::div__list__string, pythonic::dispatch::div__list__bool, pythonic::dispatch::div__list__double, pythonic::dispatch::div__list__long, pythonic::dispatch::div__list__long_long, pythonic::dispatch::div__list__long_double, pythonic::dispatch::div__list__uint, pythonic::dispatch::div__list__ulong, pythonic::dispatch::div__list__ulong_long, pythonic::dispatch::div__list__list, pythonic::dispatch::div__list__set, pythonic::dispatch::div__list__dict, pythonic::dispatch::div__list__orderedset, pythonic::dispatch::div__list__ordereddict, pythonic::dispatch::div__list__graph};
    t[13] = {pythonic::dispatch::div__set__none, pythonic::dispatch::div__set__int, pythonic::dispatch::div__set__float, pythonic::dispatch::div__set__string, pythonic::dispatch::div__set__bool, pythonic::dispatch::div__set__double, pythonic::dispatch::div__set__long, pythonic::dispatch::div__set__long_long, pythonic::dispatch::div__set__long_double, pythonic::dispatch::div__set__uint, pythonic::dispatch::div__set__ulong, pythonic::dispatch::div__set__ulong_long, pythonic::dispatch::div__set__list, pythonic::dispatch::div__set__set, pythonic::dispatch::div__set__dict, pythonic::dispatch::div__set__orderedset, pythonic::dispatch::div__set__ordereddict, pythonic::dispatch::div__set__graph};
    t[14] = {pythonic::dispatch::div__dict__none, pythonic::dispatch::div__dict__int, pythonic::dispatch::div__dict__float, pythonic::dispatch::div__dict__string, pythonic::dispatch::div__dict__bool, pythonic::dispatch::div__dict__double, pythonic::dispatch::div__dict__long, pythonic::dispatch::div__dict__long_long, pythonic::dispatch::div__dict__long_double, pythonic::dispatch::div__dict__uint, pythonic::dispatch::div__dict__ulong, pythonic::dispatch::div__dict__ulong_long, pythonic::dispatch::div__dict__list, pythonic::dispatch::div__dict__set, pythonic::dispatch::div__dict__dict, pythonic::dispatch::div__dict__orderedset, pythonic::dispatch::div__dict__ordereddict, pythonic::dispatch::div__dict__graph};
    t[15] = {pythonic::dispatch::div__orderedset__none, pythonic::dispatch::div__orderedset__int, pythonic::dispatch::div__orderedset__float, pythonic::dispatch::div__orderedset__string, pythonic::dispatch::div__orderedset__bool, pythonic::dispatch::div__orderedset__double, pythonic::dispatch::div__orderedset__long, pythonic::dispatch::div__orderedset__long_long, pythonic::dispatch::div__orderedset__long_double, pythonic::dispatch::div__orderedset__uint, pythonic::dispatch::div__orderedset__ulong, pythonic::dispatch::div__orderedset__ulong_long, pythonic::dispatch::div__orderedset__list, pythonic::dispatch::div__orderedset__set, pythonic::dispatch::div__orderedset__dict, pythonic::dispatch::div__orderedset__orderedset, pythonic::dispatch::div__orderedset__ordereddict, pythonic::dispatch::div__orderedset__graph};
    t[16] = {pythonic::dispatch::div__ordereddict__none, pythonic::dispatch::div__ordereddict__int, pythonic::dispatch::div__ordereddict__float, pythonic::dispatch::div__ordereddict__string, pythonic::dispatch::div__ordereddict__bool, pythonic::dispatch::div__ordereddict__double, pythonic::dispatch::div__ordereddict__long, pythonic::dispatch::div__ordereddict__long_long, pythonic::dispatch::div__ordereddict__long_double, pythonic::dispatch::div__ordereddict__uint, pythonic::dispatch::div__ordereddict__ulong, pythonic::dispatch::div__ordereddict__ulong_long, pythonic::dispatch::div__ordereddict__list, pythonic::dispatch::div__ordereddict__set, pythonic::dispatch::div__ordereddict__dict, pythonic::dispatch::div__ordereddict__orderedset, pythonic::dispatch::div__ordereddict__ordereddict, pythonic::dispatch::div__ordereddict__graph};
    t[17] = {pythonic::dispatch::div__graph__none, pythonic::dispatch::div__graph__int, pythonic::dispatch::div__graph__float, pythonic::dispatch::div__graph__string, pythonic::dispatch::div__graph__bool, pythonic::dispatch::div__graph__double, pythonic::dispatch::div__graph__long, pythonic::dispatch::div__graph__long_long, pythonic::dispatch::div__graph__long_double, pythonic::dispatch::div__graph__uint, pythonic::dispatch::div__graph__ulong, pythonic::dispatch::div__graph__ulong_long, pythonic::dispatch::div__graph__list, pythonic::dispatch::div__graph__set, pythonic::dispatch::div__graph__dict, pythonic::dispatch::div__graph__orderedset, pythonic::dispatch::div__graph__ordereddict, pythonic::dispatch::div__graph__graph};
    return t;
}();

// OpTable initialization for Mod
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Mod>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::mod__none__none, pythonic::dispatch::mod__none__int, pythonic::dispatch::mod__none__float, pythonic::dispatch::mod__none__string, pythonic::dispatch::mod__none__bool, pythonic::dispatch::mod__none__double, pythonic::dispatch::mod__none__long, pythonic::dispatch::mod__none__long_long, pythonic::dispatch::mod__none__long_double, pythonic::dispatch::mod__none__uint, pythonic::dispatch::mod__none__ulong, pythonic::dispatch::mod__none__ulong_long, pythonic::dispatch::mod__none__list, pythonic::dispatch::mod__none__set, pythonic::dispatch::mod__none__dict, pythonic::dispatch::mod__none__orderedset, pythonic::dispatch::mod__none__ordereddict, pythonic::dispatch::mod__none__graph};
    t[1] = {pythonic::dispatch::mod__int__none, pythonic::dispatch::mod__int__int, pythonic::dispatch::mod__int__float, pythonic::dispatch::mod__int__string, pythonic::dispatch::mod__int__bool, pythonic::dispatch::mod__int__double, pythonic::dispatch::mod__int__long, pythonic::dispatch::mod__int__long_long, pythonic::dispatch::mod__int__long_double, pythonic::dispatch::mod__int__uint, pythonic::dispatch::mod__int__ulong, pythonic::dispatch::mod__int__ulong_long, pythonic::dispatch::mod__int__list, pythonic::dispatch::mod__int__set, pythonic::dispatch::mod__int__dict, pythonic::dispatch::mod__int__orderedset, pythonic::dispatch::mod__int__ordereddict, pythonic::dispatch::mod__int__graph};
    t[2] = {pythonic::dispatch::mod__float__none, pythonic::dispatch::mod__float__int, pythonic::dispatch::mod__float__float, pythonic::dispatch::mod__float__string, pythonic::dispatch::mod__float__bool, pythonic::dispatch::mod__float__double, pythonic::dispatch::mod__float__long, pythonic::dispatch::mod__float__long_long, pythonic::dispatch::mod__float__long_double, pythonic::dispatch::mod__float__uint, pythonic::dispatch::mod__float__ulong, pythonic::dispatch::mod__float__ulong_long, pythonic::dispatch::mod__float__list, pythonic::dispatch::mod__float__set, pythonic::dispatch::mod__float__dict, pythonic::dispatch::mod__float__orderedset, pythonic::dispatch::mod__float__ordereddict, pythonic::dispatch::mod__float__graph};
    t[3] = {pythonic::dispatch::mod__string__none, pythonic::dispatch::mod__string__int, pythonic::dispatch::mod__string__float, pythonic::dispatch::mod__string__string, pythonic::dispatch::mod__string__bool, pythonic::dispatch::mod__string__double, pythonic::dispatch::mod__string__long, pythonic::dispatch::mod__string__long_long, pythonic::dispatch::mod__string__long_double, pythonic::dispatch::mod__string__uint, pythonic::dispatch::mod__string__ulong, pythonic::dispatch::mod__string__ulong_long, pythonic::dispatch::mod__string__list, pythonic::dispatch::mod__string__set, pythonic::dispatch::mod__string__dict, pythonic::dispatch::mod__string__orderedset, pythonic::dispatch::mod__string__ordereddict, pythonic::dispatch::mod__string__graph};
    t[4] = {pythonic::dispatch::mod__bool__none, pythonic::dispatch::mod__bool__int, pythonic::dispatch::mod__bool__float, pythonic::dispatch::mod__bool__string, pythonic::dispatch::mod__bool__bool, pythonic::dispatch::mod__bool__double, pythonic::dispatch::mod__bool__long, pythonic::dispatch::mod__bool__long_long, pythonic::dispatch::mod__bool__long_double, pythonic::dispatch::mod__bool__uint, pythonic::dispatch::mod__bool__ulong, pythonic::dispatch::mod__bool__ulong_long, pythonic::dispatch::mod__bool__list, pythonic::dispatch::mod__bool__set, pythonic::dispatch::mod__bool__dict, pythonic::dispatch::mod__bool__orderedset, pythonic::dispatch::mod__bool__ordereddict, pythonic::dispatch::mod__bool__graph};
    t[5] = {pythonic::dispatch::mod__double__none, pythonic::dispatch::mod__double__int, pythonic::dispatch::mod__double__float, pythonic::dispatch::mod__double__string, pythonic::dispatch::mod__double__bool, pythonic::dispatch::mod__double__double, pythonic::dispatch::mod__double__long, pythonic::dispatch::mod__double__long_long, pythonic::dispatch::mod__double__long_double, pythonic::dispatch::mod__double__uint, pythonic::dispatch::mod__double__ulong, pythonic::dispatch::mod__double__ulong_long, pythonic::dispatch::mod__double__list, pythonic::dispatch::mod__double__set, pythonic::dispatch::mod__double__dict, pythonic::dispatch::mod__double__orderedset, pythonic::dispatch::mod__double__ordereddict, pythonic::dispatch::mod__double__graph};
    t[6] = {pythonic::dispatch::mod__long__none, pythonic::dispatch::mod__long__int, pythonic::dispatch::mod__long__float, pythonic::dispatch::mod__long__string, pythonic::dispatch::mod__long__bool, pythonic::dispatch::mod__long__double, pythonic::dispatch::mod__long__long, pythonic::dispatch::mod__long__long_long, pythonic::dispatch::mod__long__long_double, pythonic::dispatch::mod__long__uint, pythonic::dispatch::mod__long__ulong, pythonic::dispatch::mod__long__ulong_long, pythonic::dispatch::mod__long__list, pythonic::dispatch::mod__long__set, pythonic::dispatch::mod__long__dict, pythonic::dispatch::mod__long__orderedset, pythonic::dispatch::mod__long__ordereddict, pythonic::dispatch::mod__long__graph};
    t[7] = {pythonic::dispatch::mod__long_long__none, pythonic::dispatch::mod__long_long__int, pythonic::dispatch::mod__long_long__float, pythonic::dispatch::mod__long_long__string, pythonic::dispatch::mod__long_long__bool, pythonic::dispatch::mod__long_long__double, pythonic::dispatch::mod__long_long__long, pythonic::dispatch::mod__long_long__long_long, pythonic::dispatch::mod__long_long__long_double, pythonic::dispatch::mod__long_long__uint, pythonic::dispatch::mod__long_long__ulong, pythonic::dispatch::mod__long_long__ulong_long, pythonic::dispatch::mod__long_long__list, pythonic::dispatch::mod__long_long__set, pythonic::dispatch::mod__long_long__dict, pythonic::dispatch::mod__long_long__orderedset, pythonic::dispatch::mod__long_long__ordereddict, pythonic::dispatch::mod__long_long__graph};
    t[8] = {pythonic::dispatch::mod__long_double__none, pythonic::dispatch::mod__long_double__int, pythonic::dispatch::mod__long_double__float, pythonic::dispatch::mod__long_double__string, pythonic::dispatch::mod__long_double__bool, pythonic::dispatch::mod__long_double__double, pythonic::dispatch::mod__long_double__long, pythonic::dispatch::mod__long_double__long_long, pythonic::dispatch::mod__long_double__long_double, pythonic::dispatch::mod__long_double__uint, pythonic::dispatch::mod__long_double__ulong, pythonic::dispatch::mod__long_double__ulong_long, pythonic::dispatch::mod__long_double__list, pythonic::dispatch::mod__long_double__set, pythonic::dispatch::mod__long_double__dict, pythonic::dispatch::mod__long_double__orderedset, pythonic::dispatch::mod__long_double__ordereddict, pythonic::dispatch::mod__long_double__graph};
    t[9] = {pythonic::dispatch::mod__uint__none, pythonic::dispatch::mod__uint__int, pythonic::dispatch::mod__uint__float, pythonic::dispatch::mod__uint__string, pythonic::dispatch::mod__uint__bool, pythonic::dispatch::mod__uint__double, pythonic::dispatch::mod__uint__long, pythonic::dispatch::mod__uint__long_long, pythonic::dispatch::mod__uint__long_double, pythonic::dispatch::mod__uint__uint, pythonic::dispatch::mod__uint__ulong, pythonic::dispatch::mod__uint__ulong_long, pythonic::dispatch::mod__uint__list, pythonic::dispatch::mod__uint__set, pythonic::dispatch::mod__uint__dict, pythonic::dispatch::mod__uint__orderedset, pythonic::dispatch::mod__uint__ordereddict, pythonic::dispatch::mod__uint__graph};
    t[10] = {pythonic::dispatch::mod__ulong__none, pythonic::dispatch::mod__ulong__int, pythonic::dispatch::mod__ulong__float, pythonic::dispatch::mod__ulong__string, pythonic::dispatch::mod__ulong__bool, pythonic::dispatch::mod__ulong__double, pythonic::dispatch::mod__ulong__long, pythonic::dispatch::mod__ulong__long_long, pythonic::dispatch::mod__ulong__long_double, pythonic::dispatch::mod__ulong__uint, pythonic::dispatch::mod__ulong__ulong, pythonic::dispatch::mod__ulong__ulong_long, pythonic::dispatch::mod__ulong__list, pythonic::dispatch::mod__ulong__set, pythonic::dispatch::mod__ulong__dict, pythonic::dispatch::mod__ulong__orderedset, pythonic::dispatch::mod__ulong__ordereddict, pythonic::dispatch::mod__ulong__graph};
    t[11] = {pythonic::dispatch::mod__ulong_long__none, pythonic::dispatch::mod__ulong_long__int, pythonic::dispatch::mod__ulong_long__float, pythonic::dispatch::mod__ulong_long__string, pythonic::dispatch::mod__ulong_long__bool, pythonic::dispatch::mod__ulong_long__double, pythonic::dispatch::mod__ulong_long__long, pythonic::dispatch::mod__ulong_long__long_long, pythonic::dispatch::mod__ulong_long__long_double, pythonic::dispatch::mod__ulong_long__uint, pythonic::dispatch::mod__ulong_long__ulong, pythonic::dispatch::mod__ulong_long__ulong_long, pythonic::dispatch::mod__ulong_long__list, pythonic::dispatch::mod__ulong_long__set, pythonic::dispatch::mod__ulong_long__dict, pythonic::dispatch::mod__ulong_long__orderedset, pythonic::dispatch::mod__ulong_long__ordereddict, pythonic::dispatch::mod__ulong_long__graph};
    t[12] = {pythonic::dispatch::mod__list__none, pythonic::dispatch::mod__list__int, pythonic::dispatch::mod__list__float, pythonic::dispatch::mod__list__string, pythonic::dispatch::mod__list__bool, pythonic::dispatch::mod__list__double, pythonic::dispatch::mod__list__long, pythonic::dispatch::mod__list__long_long, pythonic::dispatch::mod__list__long_double, pythonic::dispatch::mod__list__uint, pythonic::dispatch::mod__list__ulong, pythonic::dispatch::mod__list__ulong_long, pythonic::dispatch::mod__list__list, pythonic::dispatch::mod__list__set, pythonic::dispatch::mod__list__dict, pythonic::dispatch::mod__list__orderedset, pythonic::dispatch::mod__list__ordereddict, pythonic::dispatch::mod__list__graph};
    t[13] = {pythonic::dispatch::mod__set__none, pythonic::dispatch::mod__set__int, pythonic::dispatch::mod__set__float, pythonic::dispatch::mod__set__string, pythonic::dispatch::mod__set__bool, pythonic::dispatch::mod__set__double, pythonic::dispatch::mod__set__long, pythonic::dispatch::mod__set__long_long, pythonic::dispatch::mod__set__long_double, pythonic::dispatch::mod__set__uint, pythonic::dispatch::mod__set__ulong, pythonic::dispatch::mod__set__ulong_long, pythonic::dispatch::mod__set__list, pythonic::dispatch::mod__set__set, pythonic::dispatch::mod__set__dict, pythonic::dispatch::mod__set__orderedset, pythonic::dispatch::mod__set__ordereddict, pythonic::dispatch::mod__set__graph};
    t[14] = {pythonic::dispatch::mod__dict__none, pythonic::dispatch::mod__dict__int, pythonic::dispatch::mod__dict__float, pythonic::dispatch::mod__dict__string, pythonic::dispatch::mod__dict__bool, pythonic::dispatch::mod__dict__double, pythonic::dispatch::mod__dict__long, pythonic::dispatch::mod__dict__long_long, pythonic::dispatch::mod__dict__long_double, pythonic::dispatch::mod__dict__uint, pythonic::dispatch::mod__dict__ulong, pythonic::dispatch::mod__dict__ulong_long, pythonic::dispatch::mod__dict__list, pythonic::dispatch::mod__dict__set, pythonic::dispatch::mod__dict__dict, pythonic::dispatch::mod__dict__orderedset, pythonic::dispatch::mod__dict__ordereddict, pythonic::dispatch::mod__dict__graph};
    t[15] = {pythonic::dispatch::mod__orderedset__none, pythonic::dispatch::mod__orderedset__int, pythonic::dispatch::mod__orderedset__float, pythonic::dispatch::mod__orderedset__string, pythonic::dispatch::mod__orderedset__bool, pythonic::dispatch::mod__orderedset__double, pythonic::dispatch::mod__orderedset__long, pythonic::dispatch::mod__orderedset__long_long, pythonic::dispatch::mod__orderedset__long_double, pythonic::dispatch::mod__orderedset__uint, pythonic::dispatch::mod__orderedset__ulong, pythonic::dispatch::mod__orderedset__ulong_long, pythonic::dispatch::mod__orderedset__list, pythonic::dispatch::mod__orderedset__set, pythonic::dispatch::mod__orderedset__dict, pythonic::dispatch::mod__orderedset__orderedset, pythonic::dispatch::mod__orderedset__ordereddict, pythonic::dispatch::mod__orderedset__graph};
    t[16] = {pythonic::dispatch::mod__ordereddict__none, pythonic::dispatch::mod__ordereddict__int, pythonic::dispatch::mod__ordereddict__float, pythonic::dispatch::mod__ordereddict__string, pythonic::dispatch::mod__ordereddict__bool, pythonic::dispatch::mod__ordereddict__double, pythonic::dispatch::mod__ordereddict__long, pythonic::dispatch::mod__ordereddict__long_long, pythonic::dispatch::mod__ordereddict__long_double, pythonic::dispatch::mod__ordereddict__uint, pythonic::dispatch::mod__ordereddict__ulong, pythonic::dispatch::mod__ordereddict__ulong_long, pythonic::dispatch::mod__ordereddict__list, pythonic::dispatch::mod__ordereddict__set, pythonic::dispatch::mod__ordereddict__dict, pythonic::dispatch::mod__ordereddict__orderedset, pythonic::dispatch::mod__ordereddict__ordereddict, pythonic::dispatch::mod__ordereddict__graph};
    t[17] = {pythonic::dispatch::mod__graph__none, pythonic::dispatch::mod__graph__int, pythonic::dispatch::mod__graph__float, pythonic::dispatch::mod__graph__string, pythonic::dispatch::mod__graph__bool, pythonic::dispatch::mod__graph__double, pythonic::dispatch::mod__graph__long, pythonic::dispatch::mod__graph__long_long, pythonic::dispatch::mod__graph__long_double, pythonic::dispatch::mod__graph__uint, pythonic::dispatch::mod__graph__ulong, pythonic::dispatch::mod__graph__ulong_long, pythonic::dispatch::mod__graph__list, pythonic::dispatch::mod__graph__set, pythonic::dispatch::mod__graph__dict, pythonic::dispatch::mod__graph__orderedset, pythonic::dispatch::mod__graph__ordereddict, pythonic::dispatch::mod__graph__graph};
    return t;
}();

// OpTable initialization for Eq
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Eq>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::eq__none__none, pythonic::dispatch::eq__none__int, pythonic::dispatch::eq__none__float, pythonic::dispatch::eq__none__string, pythonic::dispatch::eq__none__bool, pythonic::dispatch::eq__none__double, pythonic::dispatch::eq__none__long, pythonic::dispatch::eq__none__long_long, pythonic::dispatch::eq__none__long_double, pythonic::dispatch::eq__none__uint, pythonic::dispatch::eq__none__ulong, pythonic::dispatch::eq__none__ulong_long, pythonic::dispatch::eq__none__list, pythonic::dispatch::eq__none__set, pythonic::dispatch::eq__none__dict, pythonic::dispatch::eq__none__orderedset, pythonic::dispatch::eq__none__ordereddict, pythonic::dispatch::eq__none__graph};
    t[1] = {pythonic::dispatch::eq__int__none, pythonic::dispatch::eq__int__int, pythonic::dispatch::eq__int__float, pythonic::dispatch::eq__int__string, pythonic::dispatch::eq__int__bool, pythonic::dispatch::eq__int__double, pythonic::dispatch::eq__int__long, pythonic::dispatch::eq__int__long_long, pythonic::dispatch::eq__int__long_double, pythonic::dispatch::eq__int__uint, pythonic::dispatch::eq__int__ulong, pythonic::dispatch::eq__int__ulong_long, pythonic::dispatch::eq__int__list, pythonic::dispatch::eq__int__set, pythonic::dispatch::eq__int__dict, pythonic::dispatch::eq__int__orderedset, pythonic::dispatch::eq__int__ordereddict, pythonic::dispatch::eq__int__graph};
    t[2] = {pythonic::dispatch::eq__float__none, pythonic::dispatch::eq__float__int, pythonic::dispatch::eq__float__float, pythonic::dispatch::eq__float__string, pythonic::dispatch::eq__float__bool, pythonic::dispatch::eq__float__double, pythonic::dispatch::eq__float__long, pythonic::dispatch::eq__float__long_long, pythonic::dispatch::eq__float__long_double, pythonic::dispatch::eq__float__uint, pythonic::dispatch::eq__float__ulong, pythonic::dispatch::eq__float__ulong_long, pythonic::dispatch::eq__float__list, pythonic::dispatch::eq__float__set, pythonic::dispatch::eq__float__dict, pythonic::dispatch::eq__float__orderedset, pythonic::dispatch::eq__float__ordereddict, pythonic::dispatch::eq__float__graph};
    t[3] = {pythonic::dispatch::eq__string__none, pythonic::dispatch::eq__string__int, pythonic::dispatch::eq__string__float, pythonic::dispatch::eq__string__string, pythonic::dispatch::eq__string__bool, pythonic::dispatch::eq__string__double, pythonic::dispatch::eq__string__long, pythonic::dispatch::eq__string__long_long, pythonic::dispatch::eq__string__long_double, pythonic::dispatch::eq__string__uint, pythonic::dispatch::eq__string__ulong, pythonic::dispatch::eq__string__ulong_long, pythonic::dispatch::eq__string__list, pythonic::dispatch::eq__string__set, pythonic::dispatch::eq__string__dict, pythonic::dispatch::eq__string__orderedset, pythonic::dispatch::eq__string__ordereddict, pythonic::dispatch::eq__string__graph};
    t[4] = {pythonic::dispatch::eq__bool__none, pythonic::dispatch::eq__bool__int, pythonic::dispatch::eq__bool__float, pythonic::dispatch::eq__bool__string, pythonic::dispatch::eq__bool__bool, pythonic::dispatch::eq__bool__double, pythonic::dispatch::eq__bool__long, pythonic::dispatch::eq__bool__long_long, pythonic::dispatch::eq__bool__long_double, pythonic::dispatch::eq__bool__uint, pythonic::dispatch::eq__bool__ulong, pythonic::dispatch::eq__bool__ulong_long, pythonic::dispatch::eq__bool__list, pythonic::dispatch::eq__bool__set, pythonic::dispatch::eq__bool__dict, pythonic::dispatch::eq__bool__orderedset, pythonic::dispatch::eq__bool__ordereddict, pythonic::dispatch::eq__bool__graph};
    t[5] = {pythonic::dispatch::eq__double__none, pythonic::dispatch::eq__double__int, pythonic::dispatch::eq__double__float, pythonic::dispatch::eq__double__string, pythonic::dispatch::eq__double__bool, pythonic::dispatch::eq__double__double, pythonic::dispatch::eq__double__long, pythonic::dispatch::eq__double__long_long, pythonic::dispatch::eq__double__long_double, pythonic::dispatch::eq__double__uint, pythonic::dispatch::eq__double__ulong, pythonic::dispatch::eq__double__ulong_long, pythonic::dispatch::eq__double__list, pythonic::dispatch::eq__double__set, pythonic::dispatch::eq__double__dict, pythonic::dispatch::eq__double__orderedset, pythonic::dispatch::eq__double__ordereddict, pythonic::dispatch::eq__double__graph};
    t[6] = {pythonic::dispatch::eq__long__none, pythonic::dispatch::eq__long__int, pythonic::dispatch::eq__long__float, pythonic::dispatch::eq__long__string, pythonic::dispatch::eq__long__bool, pythonic::dispatch::eq__long__double, pythonic::dispatch::eq__long__long, pythonic::dispatch::eq__long__long_long, pythonic::dispatch::eq__long__long_double, pythonic::dispatch::eq__long__uint, pythonic::dispatch::eq__long__ulong, pythonic::dispatch::eq__long__ulong_long, pythonic::dispatch::eq__long__list, pythonic::dispatch::eq__long__set, pythonic::dispatch::eq__long__dict, pythonic::dispatch::eq__long__orderedset, pythonic::dispatch::eq__long__ordereddict, pythonic::dispatch::eq__long__graph};
    t[7] = {pythonic::dispatch::eq__long_long__none, pythonic::dispatch::eq__long_long__int, pythonic::dispatch::eq__long_long__float, pythonic::dispatch::eq__long_long__string, pythonic::dispatch::eq__long_long__bool, pythonic::dispatch::eq__long_long__double, pythonic::dispatch::eq__long_long__long, pythonic::dispatch::eq__long_long__long_long, pythonic::dispatch::eq__long_long__long_double, pythonic::dispatch::eq__long_long__uint, pythonic::dispatch::eq__long_long__ulong, pythonic::dispatch::eq__long_long__ulong_long, pythonic::dispatch::eq__long_long__list, pythonic::dispatch::eq__long_long__set, pythonic::dispatch::eq__long_long__dict, pythonic::dispatch::eq__long_long__orderedset, pythonic::dispatch::eq__long_long__ordereddict, pythonic::dispatch::eq__long_long__graph};
    t[8] = {pythonic::dispatch::eq__long_double__none, pythonic::dispatch::eq__long_double__int, pythonic::dispatch::eq__long_double__float, pythonic::dispatch::eq__long_double__string, pythonic::dispatch::eq__long_double__bool, pythonic::dispatch::eq__long_double__double, pythonic::dispatch::eq__long_double__long, pythonic::dispatch::eq__long_double__long_long, pythonic::dispatch::eq__long_double__long_double, pythonic::dispatch::eq__long_double__uint, pythonic::dispatch::eq__long_double__ulong, pythonic::dispatch::eq__long_double__ulong_long, pythonic::dispatch::eq__long_double__list, pythonic::dispatch::eq__long_double__set, pythonic::dispatch::eq__long_double__dict, pythonic::dispatch::eq__long_double__orderedset, pythonic::dispatch::eq__long_double__ordereddict, pythonic::dispatch::eq__long_double__graph};
    t[9] = {pythonic::dispatch::eq__uint__none, pythonic::dispatch::eq__uint__int, pythonic::dispatch::eq__uint__float, pythonic::dispatch::eq__uint__string, pythonic::dispatch::eq__uint__bool, pythonic::dispatch::eq__uint__double, pythonic::dispatch::eq__uint__long, pythonic::dispatch::eq__uint__long_long, pythonic::dispatch::eq__uint__long_double, pythonic::dispatch::eq__uint__uint, pythonic::dispatch::eq__uint__ulong, pythonic::dispatch::eq__uint__ulong_long, pythonic::dispatch::eq__uint__list, pythonic::dispatch::eq__uint__set, pythonic::dispatch::eq__uint__dict, pythonic::dispatch::eq__uint__orderedset, pythonic::dispatch::eq__uint__ordereddict, pythonic::dispatch::eq__uint__graph};
    t[10] = {pythonic::dispatch::eq__ulong__none, pythonic::dispatch::eq__ulong__int, pythonic::dispatch::eq__ulong__float, pythonic::dispatch::eq__ulong__string, pythonic::dispatch::eq__ulong__bool, pythonic::dispatch::eq__ulong__double, pythonic::dispatch::eq__ulong__long, pythonic::dispatch::eq__ulong__long_long, pythonic::dispatch::eq__ulong__long_double, pythonic::dispatch::eq__ulong__uint, pythonic::dispatch::eq__ulong__ulong, pythonic::dispatch::eq__ulong__ulong_long, pythonic::dispatch::eq__ulong__list, pythonic::dispatch::eq__ulong__set, pythonic::dispatch::eq__ulong__dict, pythonic::dispatch::eq__ulong__orderedset, pythonic::dispatch::eq__ulong__ordereddict, pythonic::dispatch::eq__ulong__graph};
    t[11] = {pythonic::dispatch::eq__ulong_long__none, pythonic::dispatch::eq__ulong_long__int, pythonic::dispatch::eq__ulong_long__float, pythonic::dispatch::eq__ulong_long__string, pythonic::dispatch::eq__ulong_long__bool, pythonic::dispatch::eq__ulong_long__double, pythonic::dispatch::eq__ulong_long__long, pythonic::dispatch::eq__ulong_long__long_long, pythonic::dispatch::eq__ulong_long__long_double, pythonic::dispatch::eq__ulong_long__uint, pythonic::dispatch::eq__ulong_long__ulong, pythonic::dispatch::eq__ulong_long__ulong_long, pythonic::dispatch::eq__ulong_long__list, pythonic::dispatch::eq__ulong_long__set, pythonic::dispatch::eq__ulong_long__dict, pythonic::dispatch::eq__ulong_long__orderedset, pythonic::dispatch::eq__ulong_long__ordereddict, pythonic::dispatch::eq__ulong_long__graph};
    t[12] = {pythonic::dispatch::eq__list__none, pythonic::dispatch::eq__list__int, pythonic::dispatch::eq__list__float, pythonic::dispatch::eq__list__string, pythonic::dispatch::eq__list__bool, pythonic::dispatch::eq__list__double, pythonic::dispatch::eq__list__long, pythonic::dispatch::eq__list__long_long, pythonic::dispatch::eq__list__long_double, pythonic::dispatch::eq__list__uint, pythonic::dispatch::eq__list__ulong, pythonic::dispatch::eq__list__ulong_long, pythonic::dispatch::eq__list__list, pythonic::dispatch::eq__list__set, pythonic::dispatch::eq__list__dict, pythonic::dispatch::eq__list__orderedset, pythonic::dispatch::eq__list__ordereddict, pythonic::dispatch::eq__list__graph};
    t[13] = {pythonic::dispatch::eq__set__none, pythonic::dispatch::eq__set__int, pythonic::dispatch::eq__set__float, pythonic::dispatch::eq__set__string, pythonic::dispatch::eq__set__bool, pythonic::dispatch::eq__set__double, pythonic::dispatch::eq__set__long, pythonic::dispatch::eq__set__long_long, pythonic::dispatch::eq__set__long_double, pythonic::dispatch::eq__set__uint, pythonic::dispatch::eq__set__ulong, pythonic::dispatch::eq__set__ulong_long, pythonic::dispatch::eq__set__list, pythonic::dispatch::eq__set__set, pythonic::dispatch::eq__set__dict, pythonic::dispatch::eq__set__orderedset, pythonic::dispatch::eq__set__ordereddict, pythonic::dispatch::eq__set__graph};
    t[14] = {pythonic::dispatch::eq__dict__none, pythonic::dispatch::eq__dict__int, pythonic::dispatch::eq__dict__float, pythonic::dispatch::eq__dict__string, pythonic::dispatch::eq__dict__bool, pythonic::dispatch::eq__dict__double, pythonic::dispatch::eq__dict__long, pythonic::dispatch::eq__dict__long_long, pythonic::dispatch::eq__dict__long_double, pythonic::dispatch::eq__dict__uint, pythonic::dispatch::eq__dict__ulong, pythonic::dispatch::eq__dict__ulong_long, pythonic::dispatch::eq__dict__list, pythonic::dispatch::eq__dict__set, pythonic::dispatch::eq__dict__dict, pythonic::dispatch::eq__dict__orderedset, pythonic::dispatch::eq__dict__ordereddict, pythonic::dispatch::eq__dict__graph};
    t[15] = {pythonic::dispatch::eq__orderedset__none, pythonic::dispatch::eq__orderedset__int, pythonic::dispatch::eq__orderedset__float, pythonic::dispatch::eq__orderedset__string, pythonic::dispatch::eq__orderedset__bool, pythonic::dispatch::eq__orderedset__double, pythonic::dispatch::eq__orderedset__long, pythonic::dispatch::eq__orderedset__long_long, pythonic::dispatch::eq__orderedset__long_double, pythonic::dispatch::eq__orderedset__uint, pythonic::dispatch::eq__orderedset__ulong, pythonic::dispatch::eq__orderedset__ulong_long, pythonic::dispatch::eq__orderedset__list, pythonic::dispatch::eq__orderedset__set, pythonic::dispatch::eq__orderedset__dict, pythonic::dispatch::eq__orderedset__orderedset, pythonic::dispatch::eq__orderedset__ordereddict, pythonic::dispatch::eq__orderedset__graph};
    t[16] = {pythonic::dispatch::eq__ordereddict__none, pythonic::dispatch::eq__ordereddict__int, pythonic::dispatch::eq__ordereddict__float, pythonic::dispatch::eq__ordereddict__string, pythonic::dispatch::eq__ordereddict__bool, pythonic::dispatch::eq__ordereddict__double, pythonic::dispatch::eq__ordereddict__long, pythonic::dispatch::eq__ordereddict__long_long, pythonic::dispatch::eq__ordereddict__long_double, pythonic::dispatch::eq__ordereddict__uint, pythonic::dispatch::eq__ordereddict__ulong, pythonic::dispatch::eq__ordereddict__ulong_long, pythonic::dispatch::eq__ordereddict__list, pythonic::dispatch::eq__ordereddict__set, pythonic::dispatch::eq__ordereddict__dict, pythonic::dispatch::eq__ordereddict__orderedset, pythonic::dispatch::eq__ordereddict__ordereddict, pythonic::dispatch::eq__ordereddict__graph};
    t[17] = {pythonic::dispatch::eq__graph__none, pythonic::dispatch::eq__graph__int, pythonic::dispatch::eq__graph__float, pythonic::dispatch::eq__graph__string, pythonic::dispatch::eq__graph__bool, pythonic::dispatch::eq__graph__double, pythonic::dispatch::eq__graph__long, pythonic::dispatch::eq__graph__long_long, pythonic::dispatch::eq__graph__long_double, pythonic::dispatch::eq__graph__uint, pythonic::dispatch::eq__graph__ulong, pythonic::dispatch::eq__graph__ulong_long, pythonic::dispatch::eq__graph__list, pythonic::dispatch::eq__graph__set, pythonic::dispatch::eq__graph__dict, pythonic::dispatch::eq__graph__orderedset, pythonic::dispatch::eq__graph__ordereddict, pythonic::dispatch::eq__graph__graph};
    return t;
}();

// OpTable initialization for Ne
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Ne>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::ne__none__none, pythonic::dispatch::ne__none__int, pythonic::dispatch::ne__none__float, pythonic::dispatch::ne__none__string, pythonic::dispatch::ne__none__bool, pythonic::dispatch::ne__none__double, pythonic::dispatch::ne__none__long, pythonic::dispatch::ne__none__long_long, pythonic::dispatch::ne__none__long_double, pythonic::dispatch::ne__none__uint, pythonic::dispatch::ne__none__ulong, pythonic::dispatch::ne__none__ulong_long, pythonic::dispatch::ne__none__list, pythonic::dispatch::ne__none__set, pythonic::dispatch::ne__none__dict, pythonic::dispatch::ne__none__orderedset, pythonic::dispatch::ne__none__ordereddict, pythonic::dispatch::ne__none__graph};
    t[1] = {pythonic::dispatch::ne__int__none, pythonic::dispatch::ne__int__int, pythonic::dispatch::ne__int__float, pythonic::dispatch::ne__int__string, pythonic::dispatch::ne__int__bool, pythonic::dispatch::ne__int__double, pythonic::dispatch::ne__int__long, pythonic::dispatch::ne__int__long_long, pythonic::dispatch::ne__int__long_double, pythonic::dispatch::ne__int__uint, pythonic::dispatch::ne__int__ulong, pythonic::dispatch::ne__int__ulong_long, pythonic::dispatch::ne__int__list, pythonic::dispatch::ne__int__set, pythonic::dispatch::ne__int__dict, pythonic::dispatch::ne__int__orderedset, pythonic::dispatch::ne__int__ordereddict, pythonic::dispatch::ne__int__graph};
    t[2] = {pythonic::dispatch::ne__float__none, pythonic::dispatch::ne__float__int, pythonic::dispatch::ne__float__float, pythonic::dispatch::ne__float__string, pythonic::dispatch::ne__float__bool, pythonic::dispatch::ne__float__double, pythonic::dispatch::ne__float__long, pythonic::dispatch::ne__float__long_long, pythonic::dispatch::ne__float__long_double, pythonic::dispatch::ne__float__uint, pythonic::dispatch::ne__float__ulong, pythonic::dispatch::ne__float__ulong_long, pythonic::dispatch::ne__float__list, pythonic::dispatch::ne__float__set, pythonic::dispatch::ne__float__dict, pythonic::dispatch::ne__float__orderedset, pythonic::dispatch::ne__float__ordereddict, pythonic::dispatch::ne__float__graph};
    t[3] = {pythonic::dispatch::ne__string__none, pythonic::dispatch::ne__string__int, pythonic::dispatch::ne__string__float, pythonic::dispatch::ne__string__string, pythonic::dispatch::ne__string__bool, pythonic::dispatch::ne__string__double, pythonic::dispatch::ne__string__long, pythonic::dispatch::ne__string__long_long, pythonic::dispatch::ne__string__long_double, pythonic::dispatch::ne__string__uint, pythonic::dispatch::ne__string__ulong, pythonic::dispatch::ne__string__ulong_long, pythonic::dispatch::ne__string__list, pythonic::dispatch::ne__string__set, pythonic::dispatch::ne__string__dict, pythonic::dispatch::ne__string__orderedset, pythonic::dispatch::ne__string__ordereddict, pythonic::dispatch::ne__string__graph};
    t[4] = {pythonic::dispatch::ne__bool__none, pythonic::dispatch::ne__bool__int, pythonic::dispatch::ne__bool__float, pythonic::dispatch::ne__bool__string, pythonic::dispatch::ne__bool__bool, pythonic::dispatch::ne__bool__double, pythonic::dispatch::ne__bool__long, pythonic::dispatch::ne__bool__long_long, pythonic::dispatch::ne__bool__long_double, pythonic::dispatch::ne__bool__uint, pythonic::dispatch::ne__bool__ulong, pythonic::dispatch::ne__bool__ulong_long, pythonic::dispatch::ne__bool__list, pythonic::dispatch::ne__bool__set, pythonic::dispatch::ne__bool__dict, pythonic::dispatch::ne__bool__orderedset, pythonic::dispatch::ne__bool__ordereddict, pythonic::dispatch::ne__bool__graph};
    t[5] = {pythonic::dispatch::ne__double__none, pythonic::dispatch::ne__double__int, pythonic::dispatch::ne__double__float, pythonic::dispatch::ne__double__string, pythonic::dispatch::ne__double__bool, pythonic::dispatch::ne__double__double, pythonic::dispatch::ne__double__long, pythonic::dispatch::ne__double__long_long, pythonic::dispatch::ne__double__long_double, pythonic::dispatch::ne__double__uint, pythonic::dispatch::ne__double__ulong, pythonic::dispatch::ne__double__ulong_long, pythonic::dispatch::ne__double__list, pythonic::dispatch::ne__double__set, pythonic::dispatch::ne__double__dict, pythonic::dispatch::ne__double__orderedset, pythonic::dispatch::ne__double__ordereddict, pythonic::dispatch::ne__double__graph};
    t[6] = {pythonic::dispatch::ne__long__none, pythonic::dispatch::ne__long__int, pythonic::dispatch::ne__long__float, pythonic::dispatch::ne__long__string, pythonic::dispatch::ne__long__bool, pythonic::dispatch::ne__long__double, pythonic::dispatch::ne__long__long, pythonic::dispatch::ne__long__long_long, pythonic::dispatch::ne__long__long_double, pythonic::dispatch::ne__long__uint, pythonic::dispatch::ne__long__ulong, pythonic::dispatch::ne__long__ulong_long, pythonic::dispatch::ne__long__list, pythonic::dispatch::ne__long__set, pythonic::dispatch::ne__long__dict, pythonic::dispatch::ne__long__orderedset, pythonic::dispatch::ne__long__ordereddict, pythonic::dispatch::ne__long__graph};
    t[7] = {pythonic::dispatch::ne__long_long__none, pythonic::dispatch::ne__long_long__int, pythonic::dispatch::ne__long_long__float, pythonic::dispatch::ne__long_long__string, pythonic::dispatch::ne__long_long__bool, pythonic::dispatch::ne__long_long__double, pythonic::dispatch::ne__long_long__long, pythonic::dispatch::ne__long_long__long_long, pythonic::dispatch::ne__long_long__long_double, pythonic::dispatch::ne__long_long__uint, pythonic::dispatch::ne__long_long__ulong, pythonic::dispatch::ne__long_long__ulong_long, pythonic::dispatch::ne__long_long__list, pythonic::dispatch::ne__long_long__set, pythonic::dispatch::ne__long_long__dict, pythonic::dispatch::ne__long_long__orderedset, pythonic::dispatch::ne__long_long__ordereddict, pythonic::dispatch::ne__long_long__graph};
    t[8] = {pythonic::dispatch::ne__long_double__none, pythonic::dispatch::ne__long_double__int, pythonic::dispatch::ne__long_double__float, pythonic::dispatch::ne__long_double__string, pythonic::dispatch::ne__long_double__bool, pythonic::dispatch::ne__long_double__double, pythonic::dispatch::ne__long_double__long, pythonic::dispatch::ne__long_double__long_long, pythonic::dispatch::ne__long_double__long_double, pythonic::dispatch::ne__long_double__uint, pythonic::dispatch::ne__long_double__ulong, pythonic::dispatch::ne__long_double__ulong_long, pythonic::dispatch::ne__long_double__list, pythonic::dispatch::ne__long_double__set, pythonic::dispatch::ne__long_double__dict, pythonic::dispatch::ne__long_double__orderedset, pythonic::dispatch::ne__long_double__ordereddict, pythonic::dispatch::ne__long_double__graph};
    t[9] = {pythonic::dispatch::ne__uint__none, pythonic::dispatch::ne__uint__int, pythonic::dispatch::ne__uint__float, pythonic::dispatch::ne__uint__string, pythonic::dispatch::ne__uint__bool, pythonic::dispatch::ne__uint__double, pythonic::dispatch::ne__uint__long, pythonic::dispatch::ne__uint__long_long, pythonic::dispatch::ne__uint__long_double, pythonic::dispatch::ne__uint__uint, pythonic::dispatch::ne__uint__ulong, pythonic::dispatch::ne__uint__ulong_long, pythonic::dispatch::ne__uint__list, pythonic::dispatch::ne__uint__set, pythonic::dispatch::ne__uint__dict, pythonic::dispatch::ne__uint__orderedset, pythonic::dispatch::ne__uint__ordereddict, pythonic::dispatch::ne__uint__graph};
    t[10] = {pythonic::dispatch::ne__ulong__none, pythonic::dispatch::ne__ulong__int, pythonic::dispatch::ne__ulong__float, pythonic::dispatch::ne__ulong__string, pythonic::dispatch::ne__ulong__bool, pythonic::dispatch::ne__ulong__double, pythonic::dispatch::ne__ulong__long, pythonic::dispatch::ne__ulong__long_long, pythonic::dispatch::ne__ulong__long_double, pythonic::dispatch::ne__ulong__uint, pythonic::dispatch::ne__ulong__ulong, pythonic::dispatch::ne__ulong__ulong_long, pythonic::dispatch::ne__ulong__list, pythonic::dispatch::ne__ulong__set, pythonic::dispatch::ne__ulong__dict, pythonic::dispatch::ne__ulong__orderedset, pythonic::dispatch::ne__ulong__ordereddict, pythonic::dispatch::ne__ulong__graph};
    t[11] = {pythonic::dispatch::ne__ulong_long__none, pythonic::dispatch::ne__ulong_long__int, pythonic::dispatch::ne__ulong_long__float, pythonic::dispatch::ne__ulong_long__string, pythonic::dispatch::ne__ulong_long__bool, pythonic::dispatch::ne__ulong_long__double, pythonic::dispatch::ne__ulong_long__long, pythonic::dispatch::ne__ulong_long__long_long, pythonic::dispatch::ne__ulong_long__long_double, pythonic::dispatch::ne__ulong_long__uint, pythonic::dispatch::ne__ulong_long__ulong, pythonic::dispatch::ne__ulong_long__ulong_long, pythonic::dispatch::ne__ulong_long__list, pythonic::dispatch::ne__ulong_long__set, pythonic::dispatch::ne__ulong_long__dict, pythonic::dispatch::ne__ulong_long__orderedset, pythonic::dispatch::ne__ulong_long__ordereddict, pythonic::dispatch::ne__ulong_long__graph};
    t[12] = {pythonic::dispatch::ne__list__none, pythonic::dispatch::ne__list__int, pythonic::dispatch::ne__list__float, pythonic::dispatch::ne__list__string, pythonic::dispatch::ne__list__bool, pythonic::dispatch::ne__list__double, pythonic::dispatch::ne__list__long, pythonic::dispatch::ne__list__long_long, pythonic::dispatch::ne__list__long_double, pythonic::dispatch::ne__list__uint, pythonic::dispatch::ne__list__ulong, pythonic::dispatch::ne__list__ulong_long, pythonic::dispatch::ne__list__list, pythonic::dispatch::ne__list__set, pythonic::dispatch::ne__list__dict, pythonic::dispatch::ne__list__orderedset, pythonic::dispatch::ne__list__ordereddict, pythonic::dispatch::ne__list__graph};
    t[13] = {pythonic::dispatch::ne__set__none, pythonic::dispatch::ne__set__int, pythonic::dispatch::ne__set__float, pythonic::dispatch::ne__set__string, pythonic::dispatch::ne__set__bool, pythonic::dispatch::ne__set__double, pythonic::dispatch::ne__set__long, pythonic::dispatch::ne__set__long_long, pythonic::dispatch::ne__set__long_double, pythonic::dispatch::ne__set__uint, pythonic::dispatch::ne__set__ulong, pythonic::dispatch::ne__set__ulong_long, pythonic::dispatch::ne__set__list, pythonic::dispatch::ne__set__set, pythonic::dispatch::ne__set__dict, pythonic::dispatch::ne__set__orderedset, pythonic::dispatch::ne__set__ordereddict, pythonic::dispatch::ne__set__graph};
    t[14] = {pythonic::dispatch::ne__dict__none, pythonic::dispatch::ne__dict__int, pythonic::dispatch::ne__dict__float, pythonic::dispatch::ne__dict__string, pythonic::dispatch::ne__dict__bool, pythonic::dispatch::ne__dict__double, pythonic::dispatch::ne__dict__long, pythonic::dispatch::ne__dict__long_long, pythonic::dispatch::ne__dict__long_double, pythonic::dispatch::ne__dict__uint, pythonic::dispatch::ne__dict__ulong, pythonic::dispatch::ne__dict__ulong_long, pythonic::dispatch::ne__dict__list, pythonic::dispatch::ne__dict__set, pythonic::dispatch::ne__dict__dict, pythonic::dispatch::ne__dict__orderedset, pythonic::dispatch::ne__dict__ordereddict, pythonic::dispatch::ne__dict__graph};
    t[15] = {pythonic::dispatch::ne__orderedset__none, pythonic::dispatch::ne__orderedset__int, pythonic::dispatch::ne__orderedset__float, pythonic::dispatch::ne__orderedset__string, pythonic::dispatch::ne__orderedset__bool, pythonic::dispatch::ne__orderedset__double, pythonic::dispatch::ne__orderedset__long, pythonic::dispatch::ne__orderedset__long_long, pythonic::dispatch::ne__orderedset__long_double, pythonic::dispatch::ne__orderedset__uint, pythonic::dispatch::ne__orderedset__ulong, pythonic::dispatch::ne__orderedset__ulong_long, pythonic::dispatch::ne__orderedset__list, pythonic::dispatch::ne__orderedset__set, pythonic::dispatch::ne__orderedset__dict, pythonic::dispatch::ne__orderedset__orderedset, pythonic::dispatch::ne__orderedset__ordereddict, pythonic::dispatch::ne__orderedset__graph};
    t[16] = {pythonic::dispatch::ne__ordereddict__none, pythonic::dispatch::ne__ordereddict__int, pythonic::dispatch::ne__ordereddict__float, pythonic::dispatch::ne__ordereddict__string, pythonic::dispatch::ne__ordereddict__bool, pythonic::dispatch::ne__ordereddict__double, pythonic::dispatch::ne__ordereddict__long, pythonic::dispatch::ne__ordereddict__long_long, pythonic::dispatch::ne__ordereddict__long_double, pythonic::dispatch::ne__ordereddict__uint, pythonic::dispatch::ne__ordereddict__ulong, pythonic::dispatch::ne__ordereddict__ulong_long, pythonic::dispatch::ne__ordereddict__list, pythonic::dispatch::ne__ordereddict__set, pythonic::dispatch::ne__ordereddict__dict, pythonic::dispatch::ne__ordereddict__orderedset, pythonic::dispatch::ne__ordereddict__ordereddict, pythonic::dispatch::ne__ordereddict__graph};
    t[17] = {pythonic::dispatch::ne__graph__none, pythonic::dispatch::ne__graph__int, pythonic::dispatch::ne__graph__float, pythonic::dispatch::ne__graph__string, pythonic::dispatch::ne__graph__bool, pythonic::dispatch::ne__graph__double, pythonic::dispatch::ne__graph__long, pythonic::dispatch::ne__graph__long_long, pythonic::dispatch::ne__graph__long_double, pythonic::dispatch::ne__graph__uint, pythonic::dispatch::ne__graph__ulong, pythonic::dispatch::ne__graph__ulong_long, pythonic::dispatch::ne__graph__list, pythonic::dispatch::ne__graph__set, pythonic::dispatch::ne__graph__dict, pythonic::dispatch::ne__graph__orderedset, pythonic::dispatch::ne__graph__ordereddict, pythonic::dispatch::ne__graph__graph};
    return t;
}();

// OpTable initialization for Gt
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Gt>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::gt__none__none, pythonic::dispatch::gt__none__int, pythonic::dispatch::gt__none__float, pythonic::dispatch::gt__none__string, pythonic::dispatch::gt__none__bool, pythonic::dispatch::gt__none__double, pythonic::dispatch::gt__none__long, pythonic::dispatch::gt__none__long_long, pythonic::dispatch::gt__none__long_double, pythonic::dispatch::gt__none__uint, pythonic::dispatch::gt__none__ulong, pythonic::dispatch::gt__none__ulong_long, pythonic::dispatch::gt__none__list, pythonic::dispatch::gt__none__set, pythonic::dispatch::gt__none__dict, pythonic::dispatch::gt__none__orderedset, pythonic::dispatch::gt__none__ordereddict, pythonic::dispatch::gt__none__graph};
    t[1] = {pythonic::dispatch::gt__int__none, pythonic::dispatch::gt__int__int, pythonic::dispatch::gt__int__float, pythonic::dispatch::gt__int__string, pythonic::dispatch::gt__int__bool, pythonic::dispatch::gt__int__double, pythonic::dispatch::gt__int__long, pythonic::dispatch::gt__int__long_long, pythonic::dispatch::gt__int__long_double, pythonic::dispatch::gt__int__uint, pythonic::dispatch::gt__int__ulong, pythonic::dispatch::gt__int__ulong_long, pythonic::dispatch::gt__int__list, pythonic::dispatch::gt__int__set, pythonic::dispatch::gt__int__dict, pythonic::dispatch::gt__int__orderedset, pythonic::dispatch::gt__int__ordereddict, pythonic::dispatch::gt__int__graph};
    t[2] = {pythonic::dispatch::gt__float__none, pythonic::dispatch::gt__float__int, pythonic::dispatch::gt__float__float, pythonic::dispatch::gt__float__string, pythonic::dispatch::gt__float__bool, pythonic::dispatch::gt__float__double, pythonic::dispatch::gt__float__long, pythonic::dispatch::gt__float__long_long, pythonic::dispatch::gt__float__long_double, pythonic::dispatch::gt__float__uint, pythonic::dispatch::gt__float__ulong, pythonic::dispatch::gt__float__ulong_long, pythonic::dispatch::gt__float__list, pythonic::dispatch::gt__float__set, pythonic::dispatch::gt__float__dict, pythonic::dispatch::gt__float__orderedset, pythonic::dispatch::gt__float__ordereddict, pythonic::dispatch::gt__float__graph};
    t[3] = {pythonic::dispatch::gt__string__none, pythonic::dispatch::gt__string__int, pythonic::dispatch::gt__string__float, pythonic::dispatch::gt__string__string, pythonic::dispatch::gt__string__bool, pythonic::dispatch::gt__string__double, pythonic::dispatch::gt__string__long, pythonic::dispatch::gt__string__long_long, pythonic::dispatch::gt__string__long_double, pythonic::dispatch::gt__string__uint, pythonic::dispatch::gt__string__ulong, pythonic::dispatch::gt__string__ulong_long, pythonic::dispatch::gt__string__list, pythonic::dispatch::gt__string__set, pythonic::dispatch::gt__string__dict, pythonic::dispatch::gt__string__orderedset, pythonic::dispatch::gt__string__ordereddict, pythonic::dispatch::gt__string__graph};
    t[4] = {pythonic::dispatch::gt__bool__none, pythonic::dispatch::gt__bool__int, pythonic::dispatch::gt__bool__float, pythonic::dispatch::gt__bool__string, pythonic::dispatch::gt__bool__bool, pythonic::dispatch::gt__bool__double, pythonic::dispatch::gt__bool__long, pythonic::dispatch::gt__bool__long_long, pythonic::dispatch::gt__bool__long_double, pythonic::dispatch::gt__bool__uint, pythonic::dispatch::gt__bool__ulong, pythonic::dispatch::gt__bool__ulong_long, pythonic::dispatch::gt__bool__list, pythonic::dispatch::gt__bool__set, pythonic::dispatch::gt__bool__dict, pythonic::dispatch::gt__bool__orderedset, pythonic::dispatch::gt__bool__ordereddict, pythonic::dispatch::gt__bool__graph};
    t[5] = {pythonic::dispatch::gt__double__none, pythonic::dispatch::gt__double__int, pythonic::dispatch::gt__double__float, pythonic::dispatch::gt__double__string, pythonic::dispatch::gt__double__bool, pythonic::dispatch::gt__double__double, pythonic::dispatch::gt__double__long, pythonic::dispatch::gt__double__long_long, pythonic::dispatch::gt__double__long_double, pythonic::dispatch::gt__double__uint, pythonic::dispatch::gt__double__ulong, pythonic::dispatch::gt__double__ulong_long, pythonic::dispatch::gt__double__list, pythonic::dispatch::gt__double__set, pythonic::dispatch::gt__double__dict, pythonic::dispatch::gt__double__orderedset, pythonic::dispatch::gt__double__ordereddict, pythonic::dispatch::gt__double__graph};
    t[6] = {pythonic::dispatch::gt__long__none, pythonic::dispatch::gt__long__int, pythonic::dispatch::gt__long__float, pythonic::dispatch::gt__long__string, pythonic::dispatch::gt__long__bool, pythonic::dispatch::gt__long__double, pythonic::dispatch::gt__long__long, pythonic::dispatch::gt__long__long_long, pythonic::dispatch::gt__long__long_double, pythonic::dispatch::gt__long__uint, pythonic::dispatch::gt__long__ulong, pythonic::dispatch::gt__long__ulong_long, pythonic::dispatch::gt__long__list, pythonic::dispatch::gt__long__set, pythonic::dispatch::gt__long__dict, pythonic::dispatch::gt__long__orderedset, pythonic::dispatch::gt__long__ordereddict, pythonic::dispatch::gt__long__graph};
    t[7] = {pythonic::dispatch::gt__long_long__none, pythonic::dispatch::gt__long_long__int, pythonic::dispatch::gt__long_long__float, pythonic::dispatch::gt__long_long__string, pythonic::dispatch::gt__long_long__bool, pythonic::dispatch::gt__long_long__double, pythonic::dispatch::gt__long_long__long, pythonic::dispatch::gt__long_long__long_long, pythonic::dispatch::gt__long_long__long_double, pythonic::dispatch::gt__long_long__uint, pythonic::dispatch::gt__long_long__ulong, pythonic::dispatch::gt__long_long__ulong_long, pythonic::dispatch::gt__long_long__list, pythonic::dispatch::gt__long_long__set, pythonic::dispatch::gt__long_long__dict, pythonic::dispatch::gt__long_long__orderedset, pythonic::dispatch::gt__long_long__ordereddict, pythonic::dispatch::gt__long_long__graph};
    t[8] = {pythonic::dispatch::gt__long_double__none, pythonic::dispatch::gt__long_double__int, pythonic::dispatch::gt__long_double__float, pythonic::dispatch::gt__long_double__string, pythonic::dispatch::gt__long_double__bool, pythonic::dispatch::gt__long_double__double, pythonic::dispatch::gt__long_double__long, pythonic::dispatch::gt__long_double__long_long, pythonic::dispatch::gt__long_double__long_double, pythonic::dispatch::gt__long_double__uint, pythonic::dispatch::gt__long_double__ulong, pythonic::dispatch::gt__long_double__ulong_long, pythonic::dispatch::gt__long_double__list, pythonic::dispatch::gt__long_double__set, pythonic::dispatch::gt__long_double__dict, pythonic::dispatch::gt__long_double__orderedset, pythonic::dispatch::gt__long_double__ordereddict, pythonic::dispatch::gt__long_double__graph};
    t[9] = {pythonic::dispatch::gt__uint__none, pythonic::dispatch::gt__uint__int, pythonic::dispatch::gt__uint__float, pythonic::dispatch::gt__uint__string, pythonic::dispatch::gt__uint__bool, pythonic::dispatch::gt__uint__double, pythonic::dispatch::gt__uint__long, pythonic::dispatch::gt__uint__long_long, pythonic::dispatch::gt__uint__long_double, pythonic::dispatch::gt__uint__uint, pythonic::dispatch::gt__uint__ulong, pythonic::dispatch::gt__uint__ulong_long, pythonic::dispatch::gt__uint__list, pythonic::dispatch::gt__uint__set, pythonic::dispatch::gt__uint__dict, pythonic::dispatch::gt__uint__orderedset, pythonic::dispatch::gt__uint__ordereddict, pythonic::dispatch::gt__uint__graph};
    t[10] = {pythonic::dispatch::gt__ulong__none, pythonic::dispatch::gt__ulong__int, pythonic::dispatch::gt__ulong__float, pythonic::dispatch::gt__ulong__string, pythonic::dispatch::gt__ulong__bool, pythonic::dispatch::gt__ulong__double, pythonic::dispatch::gt__ulong__long, pythonic::dispatch::gt__ulong__long_long, pythonic::dispatch::gt__ulong__long_double, pythonic::dispatch::gt__ulong__uint, pythonic::dispatch::gt__ulong__ulong, pythonic::dispatch::gt__ulong__ulong_long, pythonic::dispatch::gt__ulong__list, pythonic::dispatch::gt__ulong__set, pythonic::dispatch::gt__ulong__dict, pythonic::dispatch::gt__ulong__orderedset, pythonic::dispatch::gt__ulong__ordereddict, pythonic::dispatch::gt__ulong__graph};
    t[11] = {pythonic::dispatch::gt__ulong_long__none, pythonic::dispatch::gt__ulong_long__int, pythonic::dispatch::gt__ulong_long__float, pythonic::dispatch::gt__ulong_long__string, pythonic::dispatch::gt__ulong_long__bool, pythonic::dispatch::gt__ulong_long__double, pythonic::dispatch::gt__ulong_long__long, pythonic::dispatch::gt__ulong_long__long_long, pythonic::dispatch::gt__ulong_long__long_double, pythonic::dispatch::gt__ulong_long__uint, pythonic::dispatch::gt__ulong_long__ulong, pythonic::dispatch::gt__ulong_long__ulong_long, pythonic::dispatch::gt__ulong_long__list, pythonic::dispatch::gt__ulong_long__set, pythonic::dispatch::gt__ulong_long__dict, pythonic::dispatch::gt__ulong_long__orderedset, pythonic::dispatch::gt__ulong_long__ordereddict, pythonic::dispatch::gt__ulong_long__graph};
    t[12] = {pythonic::dispatch::gt__list__none, pythonic::dispatch::gt__list__int, pythonic::dispatch::gt__list__float, pythonic::dispatch::gt__list__string, pythonic::dispatch::gt__list__bool, pythonic::dispatch::gt__list__double, pythonic::dispatch::gt__list__long, pythonic::dispatch::gt__list__long_long, pythonic::dispatch::gt__list__long_double, pythonic::dispatch::gt__list__uint, pythonic::dispatch::gt__list__ulong, pythonic::dispatch::gt__list__ulong_long, pythonic::dispatch::gt__list__list, pythonic::dispatch::gt__list__set, pythonic::dispatch::gt__list__dict, pythonic::dispatch::gt__list__orderedset, pythonic::dispatch::gt__list__ordereddict, pythonic::dispatch::gt__list__graph};
    t[13] = {pythonic::dispatch::gt__set__none, pythonic::dispatch::gt__set__int, pythonic::dispatch::gt__set__float, pythonic::dispatch::gt__set__string, pythonic::dispatch::gt__set__bool, pythonic::dispatch::gt__set__double, pythonic::dispatch::gt__set__long, pythonic::dispatch::gt__set__long_long, pythonic::dispatch::gt__set__long_double, pythonic::dispatch::gt__set__uint, pythonic::dispatch::gt__set__ulong, pythonic::dispatch::gt__set__ulong_long, pythonic::dispatch::gt__set__list, pythonic::dispatch::gt__set__set, pythonic::dispatch::gt__set__dict, pythonic::dispatch::gt__set__orderedset, pythonic::dispatch::gt__set__ordereddict, pythonic::dispatch::gt__set__graph};
    t[14] = {pythonic::dispatch::gt__dict__none, pythonic::dispatch::gt__dict__int, pythonic::dispatch::gt__dict__float, pythonic::dispatch::gt__dict__string, pythonic::dispatch::gt__dict__bool, pythonic::dispatch::gt__dict__double, pythonic::dispatch::gt__dict__long, pythonic::dispatch::gt__dict__long_long, pythonic::dispatch::gt__dict__long_double, pythonic::dispatch::gt__dict__uint, pythonic::dispatch::gt__dict__ulong, pythonic::dispatch::gt__dict__ulong_long, pythonic::dispatch::gt__dict__list, pythonic::dispatch::gt__dict__set, pythonic::dispatch::gt__dict__dict, pythonic::dispatch::gt__dict__orderedset, pythonic::dispatch::gt__dict__ordereddict, pythonic::dispatch::gt__dict__graph};
    t[15] = {pythonic::dispatch::gt__orderedset__none, pythonic::dispatch::gt__orderedset__int, pythonic::dispatch::gt__orderedset__float, pythonic::dispatch::gt__orderedset__string, pythonic::dispatch::gt__orderedset__bool, pythonic::dispatch::gt__orderedset__double, pythonic::dispatch::gt__orderedset__long, pythonic::dispatch::gt__orderedset__long_long, pythonic::dispatch::gt__orderedset__long_double, pythonic::dispatch::gt__orderedset__uint, pythonic::dispatch::gt__orderedset__ulong, pythonic::dispatch::gt__orderedset__ulong_long, pythonic::dispatch::gt__orderedset__list, pythonic::dispatch::gt__orderedset__set, pythonic::dispatch::gt__orderedset__dict, pythonic::dispatch::gt__orderedset__orderedset, pythonic::dispatch::gt__orderedset__ordereddict, pythonic::dispatch::gt__orderedset__graph};
    t[16] = {pythonic::dispatch::gt__ordereddict__none, pythonic::dispatch::gt__ordereddict__int, pythonic::dispatch::gt__ordereddict__float, pythonic::dispatch::gt__ordereddict__string, pythonic::dispatch::gt__ordereddict__bool, pythonic::dispatch::gt__ordereddict__double, pythonic::dispatch::gt__ordereddict__long, pythonic::dispatch::gt__ordereddict__long_long, pythonic::dispatch::gt__ordereddict__long_double, pythonic::dispatch::gt__ordereddict__uint, pythonic::dispatch::gt__ordereddict__ulong, pythonic::dispatch::gt__ordereddict__ulong_long, pythonic::dispatch::gt__ordereddict__list, pythonic::dispatch::gt__ordereddict__set, pythonic::dispatch::gt__ordereddict__dict, pythonic::dispatch::gt__ordereddict__orderedset, pythonic::dispatch::gt__ordereddict__ordereddict, pythonic::dispatch::gt__ordereddict__graph};
    t[17] = {pythonic::dispatch::gt__graph__none, pythonic::dispatch::gt__graph__int, pythonic::dispatch::gt__graph__float, pythonic::dispatch::gt__graph__string, pythonic::dispatch::gt__graph__bool, pythonic::dispatch::gt__graph__double, pythonic::dispatch::gt__graph__long, pythonic::dispatch::gt__graph__long_long, pythonic::dispatch::gt__graph__long_double, pythonic::dispatch::gt__graph__uint, pythonic::dispatch::gt__graph__ulong, pythonic::dispatch::gt__graph__ulong_long, pythonic::dispatch::gt__graph__list, pythonic::dispatch::gt__graph__set, pythonic::dispatch::gt__graph__dict, pythonic::dispatch::gt__graph__orderedset, pythonic::dispatch::gt__graph__ordereddict, pythonic::dispatch::gt__graph__graph};
    return t;
}();

// OpTable initialization for Ge
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Ge>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::ge__none__none, pythonic::dispatch::ge__none__int, pythonic::dispatch::ge__none__float, pythonic::dispatch::ge__none__string, pythonic::dispatch::ge__none__bool, pythonic::dispatch::ge__none__double, pythonic::dispatch::ge__none__long, pythonic::dispatch::ge__none__long_long, pythonic::dispatch::ge__none__long_double, pythonic::dispatch::ge__none__uint, pythonic::dispatch::ge__none__ulong, pythonic::dispatch::ge__none__ulong_long, pythonic::dispatch::ge__none__list, pythonic::dispatch::ge__none__set, pythonic::dispatch::ge__none__dict, pythonic::dispatch::ge__none__orderedset, pythonic::dispatch::ge__none__ordereddict, pythonic::dispatch::ge__none__graph};
    t[1] = {pythonic::dispatch::ge__int__none, pythonic::dispatch::ge__int__int, pythonic::dispatch::ge__int__float, pythonic::dispatch::ge__int__string, pythonic::dispatch::ge__int__bool, pythonic::dispatch::ge__int__double, pythonic::dispatch::ge__int__long, pythonic::dispatch::ge__int__long_long, pythonic::dispatch::ge__int__long_double, pythonic::dispatch::ge__int__uint, pythonic::dispatch::ge__int__ulong, pythonic::dispatch::ge__int__ulong_long, pythonic::dispatch::ge__int__list, pythonic::dispatch::ge__int__set, pythonic::dispatch::ge__int__dict, pythonic::dispatch::ge__int__orderedset, pythonic::dispatch::ge__int__ordereddict, pythonic::dispatch::ge__int__graph};
    t[2] = {pythonic::dispatch::ge__float__none, pythonic::dispatch::ge__float__int, pythonic::dispatch::ge__float__float, pythonic::dispatch::ge__float__string, pythonic::dispatch::ge__float__bool, pythonic::dispatch::ge__float__double, pythonic::dispatch::ge__float__long, pythonic::dispatch::ge__float__long_long, pythonic::dispatch::ge__float__long_double, pythonic::dispatch::ge__float__uint, pythonic::dispatch::ge__float__ulong, pythonic::dispatch::ge__float__ulong_long, pythonic::dispatch::ge__float__list, pythonic::dispatch::ge__float__set, pythonic::dispatch::ge__float__dict, pythonic::dispatch::ge__float__orderedset, pythonic::dispatch::ge__float__ordereddict, pythonic::dispatch::ge__float__graph};
    t[3] = {pythonic::dispatch::ge__string__none, pythonic::dispatch::ge__string__int, pythonic::dispatch::ge__string__float, pythonic::dispatch::ge__string__string, pythonic::dispatch::ge__string__bool, pythonic::dispatch::ge__string__double, pythonic::dispatch::ge__string__long, pythonic::dispatch::ge__string__long_long, pythonic::dispatch::ge__string__long_double, pythonic::dispatch::ge__string__uint, pythonic::dispatch::ge__string__ulong, pythonic::dispatch::ge__string__ulong_long, pythonic::dispatch::ge__string__list, pythonic::dispatch::ge__string__set, pythonic::dispatch::ge__string__dict, pythonic::dispatch::ge__string__orderedset, pythonic::dispatch::ge__string__ordereddict, pythonic::dispatch::ge__string__graph};
    t[4] = {pythonic::dispatch::ge__bool__none, pythonic::dispatch::ge__bool__int, pythonic::dispatch::ge__bool__float, pythonic::dispatch::ge__bool__string, pythonic::dispatch::ge__bool__bool, pythonic::dispatch::ge__bool__double, pythonic::dispatch::ge__bool__long, pythonic::dispatch::ge__bool__long_long, pythonic::dispatch::ge__bool__long_double, pythonic::dispatch::ge__bool__uint, pythonic::dispatch::ge__bool__ulong, pythonic::dispatch::ge__bool__ulong_long, pythonic::dispatch::ge__bool__list, pythonic::dispatch::ge__bool__set, pythonic::dispatch::ge__bool__dict, pythonic::dispatch::ge__bool__orderedset, pythonic::dispatch::ge__bool__ordereddict, pythonic::dispatch::ge__bool__graph};
    t[5] = {pythonic::dispatch::ge__double__none, pythonic::dispatch::ge__double__int, pythonic::dispatch::ge__double__float, pythonic::dispatch::ge__double__string, pythonic::dispatch::ge__double__bool, pythonic::dispatch::ge__double__double, pythonic::dispatch::ge__double__long, pythonic::dispatch::ge__double__long_long, pythonic::dispatch::ge__double__long_double, pythonic::dispatch::ge__double__uint, pythonic::dispatch::ge__double__ulong, pythonic::dispatch::ge__double__ulong_long, pythonic::dispatch::ge__double__list, pythonic::dispatch::ge__double__set, pythonic::dispatch::ge__double__dict, pythonic::dispatch::ge__double__orderedset, pythonic::dispatch::ge__double__ordereddict, pythonic::dispatch::ge__double__graph};
    t[6] = {pythonic::dispatch::ge__long__none, pythonic::dispatch::ge__long__int, pythonic::dispatch::ge__long__float, pythonic::dispatch::ge__long__string, pythonic::dispatch::ge__long__bool, pythonic::dispatch::ge__long__double, pythonic::dispatch::ge__long__long, pythonic::dispatch::ge__long__long_long, pythonic::dispatch::ge__long__long_double, pythonic::dispatch::ge__long__uint, pythonic::dispatch::ge__long__ulong, pythonic::dispatch::ge__long__ulong_long, pythonic::dispatch::ge__long__list, pythonic::dispatch::ge__long__set, pythonic::dispatch::ge__long__dict, pythonic::dispatch::ge__long__orderedset, pythonic::dispatch::ge__long__ordereddict, pythonic::dispatch::ge__long__graph};
    t[7] = {pythonic::dispatch::ge__long_long__none, pythonic::dispatch::ge__long_long__int, pythonic::dispatch::ge__long_long__float, pythonic::dispatch::ge__long_long__string, pythonic::dispatch::ge__long_long__bool, pythonic::dispatch::ge__long_long__double, pythonic::dispatch::ge__long_long__long, pythonic::dispatch::ge__long_long__long_long, pythonic::dispatch::ge__long_long__long_double, pythonic::dispatch::ge__long_long__uint, pythonic::dispatch::ge__long_long__ulong, pythonic::dispatch::ge__long_long__ulong_long, pythonic::dispatch::ge__long_long__list, pythonic::dispatch::ge__long_long__set, pythonic::dispatch::ge__long_long__dict, pythonic::dispatch::ge__long_long__orderedset, pythonic::dispatch::ge__long_long__ordereddict, pythonic::dispatch::ge__long_long__graph};
    t[8] = {pythonic::dispatch::ge__long_double__none, pythonic::dispatch::ge__long_double__int, pythonic::dispatch::ge__long_double__float, pythonic::dispatch::ge__long_double__string, pythonic::dispatch::ge__long_double__bool, pythonic::dispatch::ge__long_double__double, pythonic::dispatch::ge__long_double__long, pythonic::dispatch::ge__long_double__long_long, pythonic::dispatch::ge__long_double__long_double, pythonic::dispatch::ge__long_double__uint, pythonic::dispatch::ge__long_double__ulong, pythonic::dispatch::ge__long_double__ulong_long, pythonic::dispatch::ge__long_double__list, pythonic::dispatch::ge__long_double__set, pythonic::dispatch::ge__long_double__dict, pythonic::dispatch::ge__long_double__orderedset, pythonic::dispatch::ge__long_double__ordereddict, pythonic::dispatch::ge__long_double__graph};
    t[9] = {pythonic::dispatch::ge__uint__none, pythonic::dispatch::ge__uint__int, pythonic::dispatch::ge__uint__float, pythonic::dispatch::ge__uint__string, pythonic::dispatch::ge__uint__bool, pythonic::dispatch::ge__uint__double, pythonic::dispatch::ge__uint__long, pythonic::dispatch::ge__uint__long_long, pythonic::dispatch::ge__uint__long_double, pythonic::dispatch::ge__uint__uint, pythonic::dispatch::ge__uint__ulong, pythonic::dispatch::ge__uint__ulong_long, pythonic::dispatch::ge__uint__list, pythonic::dispatch::ge__uint__set, pythonic::dispatch::ge__uint__dict, pythonic::dispatch::ge__uint__orderedset, pythonic::dispatch::ge__uint__ordereddict, pythonic::dispatch::ge__uint__graph};
    t[10] = {pythonic::dispatch::ge__ulong__none, pythonic::dispatch::ge__ulong__int, pythonic::dispatch::ge__ulong__float, pythonic::dispatch::ge__ulong__string, pythonic::dispatch::ge__ulong__bool, pythonic::dispatch::ge__ulong__double, pythonic::dispatch::ge__ulong__long, pythonic::dispatch::ge__ulong__long_long, pythonic::dispatch::ge__ulong__long_double, pythonic::dispatch::ge__ulong__uint, pythonic::dispatch::ge__ulong__ulong, pythonic::dispatch::ge__ulong__ulong_long, pythonic::dispatch::ge__ulong__list, pythonic::dispatch::ge__ulong__set, pythonic::dispatch::ge__ulong__dict, pythonic::dispatch::ge__ulong__orderedset, pythonic::dispatch::ge__ulong__ordereddict, pythonic::dispatch::ge__ulong__graph};
    t[11] = {pythonic::dispatch::ge__ulong_long__none, pythonic::dispatch::ge__ulong_long__int, pythonic::dispatch::ge__ulong_long__float, pythonic::dispatch::ge__ulong_long__string, pythonic::dispatch::ge__ulong_long__bool, pythonic::dispatch::ge__ulong_long__double, pythonic::dispatch::ge__ulong_long__long, pythonic::dispatch::ge__ulong_long__long_long, pythonic::dispatch::ge__ulong_long__long_double, pythonic::dispatch::ge__ulong_long__uint, pythonic::dispatch::ge__ulong_long__ulong, pythonic::dispatch::ge__ulong_long__ulong_long, pythonic::dispatch::ge__ulong_long__list, pythonic::dispatch::ge__ulong_long__set, pythonic::dispatch::ge__ulong_long__dict, pythonic::dispatch::ge__ulong_long__orderedset, pythonic::dispatch::ge__ulong_long__ordereddict, pythonic::dispatch::ge__ulong_long__graph};
    t[12] = {pythonic::dispatch::ge__list__none, pythonic::dispatch::ge__list__int, pythonic::dispatch::ge__list__float, pythonic::dispatch::ge__list__string, pythonic::dispatch::ge__list__bool, pythonic::dispatch::ge__list__double, pythonic::dispatch::ge__list__long, pythonic::dispatch::ge__list__long_long, pythonic::dispatch::ge__list__long_double, pythonic::dispatch::ge__list__uint, pythonic::dispatch::ge__list__ulong, pythonic::dispatch::ge__list__ulong_long, pythonic::dispatch::ge__list__list, pythonic::dispatch::ge__list__set, pythonic::dispatch::ge__list__dict, pythonic::dispatch::ge__list__orderedset, pythonic::dispatch::ge__list__ordereddict, pythonic::dispatch::ge__list__graph};
    t[13] = {pythonic::dispatch::ge__set__none, pythonic::dispatch::ge__set__int, pythonic::dispatch::ge__set__float, pythonic::dispatch::ge__set__string, pythonic::dispatch::ge__set__bool, pythonic::dispatch::ge__set__double, pythonic::dispatch::ge__set__long, pythonic::dispatch::ge__set__long_long, pythonic::dispatch::ge__set__long_double, pythonic::dispatch::ge__set__uint, pythonic::dispatch::ge__set__ulong, pythonic::dispatch::ge__set__ulong_long, pythonic::dispatch::ge__set__list, pythonic::dispatch::ge__set__set, pythonic::dispatch::ge__set__dict, pythonic::dispatch::ge__set__orderedset, pythonic::dispatch::ge__set__ordereddict, pythonic::dispatch::ge__set__graph};
    t[14] = {pythonic::dispatch::ge__dict__none, pythonic::dispatch::ge__dict__int, pythonic::dispatch::ge__dict__float, pythonic::dispatch::ge__dict__string, pythonic::dispatch::ge__dict__bool, pythonic::dispatch::ge__dict__double, pythonic::dispatch::ge__dict__long, pythonic::dispatch::ge__dict__long_long, pythonic::dispatch::ge__dict__long_double, pythonic::dispatch::ge__dict__uint, pythonic::dispatch::ge__dict__ulong, pythonic::dispatch::ge__dict__ulong_long, pythonic::dispatch::ge__dict__list, pythonic::dispatch::ge__dict__set, pythonic::dispatch::ge__dict__dict, pythonic::dispatch::ge__dict__orderedset, pythonic::dispatch::ge__dict__ordereddict, pythonic::dispatch::ge__dict__graph};
    t[15] = {pythonic::dispatch::ge__orderedset__none, pythonic::dispatch::ge__orderedset__int, pythonic::dispatch::ge__orderedset__float, pythonic::dispatch::ge__orderedset__string, pythonic::dispatch::ge__orderedset__bool, pythonic::dispatch::ge__orderedset__double, pythonic::dispatch::ge__orderedset__long, pythonic::dispatch::ge__orderedset__long_long, pythonic::dispatch::ge__orderedset__long_double, pythonic::dispatch::ge__orderedset__uint, pythonic::dispatch::ge__orderedset__ulong, pythonic::dispatch::ge__orderedset__ulong_long, pythonic::dispatch::ge__orderedset__list, pythonic::dispatch::ge__orderedset__set, pythonic::dispatch::ge__orderedset__dict, pythonic::dispatch::ge__orderedset__orderedset, pythonic::dispatch::ge__orderedset__ordereddict, pythonic::dispatch::ge__orderedset__graph};
    t[16] = {pythonic::dispatch::ge__ordereddict__none, pythonic::dispatch::ge__ordereddict__int, pythonic::dispatch::ge__ordereddict__float, pythonic::dispatch::ge__ordereddict__string, pythonic::dispatch::ge__ordereddict__bool, pythonic::dispatch::ge__ordereddict__double, pythonic::dispatch::ge__ordereddict__long, pythonic::dispatch::ge__ordereddict__long_long, pythonic::dispatch::ge__ordereddict__long_double, pythonic::dispatch::ge__ordereddict__uint, pythonic::dispatch::ge__ordereddict__ulong, pythonic::dispatch::ge__ordereddict__ulong_long, pythonic::dispatch::ge__ordereddict__list, pythonic::dispatch::ge__ordereddict__set, pythonic::dispatch::ge__ordereddict__dict, pythonic::dispatch::ge__ordereddict__orderedset, pythonic::dispatch::ge__ordereddict__ordereddict, pythonic::dispatch::ge__ordereddict__graph};
    t[17] = {pythonic::dispatch::ge__graph__none, pythonic::dispatch::ge__graph__int, pythonic::dispatch::ge__graph__float, pythonic::dispatch::ge__graph__string, pythonic::dispatch::ge__graph__bool, pythonic::dispatch::ge__graph__double, pythonic::dispatch::ge__graph__long, pythonic::dispatch::ge__graph__long_long, pythonic::dispatch::ge__graph__long_double, pythonic::dispatch::ge__graph__uint, pythonic::dispatch::ge__graph__ulong, pythonic::dispatch::ge__graph__ulong_long, pythonic::dispatch::ge__graph__list, pythonic::dispatch::ge__graph__set, pythonic::dispatch::ge__graph__dict, pythonic::dispatch::ge__graph__orderedset, pythonic::dispatch::ge__graph__ordereddict, pythonic::dispatch::ge__graph__graph};
    return t;
}();

// OpTable initialization for Lt
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Lt>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::lt__none__none, pythonic::dispatch::lt__none__int, pythonic::dispatch::lt__none__float, pythonic::dispatch::lt__none__string, pythonic::dispatch::lt__none__bool, pythonic::dispatch::lt__none__double, pythonic::dispatch::lt__none__long, pythonic::dispatch::lt__none__long_long, pythonic::dispatch::lt__none__long_double, pythonic::dispatch::lt__none__uint, pythonic::dispatch::lt__none__ulong, pythonic::dispatch::lt__none__ulong_long, pythonic::dispatch::lt__none__list, pythonic::dispatch::lt__none__set, pythonic::dispatch::lt__none__dict, pythonic::dispatch::lt__none__orderedset, pythonic::dispatch::lt__none__ordereddict, pythonic::dispatch::lt__none__graph};
    t[1] = {pythonic::dispatch::lt__int__none, pythonic::dispatch::lt__int__int, pythonic::dispatch::lt__int__float, pythonic::dispatch::lt__int__string, pythonic::dispatch::lt__int__bool, pythonic::dispatch::lt__int__double, pythonic::dispatch::lt__int__long, pythonic::dispatch::lt__int__long_long, pythonic::dispatch::lt__int__long_double, pythonic::dispatch::lt__int__uint, pythonic::dispatch::lt__int__ulong, pythonic::dispatch::lt__int__ulong_long, pythonic::dispatch::lt__int__list, pythonic::dispatch::lt__int__set, pythonic::dispatch::lt__int__dict, pythonic::dispatch::lt__int__orderedset, pythonic::dispatch::lt__int__ordereddict, pythonic::dispatch::lt__int__graph};
    t[2] = {pythonic::dispatch::lt__float__none, pythonic::dispatch::lt__float__int, pythonic::dispatch::lt__float__float, pythonic::dispatch::lt__float__string, pythonic::dispatch::lt__float__bool, pythonic::dispatch::lt__float__double, pythonic::dispatch::lt__float__long, pythonic::dispatch::lt__float__long_long, pythonic::dispatch::lt__float__long_double, pythonic::dispatch::lt__float__uint, pythonic::dispatch::lt__float__ulong, pythonic::dispatch::lt__float__ulong_long, pythonic::dispatch::lt__float__list, pythonic::dispatch::lt__float__set, pythonic::dispatch::lt__float__dict, pythonic::dispatch::lt__float__orderedset, pythonic::dispatch::lt__float__ordereddict, pythonic::dispatch::lt__float__graph};
    t[3] = {pythonic::dispatch::lt__string__none, pythonic::dispatch::lt__string__int, pythonic::dispatch::lt__string__float, pythonic::dispatch::lt__string__string, pythonic::dispatch::lt__string__bool, pythonic::dispatch::lt__string__double, pythonic::dispatch::lt__string__long, pythonic::dispatch::lt__string__long_long, pythonic::dispatch::lt__string__long_double, pythonic::dispatch::lt__string__uint, pythonic::dispatch::lt__string__ulong, pythonic::dispatch::lt__string__ulong_long, pythonic::dispatch::lt__string__list, pythonic::dispatch::lt__string__set, pythonic::dispatch::lt__string__dict, pythonic::dispatch::lt__string__orderedset, pythonic::dispatch::lt__string__ordereddict, pythonic::dispatch::lt__string__graph};
    t[4] = {pythonic::dispatch::lt__bool__none, pythonic::dispatch::lt__bool__int, pythonic::dispatch::lt__bool__float, pythonic::dispatch::lt__bool__string, pythonic::dispatch::lt__bool__bool, pythonic::dispatch::lt__bool__double, pythonic::dispatch::lt__bool__long, pythonic::dispatch::lt__bool__long_long, pythonic::dispatch::lt__bool__long_double, pythonic::dispatch::lt__bool__uint, pythonic::dispatch::lt__bool__ulong, pythonic::dispatch::lt__bool__ulong_long, pythonic::dispatch::lt__bool__list, pythonic::dispatch::lt__bool__set, pythonic::dispatch::lt__bool__dict, pythonic::dispatch::lt__bool__orderedset, pythonic::dispatch::lt__bool__ordereddict, pythonic::dispatch::lt__bool__graph};
    t[5] = {pythonic::dispatch::lt__double__none, pythonic::dispatch::lt__double__int, pythonic::dispatch::lt__double__float, pythonic::dispatch::lt__double__string, pythonic::dispatch::lt__double__bool, pythonic::dispatch::lt__double__double, pythonic::dispatch::lt__double__long, pythonic::dispatch::lt__double__long_long, pythonic::dispatch::lt__double__long_double, pythonic::dispatch::lt__double__uint, pythonic::dispatch::lt__double__ulong, pythonic::dispatch::lt__double__ulong_long, pythonic::dispatch::lt__double__list, pythonic::dispatch::lt__double__set, pythonic::dispatch::lt__double__dict, pythonic::dispatch::lt__double__orderedset, pythonic::dispatch::lt__double__ordereddict, pythonic::dispatch::lt__double__graph};
    t[6] = {pythonic::dispatch::lt__long__none, pythonic::dispatch::lt__long__int, pythonic::dispatch::lt__long__float, pythonic::dispatch::lt__long__string, pythonic::dispatch::lt__long__bool, pythonic::dispatch::lt__long__double, pythonic::dispatch::lt__long__long, pythonic::dispatch::lt__long__long_long, pythonic::dispatch::lt__long__long_double, pythonic::dispatch::lt__long__uint, pythonic::dispatch::lt__long__ulong, pythonic::dispatch::lt__long__ulong_long, pythonic::dispatch::lt__long__list, pythonic::dispatch::lt__long__set, pythonic::dispatch::lt__long__dict, pythonic::dispatch::lt__long__orderedset, pythonic::dispatch::lt__long__ordereddict, pythonic::dispatch::lt__long__graph};
    t[7] = {pythonic::dispatch::lt__long_long__none, pythonic::dispatch::lt__long_long__int, pythonic::dispatch::lt__long_long__float, pythonic::dispatch::lt__long_long__string, pythonic::dispatch::lt__long_long__bool, pythonic::dispatch::lt__long_long__double, pythonic::dispatch::lt__long_long__long, pythonic::dispatch::lt__long_long__long_long, pythonic::dispatch::lt__long_long__long_double, pythonic::dispatch::lt__long_long__uint, pythonic::dispatch::lt__long_long__ulong, pythonic::dispatch::lt__long_long__ulong_long, pythonic::dispatch::lt__long_long__list, pythonic::dispatch::lt__long_long__set, pythonic::dispatch::lt__long_long__dict, pythonic::dispatch::lt__long_long__orderedset, pythonic::dispatch::lt__long_long__ordereddict, pythonic::dispatch::lt__long_long__graph};
    t[8] = {pythonic::dispatch::lt__long_double__none, pythonic::dispatch::lt__long_double__int, pythonic::dispatch::lt__long_double__float, pythonic::dispatch::lt__long_double__string, pythonic::dispatch::lt__long_double__bool, pythonic::dispatch::lt__long_double__double, pythonic::dispatch::lt__long_double__long, pythonic::dispatch::lt__long_double__long_long, pythonic::dispatch::lt__long_double__long_double, pythonic::dispatch::lt__long_double__uint, pythonic::dispatch::lt__long_double__ulong, pythonic::dispatch::lt__long_double__ulong_long, pythonic::dispatch::lt__long_double__list, pythonic::dispatch::lt__long_double__set, pythonic::dispatch::lt__long_double__dict, pythonic::dispatch::lt__long_double__orderedset, pythonic::dispatch::lt__long_double__ordereddict, pythonic::dispatch::lt__long_double__graph};
    t[9] = {pythonic::dispatch::lt__uint__none, pythonic::dispatch::lt__uint__int, pythonic::dispatch::lt__uint__float, pythonic::dispatch::lt__uint__string, pythonic::dispatch::lt__uint__bool, pythonic::dispatch::lt__uint__double, pythonic::dispatch::lt__uint__long, pythonic::dispatch::lt__uint__long_long, pythonic::dispatch::lt__uint__long_double, pythonic::dispatch::lt__uint__uint, pythonic::dispatch::lt__uint__ulong, pythonic::dispatch::lt__uint__ulong_long, pythonic::dispatch::lt__uint__list, pythonic::dispatch::lt__uint__set, pythonic::dispatch::lt__uint__dict, pythonic::dispatch::lt__uint__orderedset, pythonic::dispatch::lt__uint__ordereddict, pythonic::dispatch::lt__uint__graph};
    t[10] = {pythonic::dispatch::lt__ulong__none, pythonic::dispatch::lt__ulong__int, pythonic::dispatch::lt__ulong__float, pythonic::dispatch::lt__ulong__string, pythonic::dispatch::lt__ulong__bool, pythonic::dispatch::lt__ulong__double, pythonic::dispatch::lt__ulong__long, pythonic::dispatch::lt__ulong__long_long, pythonic::dispatch::lt__ulong__long_double, pythonic::dispatch::lt__ulong__uint, pythonic::dispatch::lt__ulong__ulong, pythonic::dispatch::lt__ulong__ulong_long, pythonic::dispatch::lt__ulong__list, pythonic::dispatch::lt__ulong__set, pythonic::dispatch::lt__ulong__dict, pythonic::dispatch::lt__ulong__orderedset, pythonic::dispatch::lt__ulong__ordereddict, pythonic::dispatch::lt__ulong__graph};
    t[11] = {pythonic::dispatch::lt__ulong_long__none, pythonic::dispatch::lt__ulong_long__int, pythonic::dispatch::lt__ulong_long__float, pythonic::dispatch::lt__ulong_long__string, pythonic::dispatch::lt__ulong_long__bool, pythonic::dispatch::lt__ulong_long__double, pythonic::dispatch::lt__ulong_long__long, pythonic::dispatch::lt__ulong_long__long_long, pythonic::dispatch::lt__ulong_long__long_double, pythonic::dispatch::lt__ulong_long__uint, pythonic::dispatch::lt__ulong_long__ulong, pythonic::dispatch::lt__ulong_long__ulong_long, pythonic::dispatch::lt__ulong_long__list, pythonic::dispatch::lt__ulong_long__set, pythonic::dispatch::lt__ulong_long__dict, pythonic::dispatch::lt__ulong_long__orderedset, pythonic::dispatch::lt__ulong_long__ordereddict, pythonic::dispatch::lt__ulong_long__graph};
    t[12] = {pythonic::dispatch::lt__list__none, pythonic::dispatch::lt__list__int, pythonic::dispatch::lt__list__float, pythonic::dispatch::lt__list__string, pythonic::dispatch::lt__list__bool, pythonic::dispatch::lt__list__double, pythonic::dispatch::lt__list__long, pythonic::dispatch::lt__list__long_long, pythonic::dispatch::lt__list__long_double, pythonic::dispatch::lt__list__uint, pythonic::dispatch::lt__list__ulong, pythonic::dispatch::lt__list__ulong_long, pythonic::dispatch::lt__list__list, pythonic::dispatch::lt__list__set, pythonic::dispatch::lt__list__dict, pythonic::dispatch::lt__list__orderedset, pythonic::dispatch::lt__list__ordereddict, pythonic::dispatch::lt__list__graph};
    t[13] = {pythonic::dispatch::lt__set__none, pythonic::dispatch::lt__set__int, pythonic::dispatch::lt__set__float, pythonic::dispatch::lt__set__string, pythonic::dispatch::lt__set__bool, pythonic::dispatch::lt__set__double, pythonic::dispatch::lt__set__long, pythonic::dispatch::lt__set__long_long, pythonic::dispatch::lt__set__long_double, pythonic::dispatch::lt__set__uint, pythonic::dispatch::lt__set__ulong, pythonic::dispatch::lt__set__ulong_long, pythonic::dispatch::lt__set__list, pythonic::dispatch::lt__set__set, pythonic::dispatch::lt__set__dict, pythonic::dispatch::lt__set__orderedset, pythonic::dispatch::lt__set__ordereddict, pythonic::dispatch::lt__set__graph};
    t[14] = {pythonic::dispatch::lt__dict__none, pythonic::dispatch::lt__dict__int, pythonic::dispatch::lt__dict__float, pythonic::dispatch::lt__dict__string, pythonic::dispatch::lt__dict__bool, pythonic::dispatch::lt__dict__double, pythonic::dispatch::lt__dict__long, pythonic::dispatch::lt__dict__long_long, pythonic::dispatch::lt__dict__long_double, pythonic::dispatch::lt__dict__uint, pythonic::dispatch::lt__dict__ulong, pythonic::dispatch::lt__dict__ulong_long, pythonic::dispatch::lt__dict__list, pythonic::dispatch::lt__dict__set, pythonic::dispatch::lt__dict__dict, pythonic::dispatch::lt__dict__orderedset, pythonic::dispatch::lt__dict__ordereddict, pythonic::dispatch::lt__dict__graph};
    t[15] = {pythonic::dispatch::lt__orderedset__none, pythonic::dispatch::lt__orderedset__int, pythonic::dispatch::lt__orderedset__float, pythonic::dispatch::lt__orderedset__string, pythonic::dispatch::lt__orderedset__bool, pythonic::dispatch::lt__orderedset__double, pythonic::dispatch::lt__orderedset__long, pythonic::dispatch::lt__orderedset__long_long, pythonic::dispatch::lt__orderedset__long_double, pythonic::dispatch::lt__orderedset__uint, pythonic::dispatch::lt__orderedset__ulong, pythonic::dispatch::lt__orderedset__ulong_long, pythonic::dispatch::lt__orderedset__list, pythonic::dispatch::lt__orderedset__set, pythonic::dispatch::lt__orderedset__dict, pythonic::dispatch::lt__orderedset__orderedset, pythonic::dispatch::lt__orderedset__ordereddict, pythonic::dispatch::lt__orderedset__graph};
    t[16] = {pythonic::dispatch::lt__ordereddict__none, pythonic::dispatch::lt__ordereddict__int, pythonic::dispatch::lt__ordereddict__float, pythonic::dispatch::lt__ordereddict__string, pythonic::dispatch::lt__ordereddict__bool, pythonic::dispatch::lt__ordereddict__double, pythonic::dispatch::lt__ordereddict__long, pythonic::dispatch::lt__ordereddict__long_long, pythonic::dispatch::lt__ordereddict__long_double, pythonic::dispatch::lt__ordereddict__uint, pythonic::dispatch::lt__ordereddict__ulong, pythonic::dispatch::lt__ordereddict__ulong_long, pythonic::dispatch::lt__ordereddict__list, pythonic::dispatch::lt__ordereddict__set, pythonic::dispatch::lt__ordereddict__dict, pythonic::dispatch::lt__ordereddict__orderedset, pythonic::dispatch::lt__ordereddict__ordereddict, pythonic::dispatch::lt__ordereddict__graph};
    t[17] = {pythonic::dispatch::lt__graph__none, pythonic::dispatch::lt__graph__int, pythonic::dispatch::lt__graph__float, pythonic::dispatch::lt__graph__string, pythonic::dispatch::lt__graph__bool, pythonic::dispatch::lt__graph__double, pythonic::dispatch::lt__graph__long, pythonic::dispatch::lt__graph__long_long, pythonic::dispatch::lt__graph__long_double, pythonic::dispatch::lt__graph__uint, pythonic::dispatch::lt__graph__ulong, pythonic::dispatch::lt__graph__ulong_long, pythonic::dispatch::lt__graph__list, pythonic::dispatch::lt__graph__set, pythonic::dispatch::lt__graph__dict, pythonic::dispatch::lt__graph__orderedset, pythonic::dispatch::lt__graph__ordereddict, pythonic::dispatch::lt__graph__graph};
    return t;
}();

// OpTable initialization for Le
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::Le>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::le__none__none, pythonic::dispatch::le__none__int, pythonic::dispatch::le__none__float, pythonic::dispatch::le__none__string, pythonic::dispatch::le__none__bool, pythonic::dispatch::le__none__double, pythonic::dispatch::le__none__long, pythonic::dispatch::le__none__long_long, pythonic::dispatch::le__none__long_double, pythonic::dispatch::le__none__uint, pythonic::dispatch::le__none__ulong, pythonic::dispatch::le__none__ulong_long, pythonic::dispatch::le__none__list, pythonic::dispatch::le__none__set, pythonic::dispatch::le__none__dict, pythonic::dispatch::le__none__orderedset, pythonic::dispatch::le__none__ordereddict, pythonic::dispatch::le__none__graph};
    t[1] = {pythonic::dispatch::le__int__none, pythonic::dispatch::le__int__int, pythonic::dispatch::le__int__float, pythonic::dispatch::le__int__string, pythonic::dispatch::le__int__bool, pythonic::dispatch::le__int__double, pythonic::dispatch::le__int__long, pythonic::dispatch::le__int__long_long, pythonic::dispatch::le__int__long_double, pythonic::dispatch::le__int__uint, pythonic::dispatch::le__int__ulong, pythonic::dispatch::le__int__ulong_long, pythonic::dispatch::le__int__list, pythonic::dispatch::le__int__set, pythonic::dispatch::le__int__dict, pythonic::dispatch::le__int__orderedset, pythonic::dispatch::le__int__ordereddict, pythonic::dispatch::le__int__graph};
    t[2] = {pythonic::dispatch::le__float__none, pythonic::dispatch::le__float__int, pythonic::dispatch::le__float__float, pythonic::dispatch::le__float__string, pythonic::dispatch::le__float__bool, pythonic::dispatch::le__float__double, pythonic::dispatch::le__float__long, pythonic::dispatch::le__float__long_long, pythonic::dispatch::le__float__long_double, pythonic::dispatch::le__float__uint, pythonic::dispatch::le__float__ulong, pythonic::dispatch::le__float__ulong_long, pythonic::dispatch::le__float__list, pythonic::dispatch::le__float__set, pythonic::dispatch::le__float__dict, pythonic::dispatch::le__float__orderedset, pythonic::dispatch::le__float__ordereddict, pythonic::dispatch::le__float__graph};
    t[3] = {pythonic::dispatch::le__string__none, pythonic::dispatch::le__string__int, pythonic::dispatch::le__string__float, pythonic::dispatch::le__string__string, pythonic::dispatch::le__string__bool, pythonic::dispatch::le__string__double, pythonic::dispatch::le__string__long, pythonic::dispatch::le__string__long_long, pythonic::dispatch::le__string__long_double, pythonic::dispatch::le__string__uint, pythonic::dispatch::le__string__ulong, pythonic::dispatch::le__string__ulong_long, pythonic::dispatch::le__string__list, pythonic::dispatch::le__string__set, pythonic::dispatch::le__string__dict, pythonic::dispatch::le__string__orderedset, pythonic::dispatch::le__string__ordereddict, pythonic::dispatch::le__string__graph};
    t[4] = {pythonic::dispatch::le__bool__none, pythonic::dispatch::le__bool__int, pythonic::dispatch::le__bool__float, pythonic::dispatch::le__bool__string, pythonic::dispatch::le__bool__bool, pythonic::dispatch::le__bool__double, pythonic::dispatch::le__bool__long, pythonic::dispatch::le__bool__long_long, pythonic::dispatch::le__bool__long_double, pythonic::dispatch::le__bool__uint, pythonic::dispatch::le__bool__ulong, pythonic::dispatch::le__bool__ulong_long, pythonic::dispatch::le__bool__list, pythonic::dispatch::le__bool__set, pythonic::dispatch::le__bool__dict, pythonic::dispatch::le__bool__orderedset, pythonic::dispatch::le__bool__ordereddict, pythonic::dispatch::le__bool__graph};
    t[5] = {pythonic::dispatch::le__double__none, pythonic::dispatch::le__double__int, pythonic::dispatch::le__double__float, pythonic::dispatch::le__double__string, pythonic::dispatch::le__double__bool, pythonic::dispatch::le__double__double, pythonic::dispatch::le__double__long, pythonic::dispatch::le__double__long_long, pythonic::dispatch::le__double__long_double, pythonic::dispatch::le__double__uint, pythonic::dispatch::le__double__ulong, pythonic::dispatch::le__double__ulong_long, pythonic::dispatch::le__double__list, pythonic::dispatch::le__double__set, pythonic::dispatch::le__double__dict, pythonic::dispatch::le__double__orderedset, pythonic::dispatch::le__double__ordereddict, pythonic::dispatch::le__double__graph};
    t[6] = {pythonic::dispatch::le__long__none, pythonic::dispatch::le__long__int, pythonic::dispatch::le__long__float, pythonic::dispatch::le__long__string, pythonic::dispatch::le__long__bool, pythonic::dispatch::le__long__double, pythonic::dispatch::le__long__long, pythonic::dispatch::le__long__long_long, pythonic::dispatch::le__long__long_double, pythonic::dispatch::le__long__uint, pythonic::dispatch::le__long__ulong, pythonic::dispatch::le__long__ulong_long, pythonic::dispatch::le__long__list, pythonic::dispatch::le__long__set, pythonic::dispatch::le__long__dict, pythonic::dispatch::le__long__orderedset, pythonic::dispatch::le__long__ordereddict, pythonic::dispatch::le__long__graph};
    t[7] = {pythonic::dispatch::le__long_long__none, pythonic::dispatch::le__long_long__int, pythonic::dispatch::le__long_long__float, pythonic::dispatch::le__long_long__string, pythonic::dispatch::le__long_long__bool, pythonic::dispatch::le__long_long__double, pythonic::dispatch::le__long_long__long, pythonic::dispatch::le__long_long__long_long, pythonic::dispatch::le__long_long__long_double, pythonic::dispatch::le__long_long__uint, pythonic::dispatch::le__long_long__ulong, pythonic::dispatch::le__long_long__ulong_long, pythonic::dispatch::le__long_long__list, pythonic::dispatch::le__long_long__set, pythonic::dispatch::le__long_long__dict, pythonic::dispatch::le__long_long__orderedset, pythonic::dispatch::le__long_long__ordereddict, pythonic::dispatch::le__long_long__graph};
    t[8] = {pythonic::dispatch::le__long_double__none, pythonic::dispatch::le__long_double__int, pythonic::dispatch::le__long_double__float, pythonic::dispatch::le__long_double__string, pythonic::dispatch::le__long_double__bool, pythonic::dispatch::le__long_double__double, pythonic::dispatch::le__long_double__long, pythonic::dispatch::le__long_double__long_long, pythonic::dispatch::le__long_double__long_double, pythonic::dispatch::le__long_double__uint, pythonic::dispatch::le__long_double__ulong, pythonic::dispatch::le__long_double__ulong_long, pythonic::dispatch::le__long_double__list, pythonic::dispatch::le__long_double__set, pythonic::dispatch::le__long_double__dict, pythonic::dispatch::le__long_double__orderedset, pythonic::dispatch::le__long_double__ordereddict, pythonic::dispatch::le__long_double__graph};
    t[9] = {pythonic::dispatch::le__uint__none, pythonic::dispatch::le__uint__int, pythonic::dispatch::le__uint__float, pythonic::dispatch::le__uint__string, pythonic::dispatch::le__uint__bool, pythonic::dispatch::le__uint__double, pythonic::dispatch::le__uint__long, pythonic::dispatch::le__uint__long_long, pythonic::dispatch::le__uint__long_double, pythonic::dispatch::le__uint__uint, pythonic::dispatch::le__uint__ulong, pythonic::dispatch::le__uint__ulong_long, pythonic::dispatch::le__uint__list, pythonic::dispatch::le__uint__set, pythonic::dispatch::le__uint__dict, pythonic::dispatch::le__uint__orderedset, pythonic::dispatch::le__uint__ordereddict, pythonic::dispatch::le__uint__graph};
    t[10] = {pythonic::dispatch::le__ulong__none, pythonic::dispatch::le__ulong__int, pythonic::dispatch::le__ulong__float, pythonic::dispatch::le__ulong__string, pythonic::dispatch::le__ulong__bool, pythonic::dispatch::le__ulong__double, pythonic::dispatch::le__ulong__long, pythonic::dispatch::le__ulong__long_long, pythonic::dispatch::le__ulong__long_double, pythonic::dispatch::le__ulong__uint, pythonic::dispatch::le__ulong__ulong, pythonic::dispatch::le__ulong__ulong_long, pythonic::dispatch::le__ulong__list, pythonic::dispatch::le__ulong__set, pythonic::dispatch::le__ulong__dict, pythonic::dispatch::le__ulong__orderedset, pythonic::dispatch::le__ulong__ordereddict, pythonic::dispatch::le__ulong__graph};
    t[11] = {pythonic::dispatch::le__ulong_long__none, pythonic::dispatch::le__ulong_long__int, pythonic::dispatch::le__ulong_long__float, pythonic::dispatch::le__ulong_long__string, pythonic::dispatch::le__ulong_long__bool, pythonic::dispatch::le__ulong_long__double, pythonic::dispatch::le__ulong_long__long, pythonic::dispatch::le__ulong_long__long_long, pythonic::dispatch::le__ulong_long__long_double, pythonic::dispatch::le__ulong_long__uint, pythonic::dispatch::le__ulong_long__ulong, pythonic::dispatch::le__ulong_long__ulong_long, pythonic::dispatch::le__ulong_long__list, pythonic::dispatch::le__ulong_long__set, pythonic::dispatch::le__ulong_long__dict, pythonic::dispatch::le__ulong_long__orderedset, pythonic::dispatch::le__ulong_long__ordereddict, pythonic::dispatch::le__ulong_long__graph};
    t[12] = {pythonic::dispatch::le__list__none, pythonic::dispatch::le__list__int, pythonic::dispatch::le__list__float, pythonic::dispatch::le__list__string, pythonic::dispatch::le__list__bool, pythonic::dispatch::le__list__double, pythonic::dispatch::le__list__long, pythonic::dispatch::le__list__long_long, pythonic::dispatch::le__list__long_double, pythonic::dispatch::le__list__uint, pythonic::dispatch::le__list__ulong, pythonic::dispatch::le__list__ulong_long, pythonic::dispatch::le__list__list, pythonic::dispatch::le__list__set, pythonic::dispatch::le__list__dict, pythonic::dispatch::le__list__orderedset, pythonic::dispatch::le__list__ordereddict, pythonic::dispatch::le__list__graph};
    t[13] = {pythonic::dispatch::le__set__none, pythonic::dispatch::le__set__int, pythonic::dispatch::le__set__float, pythonic::dispatch::le__set__string, pythonic::dispatch::le__set__bool, pythonic::dispatch::le__set__double, pythonic::dispatch::le__set__long, pythonic::dispatch::le__set__long_long, pythonic::dispatch::le__set__long_double, pythonic::dispatch::le__set__uint, pythonic::dispatch::le__set__ulong, pythonic::dispatch::le__set__ulong_long, pythonic::dispatch::le__set__list, pythonic::dispatch::le__set__set, pythonic::dispatch::le__set__dict, pythonic::dispatch::le__set__orderedset, pythonic::dispatch::le__set__ordereddict, pythonic::dispatch::le__set__graph};
    t[14] = {pythonic::dispatch::le__dict__none, pythonic::dispatch::le__dict__int, pythonic::dispatch::le__dict__float, pythonic::dispatch::le__dict__string, pythonic::dispatch::le__dict__bool, pythonic::dispatch::le__dict__double, pythonic::dispatch::le__dict__long, pythonic::dispatch::le__dict__long_long, pythonic::dispatch::le__dict__long_double, pythonic::dispatch::le__dict__uint, pythonic::dispatch::le__dict__ulong, pythonic::dispatch::le__dict__ulong_long, pythonic::dispatch::le__dict__list, pythonic::dispatch::le__dict__set, pythonic::dispatch::le__dict__dict, pythonic::dispatch::le__dict__orderedset, pythonic::dispatch::le__dict__ordereddict, pythonic::dispatch::le__dict__graph};
    t[15] = {pythonic::dispatch::le__orderedset__none, pythonic::dispatch::le__orderedset__int, pythonic::dispatch::le__orderedset__float, pythonic::dispatch::le__orderedset__string, pythonic::dispatch::le__orderedset__bool, pythonic::dispatch::le__orderedset__double, pythonic::dispatch::le__orderedset__long, pythonic::dispatch::le__orderedset__long_long, pythonic::dispatch::le__orderedset__long_double, pythonic::dispatch::le__orderedset__uint, pythonic::dispatch::le__orderedset__ulong, pythonic::dispatch::le__orderedset__ulong_long, pythonic::dispatch::le__orderedset__list, pythonic::dispatch::le__orderedset__set, pythonic::dispatch::le__orderedset__dict, pythonic::dispatch::le__orderedset__orderedset, pythonic::dispatch::le__orderedset__ordereddict, pythonic::dispatch::le__orderedset__graph};
    t[16] = {pythonic::dispatch::le__ordereddict__none, pythonic::dispatch::le__ordereddict__int, pythonic::dispatch::le__ordereddict__float, pythonic::dispatch::le__ordereddict__string, pythonic::dispatch::le__ordereddict__bool, pythonic::dispatch::le__ordereddict__double, pythonic::dispatch::le__ordereddict__long, pythonic::dispatch::le__ordereddict__long_long, pythonic::dispatch::le__ordereddict__long_double, pythonic::dispatch::le__ordereddict__uint, pythonic::dispatch::le__ordereddict__ulong, pythonic::dispatch::le__ordereddict__ulong_long, pythonic::dispatch::le__ordereddict__list, pythonic::dispatch::le__ordereddict__set, pythonic::dispatch::le__ordereddict__dict, pythonic::dispatch::le__ordereddict__orderedset, pythonic::dispatch::le__ordereddict__ordereddict, pythonic::dispatch::le__ordereddict__graph};
    t[17] = {pythonic::dispatch::le__graph__none, pythonic::dispatch::le__graph__int, pythonic::dispatch::le__graph__float, pythonic::dispatch::le__graph__string, pythonic::dispatch::le__graph__bool, pythonic::dispatch::le__graph__double, pythonic::dispatch::le__graph__long, pythonic::dispatch::le__graph__long_long, pythonic::dispatch::le__graph__long_double, pythonic::dispatch::le__graph__uint, pythonic::dispatch::le__graph__ulong, pythonic::dispatch::le__graph__ulong_long, pythonic::dispatch::le__graph__list, pythonic::dispatch::le__graph__set, pythonic::dispatch::le__graph__dict, pythonic::dispatch::le__graph__orderedset, pythonic::dispatch::le__graph__ordereddict, pythonic::dispatch::le__graph__graph};
    return t;
}();

// OpTable initialization for BitAnd
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::BitAnd>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::band__none__none, pythonic::dispatch::band__none__int, pythonic::dispatch::band__none__float, pythonic::dispatch::band__none__string, pythonic::dispatch::band__none__bool, pythonic::dispatch::band__none__double, pythonic::dispatch::band__none__long, pythonic::dispatch::band__none__long_long, pythonic::dispatch::band__none__long_double, pythonic::dispatch::band__none__uint, pythonic::dispatch::band__none__ulong, pythonic::dispatch::band__none__ulong_long, pythonic::dispatch::band__none__list, pythonic::dispatch::band__none__set, pythonic::dispatch::band__none__dict, pythonic::dispatch::band__none__orderedset, pythonic::dispatch::band__none__ordereddict, pythonic::dispatch::band__none__graph};
    t[1] = {pythonic::dispatch::band__int__none, pythonic::dispatch::band__int__int, pythonic::dispatch::band__int__float, pythonic::dispatch::band__int__string, pythonic::dispatch::band__int__bool, pythonic::dispatch::band__int__double, pythonic::dispatch::band__int__long, pythonic::dispatch::band__int__long_long, pythonic::dispatch::band__int__long_double, pythonic::dispatch::band__int__uint, pythonic::dispatch::band__int__ulong, pythonic::dispatch::band__int__ulong_long, pythonic::dispatch::band__int__list, pythonic::dispatch::band__int__set, pythonic::dispatch::band__int__dict, pythonic::dispatch::band__int__orderedset, pythonic::dispatch::band__int__ordereddict, pythonic::dispatch::band__int__graph};
    t[2] = {pythonic::dispatch::band__float__none, pythonic::dispatch::band__float__int, pythonic::dispatch::band__float__float, pythonic::dispatch::band__float__string, pythonic::dispatch::band__float__bool, pythonic::dispatch::band__float__double, pythonic::dispatch::band__float__long, pythonic::dispatch::band__float__long_long, pythonic::dispatch::band__float__long_double, pythonic::dispatch::band__float__uint, pythonic::dispatch::band__float__ulong, pythonic::dispatch::band__float__ulong_long, pythonic::dispatch::band__float__list, pythonic::dispatch::band__float__set, pythonic::dispatch::band__float__dict, pythonic::dispatch::band__float__orderedset, pythonic::dispatch::band__float__ordereddict, pythonic::dispatch::band__float__graph};
    t[3] = {pythonic::dispatch::band__string__none, pythonic::dispatch::band__string__int, pythonic::dispatch::band__string__float, pythonic::dispatch::band__string__string, pythonic::dispatch::band__string__bool, pythonic::dispatch::band__string__double, pythonic::dispatch::band__string__long, pythonic::dispatch::band__string__long_long, pythonic::dispatch::band__string__long_double, pythonic::dispatch::band__string__uint, pythonic::dispatch::band__string__ulong, pythonic::dispatch::band__string__ulong_long, pythonic::dispatch::band__string__list, pythonic::dispatch::band__string__set, pythonic::dispatch::band__string__dict, pythonic::dispatch::band__string__orderedset, pythonic::dispatch::band__string__ordereddict, pythonic::dispatch::band__string__graph};
    t[4] = {pythonic::dispatch::band__bool__none, pythonic::dispatch::band__bool__int, pythonic::dispatch::band__bool__float, pythonic::dispatch::band__bool__string, pythonic::dispatch::band__bool__bool, pythonic::dispatch::band__bool__double, pythonic::dispatch::band__bool__long, pythonic::dispatch::band__bool__long_long, pythonic::dispatch::band__bool__long_double, pythonic::dispatch::band__bool__uint, pythonic::dispatch::band__bool__ulong, pythonic::dispatch::band__bool__ulong_long, pythonic::dispatch::band__bool__list, pythonic::dispatch::band__bool__set, pythonic::dispatch::band__bool__dict, pythonic::dispatch::band__bool__orderedset, pythonic::dispatch::band__bool__ordereddict, pythonic::dispatch::band__bool__graph};
    t[5] = {pythonic::dispatch::band__double__none, pythonic::dispatch::band__double__int, pythonic::dispatch::band__double__float, pythonic::dispatch::band__double__string, pythonic::dispatch::band__double__bool, pythonic::dispatch::band__double__double, pythonic::dispatch::band__double__long, pythonic::dispatch::band__double__long_long, pythonic::dispatch::band__double__long_double, pythonic::dispatch::band__double__uint, pythonic::dispatch::band__double__ulong, pythonic::dispatch::band__double__ulong_long, pythonic::dispatch::band__double__list, pythonic::dispatch::band__double__set, pythonic::dispatch::band__double__dict, pythonic::dispatch::band__double__orderedset, pythonic::dispatch::band__double__ordereddict, pythonic::dispatch::band__double__graph};
    t[6] = {pythonic::dispatch::band__long__none, pythonic::dispatch::band__long__int, pythonic::dispatch::band__long__float, pythonic::dispatch::band__long__string, pythonic::dispatch::band__long__bool, pythonic::dispatch::band__long__double, pythonic::dispatch::band__long__long, pythonic::dispatch::band__long__long_long, pythonic::dispatch::band__long__long_double, pythonic::dispatch::band__long__uint, pythonic::dispatch::band__long__ulong, pythonic::dispatch::band__long__ulong_long, pythonic::dispatch::band__long__list, pythonic::dispatch::band__long__set, pythonic::dispatch::band__long__dict, pythonic::dispatch::band__long__orderedset, pythonic::dispatch::band__long__ordereddict, pythonic::dispatch::band__long__graph};
    t[7] = {pythonic::dispatch::band__long_long__none, pythonic::dispatch::band__long_long__int, pythonic::dispatch::band__long_long__float, pythonic::dispatch::band__long_long__string, pythonic::dispatch::band__long_long__bool, pythonic::dispatch::band__long_long__double, pythonic::dispatch::band__long_long__long, pythonic::dispatch::band__long_long__long_long, pythonic::dispatch::band__long_long__long_double, pythonic::dispatch::band__long_long__uint, pythonic::dispatch::band__long_long__ulong, pythonic::dispatch::band__long_long__ulong_long, pythonic::dispatch::band__long_long__list, pythonic::dispatch::band__long_long__set, pythonic::dispatch::band__long_long__dict, pythonic::dispatch::band__long_long__orderedset, pythonic::dispatch::band__long_long__ordereddict, pythonic::dispatch::band__long_long__graph};
    t[8] = {pythonic::dispatch::band__long_double__none, pythonic::dispatch::band__long_double__int, pythonic::dispatch::band__long_double__float, pythonic::dispatch::band__long_double__string, pythonic::dispatch::band__long_double__bool, pythonic::dispatch::band__long_double__double, pythonic::dispatch::band__long_double__long, pythonic::dispatch::band__long_double__long_long, pythonic::dispatch::band__long_double__long_double, pythonic::dispatch::band__long_double__uint, pythonic::dispatch::band__long_double__ulong, pythonic::dispatch::band__long_double__ulong_long, pythonic::dispatch::band__long_double__list, pythonic::dispatch::band__long_double__set, pythonic::dispatch::band__long_double__dict, pythonic::dispatch::band__long_double__orderedset, pythonic::dispatch::band__long_double__ordereddict, pythonic::dispatch::band__long_double__graph};
    t[9] = {pythonic::dispatch::band__uint__none, pythonic::dispatch::band__uint__int, pythonic::dispatch::band__uint__float, pythonic::dispatch::band__uint__string, pythonic::dispatch::band__uint__bool, pythonic::dispatch::band__uint__double, pythonic::dispatch::band__uint__long, pythonic::dispatch::band__uint__long_long, pythonic::dispatch::band__uint__long_double, pythonic::dispatch::band__uint__uint, pythonic::dispatch::band__uint__ulong, pythonic::dispatch::band__uint__ulong_long, pythonic::dispatch::band__uint__list, pythonic::dispatch::band__uint__set, pythonic::dispatch::band__uint__dict, pythonic::dispatch::band__uint__orderedset, pythonic::dispatch::band__uint__ordereddict, pythonic::dispatch::band__uint__graph};
    t[10] = {pythonic::dispatch::band__ulong__none, pythonic::dispatch::band__ulong__int, pythonic::dispatch::band__ulong__float, pythonic::dispatch::band__ulong__string, pythonic::dispatch::band__ulong__bool, pythonic::dispatch::band__ulong__double, pythonic::dispatch::band__ulong__long, pythonic::dispatch::band__ulong__long_long, pythonic::dispatch::band__ulong__long_double, pythonic::dispatch::band__ulong__uint, pythonic::dispatch::band__ulong__ulong, pythonic::dispatch::band__ulong__ulong_long, pythonic::dispatch::band__ulong__list, pythonic::dispatch::band__ulong__set, pythonic::dispatch::band__ulong__dict, pythonic::dispatch::band__ulong__orderedset, pythonic::dispatch::band__ulong__ordereddict, pythonic::dispatch::band__ulong__graph};
    t[11] = {pythonic::dispatch::band__ulong_long__none, pythonic::dispatch::band__ulong_long__int, pythonic::dispatch::band__ulong_long__float, pythonic::dispatch::band__ulong_long__string, pythonic::dispatch::band__ulong_long__bool, pythonic::dispatch::band__ulong_long__double, pythonic::dispatch::band__ulong_long__long, pythonic::dispatch::band__ulong_long__long_long, pythonic::dispatch::band__ulong_long__long_double, pythonic::dispatch::band__ulong_long__uint, pythonic::dispatch::band__ulong_long__ulong, pythonic::dispatch::band__ulong_long__ulong_long, pythonic::dispatch::band__ulong_long__list, pythonic::dispatch::band__ulong_long__set, pythonic::dispatch::band__ulong_long__dict, pythonic::dispatch::band__ulong_long__orderedset, pythonic::dispatch::band__ulong_long__ordereddict, pythonic::dispatch::band__ulong_long__graph};
    t[12] = {pythonic::dispatch::band__list__none, pythonic::dispatch::band__list__int, pythonic::dispatch::band__list__float, pythonic::dispatch::band__list__string, pythonic::dispatch::band__list__bool, pythonic::dispatch::band__list__double, pythonic::dispatch::band__list__long, pythonic::dispatch::band__list__long_long, pythonic::dispatch::band__list__long_double, pythonic::dispatch::band__list__uint, pythonic::dispatch::band__list__ulong, pythonic::dispatch::band__list__ulong_long, pythonic::dispatch::band__list__list, pythonic::dispatch::band__list__set, pythonic::dispatch::band__list__dict, pythonic::dispatch::band__list__orderedset, pythonic::dispatch::band__list__ordereddict, pythonic::dispatch::band__list__graph};
    t[13] = {pythonic::dispatch::band__set__none, pythonic::dispatch::band__set__int, pythonic::dispatch::band__set__float, pythonic::dispatch::band__set__string, pythonic::dispatch::band__set__bool, pythonic::dispatch::band__set__double, pythonic::dispatch::band__set__long, pythonic::dispatch::band__set__long_long, pythonic::dispatch::band__set__long_double, pythonic::dispatch::band__set__uint, pythonic::dispatch::band__set__ulong, pythonic::dispatch::band__set__ulong_long, pythonic::dispatch::band__set__list, pythonic::dispatch::band__set__set, pythonic::dispatch::band__set__dict, pythonic::dispatch::band__set__orderedset, pythonic::dispatch::band__set__ordereddict, pythonic::dispatch::band__set__graph};
    t[14] = {pythonic::dispatch::band__dict__none, pythonic::dispatch::band__dict__int, pythonic::dispatch::band__dict__float, pythonic::dispatch::band__dict__string, pythonic::dispatch::band__dict__bool, pythonic::dispatch::band__dict__double, pythonic::dispatch::band__dict__long, pythonic::dispatch::band__dict__long_long, pythonic::dispatch::band__dict__long_double, pythonic::dispatch::band__dict__uint, pythonic::dispatch::band__dict__ulong, pythonic::dispatch::band__dict__ulong_long, pythonic::dispatch::band__dict__list, pythonic::dispatch::band__dict__set, pythonic::dispatch::band__dict__dict, pythonic::dispatch::band__dict__orderedset, pythonic::dispatch::band__dict__ordereddict, pythonic::dispatch::band__dict__graph};
    t[15] = {pythonic::dispatch::band__orderedset__none, pythonic::dispatch::band__orderedset__int, pythonic::dispatch::band__orderedset__float, pythonic::dispatch::band__orderedset__string, pythonic::dispatch::band__orderedset__bool, pythonic::dispatch::band__orderedset__double, pythonic::dispatch::band__orderedset__long, pythonic::dispatch::band__orderedset__long_long, pythonic::dispatch::band__orderedset__long_double, pythonic::dispatch::band__orderedset__uint, pythonic::dispatch::band__orderedset__ulong, pythonic::dispatch::band__orderedset__ulong_long, pythonic::dispatch::band__orderedset__list, pythonic::dispatch::band__orderedset__set, pythonic::dispatch::band__orderedset__dict, pythonic::dispatch::band__orderedset__orderedset, pythonic::dispatch::band__orderedset__ordereddict, pythonic::dispatch::band__orderedset__graph};
    t[16] = {pythonic::dispatch::band__ordereddict__none, pythonic::dispatch::band__ordereddict__int, pythonic::dispatch::band__ordereddict__float, pythonic::dispatch::band__ordereddict__string, pythonic::dispatch::band__ordereddict__bool, pythonic::dispatch::band__ordereddict__double, pythonic::dispatch::band__ordereddict__long, pythonic::dispatch::band__ordereddict__long_long, pythonic::dispatch::band__ordereddict__long_double, pythonic::dispatch::band__ordereddict__uint, pythonic::dispatch::band__ordereddict__ulong, pythonic::dispatch::band__ordereddict__ulong_long, pythonic::dispatch::band__ordereddict__list, pythonic::dispatch::band__ordereddict__set, pythonic::dispatch::band__ordereddict__dict, pythonic::dispatch::band__ordereddict__orderedset, pythonic::dispatch::band__ordereddict__ordereddict, pythonic::dispatch::band__ordereddict__graph};
    t[17] = {pythonic::dispatch::band__graph__none, pythonic::dispatch::band__graph__int, pythonic::dispatch::band__graph__float, pythonic::dispatch::band__graph__string, pythonic::dispatch::band__graph__bool, pythonic::dispatch::band__graph__double, pythonic::dispatch::band__graph__long, pythonic::dispatch::band__graph__long_long, pythonic::dispatch::band__graph__long_double, pythonic::dispatch::band__graph__uint, pythonic::dispatch::band__graph__ulong, pythonic::dispatch::band__graph__ulong_long, pythonic::dispatch::band__graph__list, pythonic::dispatch::band__graph__set, pythonic::dispatch::band__graph__dict, pythonic::dispatch::band__graph__orderedset, pythonic::dispatch::band__graph__ordereddict, pythonic::dispatch::band__graph__graph};
    return t;
}();

// OpTable initialization for BitOr
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::BitOr>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::bor__none__none, pythonic::dispatch::bor__none__int, pythonic::dispatch::bor__none__float, pythonic::dispatch::bor__none__string, pythonic::dispatch::bor__none__bool, pythonic::dispatch::bor__none__double, pythonic::dispatch::bor__none__long, pythonic::dispatch::bor__none__long_long, pythonic::dispatch::bor__none__long_double, pythonic::dispatch::bor__none__uint, pythonic::dispatch::bor__none__ulong, pythonic::dispatch::bor__none__ulong_long, pythonic::dispatch::bor__none__list, pythonic::dispatch::bor__none__set, pythonic::dispatch::bor__none__dict, pythonic::dispatch::bor__none__orderedset, pythonic::dispatch::bor__none__ordereddict, pythonic::dispatch::bor__none__graph};
    t[1] = {pythonic::dispatch::bor__int__none, pythonic::dispatch::bor__int__int, pythonic::dispatch::bor__int__float, pythonic::dispatch::bor__int__string, pythonic::dispatch::bor__int__bool, pythonic::dispatch::bor__int__double, pythonic::dispatch::bor__int__long, pythonic::dispatch::bor__int__long_long, pythonic::dispatch::bor__int__long_double, pythonic::dispatch::bor__int__uint, pythonic::dispatch::bor__int__ulong, pythonic::dispatch::bor__int__ulong_long, pythonic::dispatch::bor__int__list, pythonic::dispatch::bor__int__set, pythonic::dispatch::bor__int__dict, pythonic::dispatch::bor__int__orderedset, pythonic::dispatch::bor__int__ordereddict, pythonic::dispatch::bor__int__graph};
    t[2] = {pythonic::dispatch::bor__float__none, pythonic::dispatch::bor__float__int, pythonic::dispatch::bor__float__float, pythonic::dispatch::bor__float__string, pythonic::dispatch::bor__float__bool, pythonic::dispatch::bor__float__double, pythonic::dispatch::bor__float__long, pythonic::dispatch::bor__float__long_long, pythonic::dispatch::bor__float__long_double, pythonic::dispatch::bor__float__uint, pythonic::dispatch::bor__float__ulong, pythonic::dispatch::bor__float__ulong_long, pythonic::dispatch::bor__float__list, pythonic::dispatch::bor__float__set, pythonic::dispatch::bor__float__dict, pythonic::dispatch::bor__float__orderedset, pythonic::dispatch::bor__float__ordereddict, pythonic::dispatch::bor__float__graph};
    t[3] = {pythonic::dispatch::bor__string__none, pythonic::dispatch::bor__string__int, pythonic::dispatch::bor__string__float, pythonic::dispatch::bor__string__string, pythonic::dispatch::bor__string__bool, pythonic::dispatch::bor__string__double, pythonic::dispatch::bor__string__long, pythonic::dispatch::bor__string__long_long, pythonic::dispatch::bor__string__long_double, pythonic::dispatch::bor__string__uint, pythonic::dispatch::bor__string__ulong, pythonic::dispatch::bor__string__ulong_long, pythonic::dispatch::bor__string__list, pythonic::dispatch::bor__string__set, pythonic::dispatch::bor__string__dict, pythonic::dispatch::bor__string__orderedset, pythonic::dispatch::bor__string__ordereddict, pythonic::dispatch::bor__string__graph};
    t[4] = {pythonic::dispatch::bor__bool__none, pythonic::dispatch::bor__bool__int, pythonic::dispatch::bor__bool__float, pythonic::dispatch::bor__bool__string, pythonic::dispatch::bor__bool__bool, pythonic::dispatch::bor__bool__double, pythonic::dispatch::bor__bool__long, pythonic::dispatch::bor__bool__long_long, pythonic::dispatch::bor__bool__long_double, pythonic::dispatch::bor__bool__uint, pythonic::dispatch::bor__bool__ulong, pythonic::dispatch::bor__bool__ulong_long, pythonic::dispatch::bor__bool__list, pythonic::dispatch::bor__bool__set, pythonic::dispatch::bor__bool__dict, pythonic::dispatch::bor__bool__orderedset, pythonic::dispatch::bor__bool__ordereddict, pythonic::dispatch::bor__bool__graph};
    t[5] = {pythonic::dispatch::bor__double__none, pythonic::dispatch::bor__double__int, pythonic::dispatch::bor__double__float, pythonic::dispatch::bor__double__string, pythonic::dispatch::bor__double__bool, pythonic::dispatch::bor__double__double, pythonic::dispatch::bor__double__long, pythonic::dispatch::bor__double__long_long, pythonic::dispatch::bor__double__long_double, pythonic::dispatch::bor__double__uint, pythonic::dispatch::bor__double__ulong, pythonic::dispatch::bor__double__ulong_long, pythonic::dispatch::bor__double__list, pythonic::dispatch::bor__double__set, pythonic::dispatch::bor__double__dict, pythonic::dispatch::bor__double__orderedset, pythonic::dispatch::bor__double__ordereddict, pythonic::dispatch::bor__double__graph};
    t[6] = {pythonic::dispatch::bor__long__none, pythonic::dispatch::bor__long__int, pythonic::dispatch::bor__long__float, pythonic::dispatch::bor__long__string, pythonic::dispatch::bor__long__bool, pythonic::dispatch::bor__long__double, pythonic::dispatch::bor__long__long, pythonic::dispatch::bor__long__long_long, pythonic::dispatch::bor__long__long_double, pythonic::dispatch::bor__long__uint, pythonic::dispatch::bor__long__ulong, pythonic::dispatch::bor__long__ulong_long, pythonic::dispatch::bor__long__list, pythonic::dispatch::bor__long__set, pythonic::dispatch::bor__long__dict, pythonic::dispatch::bor__long__orderedset, pythonic::dispatch::bor__long__ordereddict, pythonic::dispatch::bor__long__graph};
    t[7] = {pythonic::dispatch::bor__long_long__none, pythonic::dispatch::bor__long_long__int, pythonic::dispatch::bor__long_long__float, pythonic::dispatch::bor__long_long__string, pythonic::dispatch::bor__long_long__bool, pythonic::dispatch::bor__long_long__double, pythonic::dispatch::bor__long_long__long, pythonic::dispatch::bor__long_long__long_long, pythonic::dispatch::bor__long_long__long_double, pythonic::dispatch::bor__long_long__uint, pythonic::dispatch::bor__long_long__ulong, pythonic::dispatch::bor__long_long__ulong_long, pythonic::dispatch::bor__long_long__list, pythonic::dispatch::bor__long_long__set, pythonic::dispatch::bor__long_long__dict, pythonic::dispatch::bor__long_long__orderedset, pythonic::dispatch::bor__long_long__ordereddict, pythonic::dispatch::bor__long_long__graph};
    t[8] = {pythonic::dispatch::bor__long_double__none, pythonic::dispatch::bor__long_double__int, pythonic::dispatch::bor__long_double__float, pythonic::dispatch::bor__long_double__string, pythonic::dispatch::bor__long_double__bool, pythonic::dispatch::bor__long_double__double, pythonic::dispatch::bor__long_double__long, pythonic::dispatch::bor__long_double__long_long, pythonic::dispatch::bor__long_double__long_double, pythonic::dispatch::bor__long_double__uint, pythonic::dispatch::bor__long_double__ulong, pythonic::dispatch::bor__long_double__ulong_long, pythonic::dispatch::bor__long_double__list, pythonic::dispatch::bor__long_double__set, pythonic::dispatch::bor__long_double__dict, pythonic::dispatch::bor__long_double__orderedset, pythonic::dispatch::bor__long_double__ordereddict, pythonic::dispatch::bor__long_double__graph};
    t[9] = {pythonic::dispatch::bor__uint__none, pythonic::dispatch::bor__uint__int, pythonic::dispatch::bor__uint__float, pythonic::dispatch::bor__uint__string, pythonic::dispatch::bor__uint__bool, pythonic::dispatch::bor__uint__double, pythonic::dispatch::bor__uint__long, pythonic::dispatch::bor__uint__long_long, pythonic::dispatch::bor__uint__long_double, pythonic::dispatch::bor__uint__uint, pythonic::dispatch::bor__uint__ulong, pythonic::dispatch::bor__uint__ulong_long, pythonic::dispatch::bor__uint__list, pythonic::dispatch::bor__uint__set, pythonic::dispatch::bor__uint__dict, pythonic::dispatch::bor__uint__orderedset, pythonic::dispatch::bor__uint__ordereddict, pythonic::dispatch::bor__uint__graph};
    t[10] = {pythonic::dispatch::bor__ulong__none, pythonic::dispatch::bor__ulong__int, pythonic::dispatch::bor__ulong__float, pythonic::dispatch::bor__ulong__string, pythonic::dispatch::bor__ulong__bool, pythonic::dispatch::bor__ulong__double, pythonic::dispatch::bor__ulong__long, pythonic::dispatch::bor__ulong__long_long, pythonic::dispatch::bor__ulong__long_double, pythonic::dispatch::bor__ulong__uint, pythonic::dispatch::bor__ulong__ulong, pythonic::dispatch::bor__ulong__ulong_long, pythonic::dispatch::bor__ulong__list, pythonic::dispatch::bor__ulong__set, pythonic::dispatch::bor__ulong__dict, pythonic::dispatch::bor__ulong__orderedset, pythonic::dispatch::bor__ulong__ordereddict, pythonic::dispatch::bor__ulong__graph};
    t[11] = {pythonic::dispatch::bor__ulong_long__none, pythonic::dispatch::bor__ulong_long__int, pythonic::dispatch::bor__ulong_long__float, pythonic::dispatch::bor__ulong_long__string, pythonic::dispatch::bor__ulong_long__bool, pythonic::dispatch::bor__ulong_long__double, pythonic::dispatch::bor__ulong_long__long, pythonic::dispatch::bor__ulong_long__long_long, pythonic::dispatch::bor__ulong_long__long_double, pythonic::dispatch::bor__ulong_long__uint, pythonic::dispatch::bor__ulong_long__ulong, pythonic::dispatch::bor__ulong_long__ulong_long, pythonic::dispatch::bor__ulong_long__list, pythonic::dispatch::bor__ulong_long__set, pythonic::dispatch::bor__ulong_long__dict, pythonic::dispatch::bor__ulong_long__orderedset, pythonic::dispatch::bor__ulong_long__ordereddict, pythonic::dispatch::bor__ulong_long__graph};
    t[12] = {pythonic::dispatch::bor__list__none, pythonic::dispatch::bor__list__int, pythonic::dispatch::bor__list__float, pythonic::dispatch::bor__list__string, pythonic::dispatch::bor__list__bool, pythonic::dispatch::bor__list__double, pythonic::dispatch::bor__list__long, pythonic::dispatch::bor__list__long_long, pythonic::dispatch::bor__list__long_double, pythonic::dispatch::bor__list__uint, pythonic::dispatch::bor__list__ulong, pythonic::dispatch::bor__list__ulong_long, pythonic::dispatch::bor__list__list, pythonic::dispatch::bor__list__set, pythonic::dispatch::bor__list__dict, pythonic::dispatch::bor__list__orderedset, pythonic::dispatch::bor__list__ordereddict, pythonic::dispatch::bor__list__graph};
    t[13] = {pythonic::dispatch::bor__set__none, pythonic::dispatch::bor__set__int, pythonic::dispatch::bor__set__float, pythonic::dispatch::bor__set__string, pythonic::dispatch::bor__set__bool, pythonic::dispatch::bor__set__double, pythonic::dispatch::bor__set__long, pythonic::dispatch::bor__set__long_long, pythonic::dispatch::bor__set__long_double, pythonic::dispatch::bor__set__uint, pythonic::dispatch::bor__set__ulong, pythonic::dispatch::bor__set__ulong_long, pythonic::dispatch::bor__set__list, pythonic::dispatch::bor__set__set, pythonic::dispatch::bor__set__dict, pythonic::dispatch::bor__set__orderedset, pythonic::dispatch::bor__set__ordereddict, pythonic::dispatch::bor__set__graph};
    t[14] = {pythonic::dispatch::bor__dict__none, pythonic::dispatch::bor__dict__int, pythonic::dispatch::bor__dict__float, pythonic::dispatch::bor__dict__string, pythonic::dispatch::bor__dict__bool, pythonic::dispatch::bor__dict__double, pythonic::dispatch::bor__dict__long, pythonic::dispatch::bor__dict__long_long, pythonic::dispatch::bor__dict__long_double, pythonic::dispatch::bor__dict__uint, pythonic::dispatch::bor__dict__ulong, pythonic::dispatch::bor__dict__ulong_long, pythonic::dispatch::bor__dict__list, pythonic::dispatch::bor__dict__set, pythonic::dispatch::bor__dict__dict, pythonic::dispatch::bor__dict__orderedset, pythonic::dispatch::bor__dict__ordereddict, pythonic::dispatch::bor__dict__graph};
    t[15] = {pythonic::dispatch::bor__orderedset__none, pythonic::dispatch::bor__orderedset__int, pythonic::dispatch::bor__orderedset__float, pythonic::dispatch::bor__orderedset__string, pythonic::dispatch::bor__orderedset__bool, pythonic::dispatch::bor__orderedset__double, pythonic::dispatch::bor__orderedset__long, pythonic::dispatch::bor__orderedset__long_long, pythonic::dispatch::bor__orderedset__long_double, pythonic::dispatch::bor__orderedset__uint, pythonic::dispatch::bor__orderedset__ulong, pythonic::dispatch::bor__orderedset__ulong_long, pythonic::dispatch::bor__orderedset__list, pythonic::dispatch::bor__orderedset__set, pythonic::dispatch::bor__orderedset__dict, pythonic::dispatch::bor__orderedset__orderedset, pythonic::dispatch::bor__orderedset__ordereddict, pythonic::dispatch::bor__orderedset__graph};
    t[16] = {pythonic::dispatch::bor__ordereddict__none, pythonic::dispatch::bor__ordereddict__int, pythonic::dispatch::bor__ordereddict__float, pythonic::dispatch::bor__ordereddict__string, pythonic::dispatch::bor__ordereddict__bool, pythonic::dispatch::bor__ordereddict__double, pythonic::dispatch::bor__ordereddict__long, pythonic::dispatch::bor__ordereddict__long_long, pythonic::dispatch::bor__ordereddict__long_double, pythonic::dispatch::bor__ordereddict__uint, pythonic::dispatch::bor__ordereddict__ulong, pythonic::dispatch::bor__ordereddict__ulong_long, pythonic::dispatch::bor__ordereddict__list, pythonic::dispatch::bor__ordereddict__set, pythonic::dispatch::bor__ordereddict__dict, pythonic::dispatch::bor__ordereddict__orderedset, pythonic::dispatch::bor__ordereddict__ordereddict, pythonic::dispatch::bor__ordereddict__graph};
    t[17] = {pythonic::dispatch::bor__graph__none, pythonic::dispatch::bor__graph__int, pythonic::dispatch::bor__graph__float, pythonic::dispatch::bor__graph__string, pythonic::dispatch::bor__graph__bool, pythonic::dispatch::bor__graph__double, pythonic::dispatch::bor__graph__long, pythonic::dispatch::bor__graph__long_long, pythonic::dispatch::bor__graph__long_double, pythonic::dispatch::bor__graph__uint, pythonic::dispatch::bor__graph__ulong, pythonic::dispatch::bor__graph__ulong_long, pythonic::dispatch::bor__graph__list, pythonic::dispatch::bor__graph__set, pythonic::dispatch::bor__graph__dict, pythonic::dispatch::bor__graph__orderedset, pythonic::dispatch::bor__graph__ordereddict, pythonic::dispatch::bor__graph__graph};
    return t;
}();

// OpTable initialization for BitXor
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::BitXor>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::bxor__none__none, pythonic::dispatch::bxor__none__int, pythonic::dispatch::bxor__none__float, pythonic::dispatch::bxor__none__string, pythonic::dispatch::bxor__none__bool, pythonic::dispatch::bxor__none__double, pythonic::dispatch::bxor__none__long, pythonic::dispatch::bxor__none__long_long, pythonic::dispatch::bxor__none__long_double, pythonic::dispatch::bxor__none__uint, pythonic::dispatch::bxor__none__ulong, pythonic::dispatch::bxor__none__ulong_long, pythonic::dispatch::bxor__none__list, pythonic::dispatch::bxor__none__set, pythonic::dispatch::bxor__none__dict, pythonic::dispatch::bxor__none__orderedset, pythonic::dispatch::bxor__none__ordereddict, pythonic::dispatch::bxor__none__graph};
    t[1] = {pythonic::dispatch::bxor__int__none, pythonic::dispatch::bxor__int__int, pythonic::dispatch::bxor__int__float, pythonic::dispatch::bxor__int__string, pythonic::dispatch::bxor__int__bool, pythonic::dispatch::bxor__int__double, pythonic::dispatch::bxor__int__long, pythonic::dispatch::bxor__int__long_long, pythonic::dispatch::bxor__int__long_double, pythonic::dispatch::bxor__int__uint, pythonic::dispatch::bxor__int__ulong, pythonic::dispatch::bxor__int__ulong_long, pythonic::dispatch::bxor__int__list, pythonic::dispatch::bxor__int__set, pythonic::dispatch::bxor__int__dict, pythonic::dispatch::bxor__int__orderedset, pythonic::dispatch::bxor__int__ordereddict, pythonic::dispatch::bxor__int__graph};
    t[2] = {pythonic::dispatch::bxor__float__none, pythonic::dispatch::bxor__float__int, pythonic::dispatch::bxor__float__float, pythonic::dispatch::bxor__float__string, pythonic::dispatch::bxor__float__bool, pythonic::dispatch::bxor__float__double, pythonic::dispatch::bxor__float__long, pythonic::dispatch::bxor__float__long_long, pythonic::dispatch::bxor__float__long_double, pythonic::dispatch::bxor__float__uint, pythonic::dispatch::bxor__float__ulong, pythonic::dispatch::bxor__float__ulong_long, pythonic::dispatch::bxor__float__list, pythonic::dispatch::bxor__float__set, pythonic::dispatch::bxor__float__dict, pythonic::dispatch::bxor__float__orderedset, pythonic::dispatch::bxor__float__ordereddict, pythonic::dispatch::bxor__float__graph};
    t[3] = {pythonic::dispatch::bxor__string__none, pythonic::dispatch::bxor__string__int, pythonic::dispatch::bxor__string__float, pythonic::dispatch::bxor__string__string, pythonic::dispatch::bxor__string__bool, pythonic::dispatch::bxor__string__double, pythonic::dispatch::bxor__string__long, pythonic::dispatch::bxor__string__long_long, pythonic::dispatch::bxor__string__long_double, pythonic::dispatch::bxor__string__uint, pythonic::dispatch::bxor__string__ulong, pythonic::dispatch::bxor__string__ulong_long, pythonic::dispatch::bxor__string__list, pythonic::dispatch::bxor__string__set, pythonic::dispatch::bxor__string__dict, pythonic::dispatch::bxor__string__orderedset, pythonic::dispatch::bxor__string__ordereddict, pythonic::dispatch::bxor__string__graph};
    t[4] = {pythonic::dispatch::bxor__bool__none, pythonic::dispatch::bxor__bool__int, pythonic::dispatch::bxor__bool__float, pythonic::dispatch::bxor__bool__string, pythonic::dispatch::bxor__bool__bool, pythonic::dispatch::bxor__bool__double, pythonic::dispatch::bxor__bool__long, pythonic::dispatch::bxor__bool__long_long, pythonic::dispatch::bxor__bool__long_double, pythonic::dispatch::bxor__bool__uint, pythonic::dispatch::bxor__bool__ulong, pythonic::dispatch::bxor__bool__ulong_long, pythonic::dispatch::bxor__bool__list, pythonic::dispatch::bxor__bool__set, pythonic::dispatch::bxor__bool__dict, pythonic::dispatch::bxor__bool__orderedset, pythonic::dispatch::bxor__bool__ordereddict, pythonic::dispatch::bxor__bool__graph};
    t[5] = {pythonic::dispatch::bxor__double__none, pythonic::dispatch::bxor__double__int, pythonic::dispatch::bxor__double__float, pythonic::dispatch::bxor__double__string, pythonic::dispatch::bxor__double__bool, pythonic::dispatch::bxor__double__double, pythonic::dispatch::bxor__double__long, pythonic::dispatch::bxor__double__long_long, pythonic::dispatch::bxor__double__long_double, pythonic::dispatch::bxor__double__uint, pythonic::dispatch::bxor__double__ulong, pythonic::dispatch::bxor__double__ulong_long, pythonic::dispatch::bxor__double__list, pythonic::dispatch::bxor__double__set, pythonic::dispatch::bxor__double__dict, pythonic::dispatch::bxor__double__orderedset, pythonic::dispatch::bxor__double__ordereddict, pythonic::dispatch::bxor__double__graph};
    t[6] = {pythonic::dispatch::bxor__long__none, pythonic::dispatch::bxor__long__int, pythonic::dispatch::bxor__long__float, pythonic::dispatch::bxor__long__string, pythonic::dispatch::bxor__long__bool, pythonic::dispatch::bxor__long__double, pythonic::dispatch::bxor__long__long, pythonic::dispatch::bxor__long__long_long, pythonic::dispatch::bxor__long__long_double, pythonic::dispatch::bxor__long__uint, pythonic::dispatch::bxor__long__ulong, pythonic::dispatch::bxor__long__ulong_long, pythonic::dispatch::bxor__long__list, pythonic::dispatch::bxor__long__set, pythonic::dispatch::bxor__long__dict, pythonic::dispatch::bxor__long__orderedset, pythonic::dispatch::bxor__long__ordereddict, pythonic::dispatch::bxor__long__graph};
    t[7] = {pythonic::dispatch::bxor__long_long__none, pythonic::dispatch::bxor__long_long__int, pythonic::dispatch::bxor__long_long__float, pythonic::dispatch::bxor__long_long__string, pythonic::dispatch::bxor__long_long__bool, pythonic::dispatch::bxor__long_long__double, pythonic::dispatch::bxor__long_long__long, pythonic::dispatch::bxor__long_long__long_long, pythonic::dispatch::bxor__long_long__long_double, pythonic::dispatch::bxor__long_long__uint, pythonic::dispatch::bxor__long_long__ulong, pythonic::dispatch::bxor__long_long__ulong_long, pythonic::dispatch::bxor__long_long__list, pythonic::dispatch::bxor__long_long__set, pythonic::dispatch::bxor__long_long__dict, pythonic::dispatch::bxor__long_long__orderedset, pythonic::dispatch::bxor__long_long__ordereddict, pythonic::dispatch::bxor__long_long__graph};
    t[8] = {pythonic::dispatch::bxor__long_double__none, pythonic::dispatch::bxor__long_double__int, pythonic::dispatch::bxor__long_double__float, pythonic::dispatch::bxor__long_double__string, pythonic::dispatch::bxor__long_double__bool, pythonic::dispatch::bxor__long_double__double, pythonic::dispatch::bxor__long_double__long, pythonic::dispatch::bxor__long_double__long_long, pythonic::dispatch::bxor__long_double__long_double, pythonic::dispatch::bxor__long_double__uint, pythonic::dispatch::bxor__long_double__ulong, pythonic::dispatch::bxor__long_double__ulong_long, pythonic::dispatch::bxor__long_double__list, pythonic::dispatch::bxor__long_double__set, pythonic::dispatch::bxor__long_double__dict, pythonic::dispatch::bxor__long_double__orderedset, pythonic::dispatch::bxor__long_double__ordereddict, pythonic::dispatch::bxor__long_double__graph};
    t[9] = {pythonic::dispatch::bxor__uint__none, pythonic::dispatch::bxor__uint__int, pythonic::dispatch::bxor__uint__float, pythonic::dispatch::bxor__uint__string, pythonic::dispatch::bxor__uint__bool, pythonic::dispatch::bxor__uint__double, pythonic::dispatch::bxor__uint__long, pythonic::dispatch::bxor__uint__long_long, pythonic::dispatch::bxor__uint__long_double, pythonic::dispatch::bxor__uint__uint, pythonic::dispatch::bxor__uint__ulong, pythonic::dispatch::bxor__uint__ulong_long, pythonic::dispatch::bxor__uint__list, pythonic::dispatch::bxor__uint__set, pythonic::dispatch::bxor__uint__dict, pythonic::dispatch::bxor__uint__orderedset, pythonic::dispatch::bxor__uint__ordereddict, pythonic::dispatch::bxor__uint__graph};
    t[10] = {pythonic::dispatch::bxor__ulong__none, pythonic::dispatch::bxor__ulong__int, pythonic::dispatch::bxor__ulong__float, pythonic::dispatch::bxor__ulong__string, pythonic::dispatch::bxor__ulong__bool, pythonic::dispatch::bxor__ulong__double, pythonic::dispatch::bxor__ulong__long, pythonic::dispatch::bxor__ulong__long_long, pythonic::dispatch::bxor__ulong__long_double, pythonic::dispatch::bxor__ulong__uint, pythonic::dispatch::bxor__ulong__ulong, pythonic::dispatch::bxor__ulong__ulong_long, pythonic::dispatch::bxor__ulong__list, pythonic::dispatch::bxor__ulong__set, pythonic::dispatch::bxor__ulong__dict, pythonic::dispatch::bxor__ulong__orderedset, pythonic::dispatch::bxor__ulong__ordereddict, pythonic::dispatch::bxor__ulong__graph};
    t[11] = {pythonic::dispatch::bxor__ulong_long__none, pythonic::dispatch::bxor__ulong_long__int, pythonic::dispatch::bxor__ulong_long__float, pythonic::dispatch::bxor__ulong_long__string, pythonic::dispatch::bxor__ulong_long__bool, pythonic::dispatch::bxor__ulong_long__double, pythonic::dispatch::bxor__ulong_long__long, pythonic::dispatch::bxor__ulong_long__long_long, pythonic::dispatch::bxor__ulong_long__long_double, pythonic::dispatch::bxor__ulong_long__uint, pythonic::dispatch::bxor__ulong_long__ulong, pythonic::dispatch::bxor__ulong_long__ulong_long, pythonic::dispatch::bxor__ulong_long__list, pythonic::dispatch::bxor__ulong_long__set, pythonic::dispatch::bxor__ulong_long__dict, pythonic::dispatch::bxor__ulong_long__orderedset, pythonic::dispatch::bxor__ulong_long__ordereddict, pythonic::dispatch::bxor__ulong_long__graph};
    t[12] = {pythonic::dispatch::bxor__list__none, pythonic::dispatch::bxor__list__int, pythonic::dispatch::bxor__list__float, pythonic::dispatch::bxor__list__string, pythonic::dispatch::bxor__list__bool, pythonic::dispatch::bxor__list__double, pythonic::dispatch::bxor__list__long, pythonic::dispatch::bxor__list__long_long, pythonic::dispatch::bxor__list__long_double, pythonic::dispatch::bxor__list__uint, pythonic::dispatch::bxor__list__ulong, pythonic::dispatch::bxor__list__ulong_long, pythonic::dispatch::bxor__list__list, pythonic::dispatch::bxor__list__set, pythonic::dispatch::bxor__list__dict, pythonic::dispatch::bxor__list__orderedset, pythonic::dispatch::bxor__list__ordereddict, pythonic::dispatch::bxor__list__graph};
    t[13] = {pythonic::dispatch::bxor__set__none, pythonic::dispatch::bxor__set__int, pythonic::dispatch::bxor__set__float, pythonic::dispatch::bxor__set__string, pythonic::dispatch::bxor__set__bool, pythonic::dispatch::bxor__set__double, pythonic::dispatch::bxor__set__long, pythonic::dispatch::bxor__set__long_long, pythonic::dispatch::bxor__set__long_double, pythonic::dispatch::bxor__set__uint, pythonic::dispatch::bxor__set__ulong, pythonic::dispatch::bxor__set__ulong_long, pythonic::dispatch::bxor__set__list, pythonic::dispatch::bxor__set__set, pythonic::dispatch::bxor__set__dict, pythonic::dispatch::bxor__set__orderedset, pythonic::dispatch::bxor__set__ordereddict, pythonic::dispatch::bxor__set__graph};
    t[14] = {pythonic::dispatch::bxor__dict__none, pythonic::dispatch::bxor__dict__int, pythonic::dispatch::bxor__dict__float, pythonic::dispatch::bxor__dict__string, pythonic::dispatch::bxor__dict__bool, pythonic::dispatch::bxor__dict__double, pythonic::dispatch::bxor__dict__long, pythonic::dispatch::bxor__dict__long_long, pythonic::dispatch::bxor__dict__long_double, pythonic::dispatch::bxor__dict__uint, pythonic::dispatch::bxor__dict__ulong, pythonic::dispatch::bxor__dict__ulong_long, pythonic::dispatch::bxor__dict__list, pythonic::dispatch::bxor__dict__set, pythonic::dispatch::bxor__dict__dict, pythonic::dispatch::bxor__dict__orderedset, pythonic::dispatch::bxor__dict__ordereddict, pythonic::dispatch::bxor__dict__graph};
    t[15] = {pythonic::dispatch::bxor__orderedset__none, pythonic::dispatch::bxor__orderedset__int, pythonic::dispatch::bxor__orderedset__float, pythonic::dispatch::bxor__orderedset__string, pythonic::dispatch::bxor__orderedset__bool, pythonic::dispatch::bxor__orderedset__double, pythonic::dispatch::bxor__orderedset__long, pythonic::dispatch::bxor__orderedset__long_long, pythonic::dispatch::bxor__orderedset__long_double, pythonic::dispatch::bxor__orderedset__uint, pythonic::dispatch::bxor__orderedset__ulong, pythonic::dispatch::bxor__orderedset__ulong_long, pythonic::dispatch::bxor__orderedset__list, pythonic::dispatch::bxor__orderedset__set, pythonic::dispatch::bxor__orderedset__dict, pythonic::dispatch::bxor__orderedset__orderedset, pythonic::dispatch::bxor__orderedset__ordereddict, pythonic::dispatch::bxor__orderedset__graph};
    t[16] = {pythonic::dispatch::bxor__ordereddict__none, pythonic::dispatch::bxor__ordereddict__int, pythonic::dispatch::bxor__ordereddict__float, pythonic::dispatch::bxor__ordereddict__string, pythonic::dispatch::bxor__ordereddict__bool, pythonic::dispatch::bxor__ordereddict__double, pythonic::dispatch::bxor__ordereddict__long, pythonic::dispatch::bxor__ordereddict__long_long, pythonic::dispatch::bxor__ordereddict__long_double, pythonic::dispatch::bxor__ordereddict__uint, pythonic::dispatch::bxor__ordereddict__ulong, pythonic::dispatch::bxor__ordereddict__ulong_long, pythonic::dispatch::bxor__ordereddict__list, pythonic::dispatch::bxor__ordereddict__set, pythonic::dispatch::bxor__ordereddict__dict, pythonic::dispatch::bxor__ordereddict__orderedset, pythonic::dispatch::bxor__ordereddict__ordereddict, pythonic::dispatch::bxor__ordereddict__graph};
    t[17] = {pythonic::dispatch::bxor__graph__none, pythonic::dispatch::bxor__graph__int, pythonic::dispatch::bxor__graph__float, pythonic::dispatch::bxor__graph__string, pythonic::dispatch::bxor__graph__bool, pythonic::dispatch::bxor__graph__double, pythonic::dispatch::bxor__graph__long, pythonic::dispatch::bxor__graph__long_long, pythonic::dispatch::bxor__graph__long_double, pythonic::dispatch::bxor__graph__uint, pythonic::dispatch::bxor__graph__ulong, pythonic::dispatch::bxor__graph__ulong_long, pythonic::dispatch::bxor__graph__list, pythonic::dispatch::bxor__graph__set, pythonic::dispatch::bxor__graph__dict, pythonic::dispatch::bxor__graph__orderedset, pythonic::dispatch::bxor__graph__ordereddict, pythonic::dispatch::bxor__graph__graph};
    return t;
}();

// OpTable initialization for ShiftLeft
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::ShiftLeft>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::shl__none__none, pythonic::dispatch::shl__none__int, pythonic::dispatch::shl__none__float, pythonic::dispatch::shl__none__string, pythonic::dispatch::shl__none__bool, pythonic::dispatch::shl__none__double, pythonic::dispatch::shl__none__long, pythonic::dispatch::shl__none__long_long, pythonic::dispatch::shl__none__long_double, pythonic::dispatch::shl__none__uint, pythonic::dispatch::shl__none__ulong, pythonic::dispatch::shl__none__ulong_long, pythonic::dispatch::shl__none__list, pythonic::dispatch::shl__none__set, pythonic::dispatch::shl__none__dict, pythonic::dispatch::shl__none__orderedset, pythonic::dispatch::shl__none__ordereddict, pythonic::dispatch::shl__none__graph};
    t[1] = {pythonic::dispatch::shl__int__none, pythonic::dispatch::shl__int__int, pythonic::dispatch::shl__int__float, pythonic::dispatch::shl__int__string, pythonic::dispatch::shl__int__bool, pythonic::dispatch::shl__int__double, pythonic::dispatch::shl__int__long, pythonic::dispatch::shl__int__long_long, pythonic::dispatch::shl__int__long_double, pythonic::dispatch::shl__int__uint, pythonic::dispatch::shl__int__ulong, pythonic::dispatch::shl__int__ulong_long, pythonic::dispatch::shl__int__list, pythonic::dispatch::shl__int__set, pythonic::dispatch::shl__int__dict, pythonic::dispatch::shl__int__orderedset, pythonic::dispatch::shl__int__ordereddict, pythonic::dispatch::shl__int__graph};
    t[2] = {pythonic::dispatch::shl__float__none, pythonic::dispatch::shl__float__int, pythonic::dispatch::shl__float__float, pythonic::dispatch::shl__float__string, pythonic::dispatch::shl__float__bool, pythonic::dispatch::shl__float__double, pythonic::dispatch::shl__float__long, pythonic::dispatch::shl__float__long_long, pythonic::dispatch::shl__float__long_double, pythonic::dispatch::shl__float__uint, pythonic::dispatch::shl__float__ulong, pythonic::dispatch::shl__float__ulong_long, pythonic::dispatch::shl__float__list, pythonic::dispatch::shl__float__set, pythonic::dispatch::shl__float__dict, pythonic::dispatch::shl__float__orderedset, pythonic::dispatch::shl__float__ordereddict, pythonic::dispatch::shl__float__graph};
    t[3] = {pythonic::dispatch::shl__string__none, pythonic::dispatch::shl__string__int, pythonic::dispatch::shl__string__float, pythonic::dispatch::shl__string__string, pythonic::dispatch::shl__string__bool, pythonic::dispatch::shl__string__double, pythonic::dispatch::shl__string__long, pythonic::dispatch::shl__string__long_long, pythonic::dispatch::shl__string__long_double, pythonic::dispatch::shl__string__uint, pythonic::dispatch::shl__string__ulong, pythonic::dispatch::shl__string__ulong_long, pythonic::dispatch::shl__string__list, pythonic::dispatch::shl__string__set, pythonic::dispatch::shl__string__dict, pythonic::dispatch::shl__string__orderedset, pythonic::dispatch::shl__string__ordereddict, pythonic::dispatch::shl__string__graph};
    t[4] = {pythonic::dispatch::shl__bool__none, pythonic::dispatch::shl__bool__int, pythonic::dispatch::shl__bool__float, pythonic::dispatch::shl__bool__string, pythonic::dispatch::shl__bool__bool, pythonic::dispatch::shl__bool__double, pythonic::dispatch::shl__bool__long, pythonic::dispatch::shl__bool__long_long, pythonic::dispatch::shl__bool__long_double, pythonic::dispatch::shl__bool__uint, pythonic::dispatch::shl__bool__ulong, pythonic::dispatch::shl__bool__ulong_long, pythonic::dispatch::shl__bool__list, pythonic::dispatch::shl__bool__set, pythonic::dispatch::shl__bool__dict, pythonic::dispatch::shl__bool__orderedset, pythonic::dispatch::shl__bool__ordereddict, pythonic::dispatch::shl__bool__graph};
    t[5] = {pythonic::dispatch::shl__double__none, pythonic::dispatch::shl__double__int, pythonic::dispatch::shl__double__float, pythonic::dispatch::shl__double__string, pythonic::dispatch::shl__double__bool, pythonic::dispatch::shl__double__double, pythonic::dispatch::shl__double__long, pythonic::dispatch::shl__double__long_long, pythonic::dispatch::shl__double__long_double, pythonic::dispatch::shl__double__uint, pythonic::dispatch::shl__double__ulong, pythonic::dispatch::shl__double__ulong_long, pythonic::dispatch::shl__double__list, pythonic::dispatch::shl__double__set, pythonic::dispatch::shl__double__dict, pythonic::dispatch::shl__double__orderedset, pythonic::dispatch::shl__double__ordereddict, pythonic::dispatch::shl__double__graph};
    t[6] = {pythonic::dispatch::shl__long__none, pythonic::dispatch::shl__long__int, pythonic::dispatch::shl__long__float, pythonic::dispatch::shl__long__string, pythonic::dispatch::shl__long__bool, pythonic::dispatch::shl__long__double, pythonic::dispatch::shl__long__long, pythonic::dispatch::shl__long__long_long, pythonic::dispatch::shl__long__long_double, pythonic::dispatch::shl__long__uint, pythonic::dispatch::shl__long__ulong, pythonic::dispatch::shl__long__ulong_long, pythonic::dispatch::shl__long__list, pythonic::dispatch::shl__long__set, pythonic::dispatch::shl__long__dict, pythonic::dispatch::shl__long__orderedset, pythonic::dispatch::shl__long__ordereddict, pythonic::dispatch::shl__long__graph};
    t[7] = {pythonic::dispatch::shl__long_long__none, pythonic::dispatch::shl__long_long__int, pythonic::dispatch::shl__long_long__float, pythonic::dispatch::shl__long_long__string, pythonic::dispatch::shl__long_long__bool, pythonic::dispatch::shl__long_long__double, pythonic::dispatch::shl__long_long__long, pythonic::dispatch::shl__long_long__long_long, pythonic::dispatch::shl__long_long__long_double, pythonic::dispatch::shl__long_long__uint, pythonic::dispatch::shl__long_long__ulong, pythonic::dispatch::shl__long_long__ulong_long, pythonic::dispatch::shl__long_long__list, pythonic::dispatch::shl__long_long__set, pythonic::dispatch::shl__long_long__dict, pythonic::dispatch::shl__long_long__orderedset, pythonic::dispatch::shl__long_long__ordereddict, pythonic::dispatch::shl__long_long__graph};
    t[8] = {pythonic::dispatch::shl__long_double__none, pythonic::dispatch::shl__long_double__int, pythonic::dispatch::shl__long_double__float, pythonic::dispatch::shl__long_double__string, pythonic::dispatch::shl__long_double__bool, pythonic::dispatch::shl__long_double__double, pythonic::dispatch::shl__long_double__long, pythonic::dispatch::shl__long_double__long_long, pythonic::dispatch::shl__long_double__long_double, pythonic::dispatch::shl__long_double__uint, pythonic::dispatch::shl__long_double__ulong, pythonic::dispatch::shl__long_double__ulong_long, pythonic::dispatch::shl__long_double__list, pythonic::dispatch::shl__long_double__set, pythonic::dispatch::shl__long_double__dict, pythonic::dispatch::shl__long_double__orderedset, pythonic::dispatch::shl__long_double__ordereddict, pythonic::dispatch::shl__long_double__graph};
    t[9] = {pythonic::dispatch::shl__uint__none, pythonic::dispatch::shl__uint__int, pythonic::dispatch::shl__uint__float, pythonic::dispatch::shl__uint__string, pythonic::dispatch::shl__uint__bool, pythonic::dispatch::shl__uint__double, pythonic::dispatch::shl__uint__long, pythonic::dispatch::shl__uint__long_long, pythonic::dispatch::shl__uint__long_double, pythonic::dispatch::shl__uint__uint, pythonic::dispatch::shl__uint__ulong, pythonic::dispatch::shl__uint__ulong_long, pythonic::dispatch::shl__uint__list, pythonic::dispatch::shl__uint__set, pythonic::dispatch::shl__uint__dict, pythonic::dispatch::shl__uint__orderedset, pythonic::dispatch::shl__uint__ordereddict, pythonic::dispatch::shl__uint__graph};
    t[10] = {pythonic::dispatch::shl__ulong__none, pythonic::dispatch::shl__ulong__int, pythonic::dispatch::shl__ulong__float, pythonic::dispatch::shl__ulong__string, pythonic::dispatch::shl__ulong__bool, pythonic::dispatch::shl__ulong__double, pythonic::dispatch::shl__ulong__long, pythonic::dispatch::shl__ulong__long_long, pythonic::dispatch::shl__ulong__long_double, pythonic::dispatch::shl__ulong__uint, pythonic::dispatch::shl__ulong__ulong, pythonic::dispatch::shl__ulong__ulong_long, pythonic::dispatch::shl__ulong__list, pythonic::dispatch::shl__ulong__set, pythonic::dispatch::shl__ulong__dict, pythonic::dispatch::shl__ulong__orderedset, pythonic::dispatch::shl__ulong__ordereddict, pythonic::dispatch::shl__ulong__graph};
    t[11] = {pythonic::dispatch::shl__ulong_long__none, pythonic::dispatch::shl__ulong_long__int, pythonic::dispatch::shl__ulong_long__float, pythonic::dispatch::shl__ulong_long__string, pythonic::dispatch::shl__ulong_long__bool, pythonic::dispatch::shl__ulong_long__double, pythonic::dispatch::shl__ulong_long__long, pythonic::dispatch::shl__ulong_long__long_long, pythonic::dispatch::shl__ulong_long__long_double, pythonic::dispatch::shl__ulong_long__uint, pythonic::dispatch::shl__ulong_long__ulong, pythonic::dispatch::shl__ulong_long__ulong_long, pythonic::dispatch::shl__ulong_long__list, pythonic::dispatch::shl__ulong_long__set, pythonic::dispatch::shl__ulong_long__dict, pythonic::dispatch::shl__ulong_long__orderedset, pythonic::dispatch::shl__ulong_long__ordereddict, pythonic::dispatch::shl__ulong_long__graph};
    t[12] = {pythonic::dispatch::shl__list__none, pythonic::dispatch::shl__list__int, pythonic::dispatch::shl__list__float, pythonic::dispatch::shl__list__string, pythonic::dispatch::shl__list__bool, pythonic::dispatch::shl__list__double, pythonic::dispatch::shl__list__long, pythonic::dispatch::shl__list__long_long, pythonic::dispatch::shl__list__long_double, pythonic::dispatch::shl__list__uint, pythonic::dispatch::shl__list__ulong, pythonic::dispatch::shl__list__ulong_long, pythonic::dispatch::shl__list__list, pythonic::dispatch::shl__list__set, pythonic::dispatch::shl__list__dict, pythonic::dispatch::shl__list__orderedset, pythonic::dispatch::shl__list__ordereddict, pythonic::dispatch::shl__list__graph};
    t[13] = {pythonic::dispatch::shl__set__none, pythonic::dispatch::shl__set__int, pythonic::dispatch::shl__set__float, pythonic::dispatch::shl__set__string, pythonic::dispatch::shl__set__bool, pythonic::dispatch::shl__set__double, pythonic::dispatch::shl__set__long, pythonic::dispatch::shl__set__long_long, pythonic::dispatch::shl__set__long_double, pythonic::dispatch::shl__set__uint, pythonic::dispatch::shl__set__ulong, pythonic::dispatch::shl__set__ulong_long, pythonic::dispatch::shl__set__list, pythonic::dispatch::shl__set__set, pythonic::dispatch::shl__set__dict, pythonic::dispatch::shl__set__orderedset, pythonic::dispatch::shl__set__ordereddict, pythonic::dispatch::shl__set__graph};
    t[14] = {pythonic::dispatch::shl__dict__none, pythonic::dispatch::shl__dict__int, pythonic::dispatch::shl__dict__float, pythonic::dispatch::shl__dict__string, pythonic::dispatch::shl__dict__bool, pythonic::dispatch::shl__dict__double, pythonic::dispatch::shl__dict__long, pythonic::dispatch::shl__dict__long_long, pythonic::dispatch::shl__dict__long_double, pythonic::dispatch::shl__dict__uint, pythonic::dispatch::shl__dict__ulong, pythonic::dispatch::shl__dict__ulong_long, pythonic::dispatch::shl__dict__list, pythonic::dispatch::shl__dict__set, pythonic::dispatch::shl__dict__dict, pythonic::dispatch::shl__dict__orderedset, pythonic::dispatch::shl__dict__ordereddict, pythonic::dispatch::shl__dict__graph};
    t[15] = {pythonic::dispatch::shl__orderedset__none, pythonic::dispatch::shl__orderedset__int, pythonic::dispatch::shl__orderedset__float, pythonic::dispatch::shl__orderedset__string, pythonic::dispatch::shl__orderedset__bool, pythonic::dispatch::shl__orderedset__double, pythonic::dispatch::shl__orderedset__long, pythonic::dispatch::shl__orderedset__long_long, pythonic::dispatch::shl__orderedset__long_double, pythonic::dispatch::shl__orderedset__uint, pythonic::dispatch::shl__orderedset__ulong, pythonic::dispatch::shl__orderedset__ulong_long, pythonic::dispatch::shl__orderedset__list, pythonic::dispatch::shl__orderedset__set, pythonic::dispatch::shl__orderedset__dict, pythonic::dispatch::shl__orderedset__orderedset, pythonic::dispatch::shl__orderedset__ordereddict, pythonic::dispatch::shl__orderedset__graph};
    t[16] = {pythonic::dispatch::shl__ordereddict__none, pythonic::dispatch::shl__ordereddict__int, pythonic::dispatch::shl__ordereddict__float, pythonic::dispatch::shl__ordereddict__string, pythonic::dispatch::shl__ordereddict__bool, pythonic::dispatch::shl__ordereddict__double, pythonic::dispatch::shl__ordereddict__long, pythonic::dispatch::shl__ordereddict__long_long, pythonic::dispatch::shl__ordereddict__long_double, pythonic::dispatch::shl__ordereddict__uint, pythonic::dispatch::shl__ordereddict__ulong, pythonic::dispatch::shl__ordereddict__ulong_long, pythonic::dispatch::shl__ordereddict__list, pythonic::dispatch::shl__ordereddict__set, pythonic::dispatch::shl__ordereddict__dict, pythonic::dispatch::shl__ordereddict__orderedset, pythonic::dispatch::shl__ordereddict__ordereddict, pythonic::dispatch::shl__ordereddict__graph};
    t[17] = {pythonic::dispatch::shl__graph__none, pythonic::dispatch::shl__graph__int, pythonic::dispatch::shl__graph__float, pythonic::dispatch::shl__graph__string, pythonic::dispatch::shl__graph__bool, pythonic::dispatch::shl__graph__double, pythonic::dispatch::shl__graph__long, pythonic::dispatch::shl__graph__long_long, pythonic::dispatch::shl__graph__long_double, pythonic::dispatch::shl__graph__uint, pythonic::dispatch::shl__graph__ulong, pythonic::dispatch::shl__graph__ulong_long, pythonic::dispatch::shl__graph__list, pythonic::dispatch::shl__graph__set, pythonic::dispatch::shl__graph__dict, pythonic::dispatch::shl__graph__orderedset, pythonic::dispatch::shl__graph__ordereddict, pythonic::dispatch::shl__graph__graph};
    return t;
}();

// OpTable initialization for ShiftRight
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::ShiftRight>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::shr__none__none, pythonic::dispatch::shr__none__int, pythonic::dispatch::shr__none__float, pythonic::dispatch::shr__none__string, pythonic::dispatch::shr__none__bool, pythonic::dispatch::shr__none__double, pythonic::dispatch::shr__none__long, pythonic::dispatch::shr__none__long_long, pythonic::dispatch::shr__none__long_double, pythonic::dispatch::shr__none__uint, pythonic::dispatch::shr__none__ulong, pythonic::dispatch::shr__none__ulong_long, pythonic::dispatch::shr__none__list, pythonic::dispatch::shr__none__set, pythonic::dispatch::shr__none__dict, pythonic::dispatch::shr__none__orderedset, pythonic::dispatch::shr__none__ordereddict, pythonic::dispatch::shr__none__graph};
    t[1] = {pythonic::dispatch::shr__int__none, pythonic::dispatch::shr__int__int, pythonic::dispatch::shr__int__float, pythonic::dispatch::shr__int__string, pythonic::dispatch::shr__int__bool, pythonic::dispatch::shr__int__double, pythonic::dispatch::shr__int__long, pythonic::dispatch::shr__int__long_long, pythonic::dispatch::shr__int__long_double, pythonic::dispatch::shr__int__uint, pythonic::dispatch::shr__int__ulong, pythonic::dispatch::shr__int__ulong_long, pythonic::dispatch::shr__int__list, pythonic::dispatch::shr__int__set, pythonic::dispatch::shr__int__dict, pythonic::dispatch::shr__int__orderedset, pythonic::dispatch::shr__int__ordereddict, pythonic::dispatch::shr__int__graph};
    t[2] = {pythonic::dispatch::shr__float__none, pythonic::dispatch::shr__float__int, pythonic::dispatch::shr__float__float, pythonic::dispatch::shr__float__string, pythonic::dispatch::shr__float__bool, pythonic::dispatch::shr__float__double, pythonic::dispatch::shr__float__long, pythonic::dispatch::shr__float__long_long, pythonic::dispatch::shr__float__long_double, pythonic::dispatch::shr__float__uint, pythonic::dispatch::shr__float__ulong, pythonic::dispatch::shr__float__ulong_long, pythonic::dispatch::shr__float__list, pythonic::dispatch::shr__float__set, pythonic::dispatch::shr__float__dict, pythonic::dispatch::shr__float__orderedset, pythonic::dispatch::shr__float__ordereddict, pythonic::dispatch::shr__float__graph};
    t[3] = {pythonic::dispatch::shr__string__none, pythonic::dispatch::shr__string__int, pythonic::dispatch::shr__string__float, pythonic::dispatch::shr__string__string, pythonic::dispatch::shr__string__bool, pythonic::dispatch::shr__string__double, pythonic::dispatch::shr__string__long, pythonic::dispatch::shr__string__long_long, pythonic::dispatch::shr__string__long_double, pythonic::dispatch::shr__string__uint, pythonic::dispatch::shr__string__ulong, pythonic::dispatch::shr__string__ulong_long, pythonic::dispatch::shr__string__list, pythonic::dispatch::shr__string__set, pythonic::dispatch::shr__string__dict, pythonic::dispatch::shr__string__orderedset, pythonic::dispatch::shr__string__ordereddict, pythonic::dispatch::shr__string__graph};
    t[4] = {pythonic::dispatch::shr__bool__none, pythonic::dispatch::shr__bool__int, pythonic::dispatch::shr__bool__float, pythonic::dispatch::shr__bool__string, pythonic::dispatch::shr__bool__bool, pythonic::dispatch::shr__bool__double, pythonic::dispatch::shr__bool__long, pythonic::dispatch::shr__bool__long_long, pythonic::dispatch::shr__bool__long_double, pythonic::dispatch::shr__bool__uint, pythonic::dispatch::shr__bool__ulong, pythonic::dispatch::shr__bool__ulong_long, pythonic::dispatch::shr__bool__list, pythonic::dispatch::shr__bool__set, pythonic::dispatch::shr__bool__dict, pythonic::dispatch::shr__bool__orderedset, pythonic::dispatch::shr__bool__ordereddict, pythonic::dispatch::shr__bool__graph};
    t[5] = {pythonic::dispatch::shr__double__none, pythonic::dispatch::shr__double__int, pythonic::dispatch::shr__double__float, pythonic::dispatch::shr__double__string, pythonic::dispatch::shr__double__bool, pythonic::dispatch::shr__double__double, pythonic::dispatch::shr__double__long, pythonic::dispatch::shr__double__long_long, pythonic::dispatch::shr__double__long_double, pythonic::dispatch::shr__double__uint, pythonic::dispatch::shr__double__ulong, pythonic::dispatch::shr__double__ulong_long, pythonic::dispatch::shr__double__list, pythonic::dispatch::shr__double__set, pythonic::dispatch::shr__double__dict, pythonic::dispatch::shr__double__orderedset, pythonic::dispatch::shr__double__ordereddict, pythonic::dispatch::shr__double__graph};
    t[6] = {pythonic::dispatch::shr__long__none, pythonic::dispatch::shr__long__int, pythonic::dispatch::shr__long__float, pythonic::dispatch::shr__long__string, pythonic::dispatch::shr__long__bool, pythonic::dispatch::shr__long__double, pythonic::dispatch::shr__long__long, pythonic::dispatch::shr__long__long_long, pythonic::dispatch::shr__long__long_double, pythonic::dispatch::shr__long__uint, pythonic::dispatch::shr__long__ulong, pythonic::dispatch::shr__long__ulong_long, pythonic::dispatch::shr__long__list, pythonic::dispatch::shr__long__set, pythonic::dispatch::shr__long__dict, pythonic::dispatch::shr__long__orderedset, pythonic::dispatch::shr__long__ordereddict, pythonic::dispatch::shr__long__graph};
    t[7] = {pythonic::dispatch::shr__long_long__none, pythonic::dispatch::shr__long_long__int, pythonic::dispatch::shr__long_long__float, pythonic::dispatch::shr__long_long__string, pythonic::dispatch::shr__long_long__bool, pythonic::dispatch::shr__long_long__double, pythonic::dispatch::shr__long_long__long, pythonic::dispatch::shr__long_long__long_long, pythonic::dispatch::shr__long_long__long_double, pythonic::dispatch::shr__long_long__uint, pythonic::dispatch::shr__long_long__ulong, pythonic::dispatch::shr__long_long__ulong_long, pythonic::dispatch::shr__long_long__list, pythonic::dispatch::shr__long_long__set, pythonic::dispatch::shr__long_long__dict, pythonic::dispatch::shr__long_long__orderedset, pythonic::dispatch::shr__long_long__ordereddict, pythonic::dispatch::shr__long_long__graph};
    t[8] = {pythonic::dispatch::shr__long_double__none, pythonic::dispatch::shr__long_double__int, pythonic::dispatch::shr__long_double__float, pythonic::dispatch::shr__long_double__string, pythonic::dispatch::shr__long_double__bool, pythonic::dispatch::shr__long_double__double, pythonic::dispatch::shr__long_double__long, pythonic::dispatch::shr__long_double__long_long, pythonic::dispatch::shr__long_double__long_double, pythonic::dispatch::shr__long_double__uint, pythonic::dispatch::shr__long_double__ulong, pythonic::dispatch::shr__long_double__ulong_long, pythonic::dispatch::shr__long_double__list, pythonic::dispatch::shr__long_double__set, pythonic::dispatch::shr__long_double__dict, pythonic::dispatch::shr__long_double__orderedset, pythonic::dispatch::shr__long_double__ordereddict, pythonic::dispatch::shr__long_double__graph};
    t[9] = {pythonic::dispatch::shr__uint__none, pythonic::dispatch::shr__uint__int, pythonic::dispatch::shr__uint__float, pythonic::dispatch::shr__uint__string, pythonic::dispatch::shr__uint__bool, pythonic::dispatch::shr__uint__double, pythonic::dispatch::shr__uint__long, pythonic::dispatch::shr__uint__long_long, pythonic::dispatch::shr__uint__long_double, pythonic::dispatch::shr__uint__uint, pythonic::dispatch::shr__uint__ulong, pythonic::dispatch::shr__uint__ulong_long, pythonic::dispatch::shr__uint__list, pythonic::dispatch::shr__uint__set, pythonic::dispatch::shr__uint__dict, pythonic::dispatch::shr__uint__orderedset, pythonic::dispatch::shr__uint__ordereddict, pythonic::dispatch::shr__uint__graph};
    t[10] = {pythonic::dispatch::shr__ulong__none, pythonic::dispatch::shr__ulong__int, pythonic::dispatch::shr__ulong__float, pythonic::dispatch::shr__ulong__string, pythonic::dispatch::shr__ulong__bool, pythonic::dispatch::shr__ulong__double, pythonic::dispatch::shr__ulong__long, pythonic::dispatch::shr__ulong__long_long, pythonic::dispatch::shr__ulong__long_double, pythonic::dispatch::shr__ulong__uint, pythonic::dispatch::shr__ulong__ulong, pythonic::dispatch::shr__ulong__ulong_long, pythonic::dispatch::shr__ulong__list, pythonic::dispatch::shr__ulong__set, pythonic::dispatch::shr__ulong__dict, pythonic::dispatch::shr__ulong__orderedset, pythonic::dispatch::shr__ulong__ordereddict, pythonic::dispatch::shr__ulong__graph};
    t[11] = {pythonic::dispatch::shr__ulong_long__none, pythonic::dispatch::shr__ulong_long__int, pythonic::dispatch::shr__ulong_long__float, pythonic::dispatch::shr__ulong_long__string, pythonic::dispatch::shr__ulong_long__bool, pythonic::dispatch::shr__ulong_long__double, pythonic::dispatch::shr__ulong_long__long, pythonic::dispatch::shr__ulong_long__long_long, pythonic::dispatch::shr__ulong_long__long_double, pythonic::dispatch::shr__ulong_long__uint, pythonic::dispatch::shr__ulong_long__ulong, pythonic::dispatch::shr__ulong_long__ulong_long, pythonic::dispatch::shr__ulong_long__list, pythonic::dispatch::shr__ulong_long__set, pythonic::dispatch::shr__ulong_long__dict, pythonic::dispatch::shr__ulong_long__orderedset, pythonic::dispatch::shr__ulong_long__ordereddict, pythonic::dispatch::shr__ulong_long__graph};
    t[12] = {pythonic::dispatch::shr__list__none, pythonic::dispatch::shr__list__int, pythonic::dispatch::shr__list__float, pythonic::dispatch::shr__list__string, pythonic::dispatch::shr__list__bool, pythonic::dispatch::shr__list__double, pythonic::dispatch::shr__list__long, pythonic::dispatch::shr__list__long_long, pythonic::dispatch::shr__list__long_double, pythonic::dispatch::shr__list__uint, pythonic::dispatch::shr__list__ulong, pythonic::dispatch::shr__list__ulong_long, pythonic::dispatch::shr__list__list, pythonic::dispatch::shr__list__set, pythonic::dispatch::shr__list__dict, pythonic::dispatch::shr__list__orderedset, pythonic::dispatch::shr__list__ordereddict, pythonic::dispatch::shr__list__graph};
    t[13] = {pythonic::dispatch::shr__set__none, pythonic::dispatch::shr__set__int, pythonic::dispatch::shr__set__float, pythonic::dispatch::shr__set__string, pythonic::dispatch::shr__set__bool, pythonic::dispatch::shr__set__double, pythonic::dispatch::shr__set__long, pythonic::dispatch::shr__set__long_long, pythonic::dispatch::shr__set__long_double, pythonic::dispatch::shr__set__uint, pythonic::dispatch::shr__set__ulong, pythonic::dispatch::shr__set__ulong_long, pythonic::dispatch::shr__set__list, pythonic::dispatch::shr__set__set, pythonic::dispatch::shr__set__dict, pythonic::dispatch::shr__set__orderedset, pythonic::dispatch::shr__set__ordereddict, pythonic::dispatch::shr__set__graph};
    t[14] = {pythonic::dispatch::shr__dict__none, pythonic::dispatch::shr__dict__int, pythonic::dispatch::shr__dict__float, pythonic::dispatch::shr__dict__string, pythonic::dispatch::shr__dict__bool, pythonic::dispatch::shr__dict__double, pythonic::dispatch::shr__dict__long, pythonic::dispatch::shr__dict__long_long, pythonic::dispatch::shr__dict__long_double, pythonic::dispatch::shr__dict__uint, pythonic::dispatch::shr__dict__ulong, pythonic::dispatch::shr__dict__ulong_long, pythonic::dispatch::shr__dict__list, pythonic::dispatch::shr__dict__set, pythonic::dispatch::shr__dict__dict, pythonic::dispatch::shr__dict__orderedset, pythonic::dispatch::shr__dict__ordereddict, pythonic::dispatch::shr__dict__graph};
    t[15] = {pythonic::dispatch::shr__orderedset__none, pythonic::dispatch::shr__orderedset__int, pythonic::dispatch::shr__orderedset__float, pythonic::dispatch::shr__orderedset__string, pythonic::dispatch::shr__orderedset__bool, pythonic::dispatch::shr__orderedset__double, pythonic::dispatch::shr__orderedset__long, pythonic::dispatch::shr__orderedset__long_long, pythonic::dispatch::shr__orderedset__long_double, pythonic::dispatch::shr__orderedset__uint, pythonic::dispatch::shr__orderedset__ulong, pythonic::dispatch::shr__orderedset__ulong_long, pythonic::dispatch::shr__orderedset__list, pythonic::dispatch::shr__orderedset__set, pythonic::dispatch::shr__orderedset__dict, pythonic::dispatch::shr__orderedset__orderedset, pythonic::dispatch::shr__orderedset__ordereddict, pythonic::dispatch::shr__orderedset__graph};
    t[16] = {pythonic::dispatch::shr__ordereddict__none, pythonic::dispatch::shr__ordereddict__int, pythonic::dispatch::shr__ordereddict__float, pythonic::dispatch::shr__ordereddict__string, pythonic::dispatch::shr__ordereddict__bool, pythonic::dispatch::shr__ordereddict__double, pythonic::dispatch::shr__ordereddict__long, pythonic::dispatch::shr__ordereddict__long_long, pythonic::dispatch::shr__ordereddict__long_double, pythonic::dispatch::shr__ordereddict__uint, pythonic::dispatch::shr__ordereddict__ulong, pythonic::dispatch::shr__ordereddict__ulong_long, pythonic::dispatch::shr__ordereddict__list, pythonic::dispatch::shr__ordereddict__set, pythonic::dispatch::shr__ordereddict__dict, pythonic::dispatch::shr__ordereddict__orderedset, pythonic::dispatch::shr__ordereddict__ordereddict, pythonic::dispatch::shr__ordereddict__graph};
    t[17] = {pythonic::dispatch::shr__graph__none, pythonic::dispatch::shr__graph__int, pythonic::dispatch::shr__graph__float, pythonic::dispatch::shr__graph__string, pythonic::dispatch::shr__graph__bool, pythonic::dispatch::shr__graph__double, pythonic::dispatch::shr__graph__long, pythonic::dispatch::shr__graph__long_long, pythonic::dispatch::shr__graph__long_double, pythonic::dispatch::shr__graph__uint, pythonic::dispatch::shr__graph__ulong, pythonic::dispatch::shr__graph__ulong_long, pythonic::dispatch::shr__graph__list, pythonic::dispatch::shr__graph__set, pythonic::dispatch::shr__graph__dict, pythonic::dispatch::shr__graph__orderedset, pythonic::dispatch::shr__graph__ordereddict, pythonic::dispatch::shr__graph__graph};
    return t;
}();

// OpTable initialization for LogicalAnd
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::LogicalAnd>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::land__none__none, pythonic::dispatch::land__none__int, pythonic::dispatch::land__none__float, pythonic::dispatch::land__none__string, pythonic::dispatch::land__none__bool, pythonic::dispatch::land__none__double, pythonic::dispatch::land__none__long, pythonic::dispatch::land__none__long_long, pythonic::dispatch::land__none__long_double, pythonic::dispatch::land__none__uint, pythonic::dispatch::land__none__ulong, pythonic::dispatch::land__none__ulong_long, pythonic::dispatch::land__none__list, pythonic::dispatch::land__none__set, pythonic::dispatch::land__none__dict, pythonic::dispatch::land__none__orderedset, pythonic::dispatch::land__none__ordereddict, pythonic::dispatch::land__none__graph};
    t[1] = {pythonic::dispatch::land__int__none, pythonic::dispatch::land__int__int, pythonic::dispatch::land__int__float, pythonic::dispatch::land__int__string, pythonic::dispatch::land__int__bool, pythonic::dispatch::land__int__double, pythonic::dispatch::land__int__long, pythonic::dispatch::land__int__long_long, pythonic::dispatch::land__int__long_double, pythonic::dispatch::land__int__uint, pythonic::dispatch::land__int__ulong, pythonic::dispatch::land__int__ulong_long, pythonic::dispatch::land__int__list, pythonic::dispatch::land__int__set, pythonic::dispatch::land__int__dict, pythonic::dispatch::land__int__orderedset, pythonic::dispatch::land__int__ordereddict, pythonic::dispatch::land__int__graph};
    t[2] = {pythonic::dispatch::land__float__none, pythonic::dispatch::land__float__int, pythonic::dispatch::land__float__float, pythonic::dispatch::land__float__string, pythonic::dispatch::land__float__bool, pythonic::dispatch::land__float__double, pythonic::dispatch::land__float__long, pythonic::dispatch::land__float__long_long, pythonic::dispatch::land__float__long_double, pythonic::dispatch::land__float__uint, pythonic::dispatch::land__float__ulong, pythonic::dispatch::land__float__ulong_long, pythonic::dispatch::land__float__list, pythonic::dispatch::land__float__set, pythonic::dispatch::land__float__dict, pythonic::dispatch::land__float__orderedset, pythonic::dispatch::land__float__ordereddict, pythonic::dispatch::land__float__graph};
    t[3] = {pythonic::dispatch::land__string__none, pythonic::dispatch::land__string__int, pythonic::dispatch::land__string__float, pythonic::dispatch::land__string__string, pythonic::dispatch::land__string__bool, pythonic::dispatch::land__string__double, pythonic::dispatch::land__string__long, pythonic::dispatch::land__string__long_long, pythonic::dispatch::land__string__long_double, pythonic::dispatch::land__string__uint, pythonic::dispatch::land__string__ulong, pythonic::dispatch::land__string__ulong_long, pythonic::dispatch::land__string__list, pythonic::dispatch::land__string__set, pythonic::dispatch::land__string__dict, pythonic::dispatch::land__string__orderedset, pythonic::dispatch::land__string__ordereddict, pythonic::dispatch::land__string__graph};
    t[4] = {pythonic::dispatch::land__bool__none, pythonic::dispatch::land__bool__int, pythonic::dispatch::land__bool__float, pythonic::dispatch::land__bool__string, pythonic::dispatch::land__bool__bool, pythonic::dispatch::land__bool__double, pythonic::dispatch::land__bool__long, pythonic::dispatch::land__bool__long_long, pythonic::dispatch::land__bool__long_double, pythonic::dispatch::land__bool__uint, pythonic::dispatch::land__bool__ulong, pythonic::dispatch::land__bool__ulong_long, pythonic::dispatch::land__bool__list, pythonic::dispatch::land__bool__set, pythonic::dispatch::land__bool__dict, pythonic::dispatch::land__bool__orderedset, pythonic::dispatch::land__bool__ordereddict, pythonic::dispatch::land__bool__graph};
    t[5] = {pythonic::dispatch::land__double__none, pythonic::dispatch::land__double__int, pythonic::dispatch::land__double__float, pythonic::dispatch::land__double__string, pythonic::dispatch::land__double__bool, pythonic::dispatch::land__double__double, pythonic::dispatch::land__double__long, pythonic::dispatch::land__double__long_long, pythonic::dispatch::land__double__long_double, pythonic::dispatch::land__double__uint, pythonic::dispatch::land__double__ulong, pythonic::dispatch::land__double__ulong_long, pythonic::dispatch::land__double__list, pythonic::dispatch::land__double__set, pythonic::dispatch::land__double__dict, pythonic::dispatch::land__double__orderedset, pythonic::dispatch::land__double__ordereddict, pythonic::dispatch::land__double__graph};
    t[6] = {pythonic::dispatch::land__long__none, pythonic::dispatch::land__long__int, pythonic::dispatch::land__long__float, pythonic::dispatch::land__long__string, pythonic::dispatch::land__long__bool, pythonic::dispatch::land__long__double, pythonic::dispatch::land__long__long, pythonic::dispatch::land__long__long_long, pythonic::dispatch::land__long__long_double, pythonic::dispatch::land__long__uint, pythonic::dispatch::land__long__ulong, pythonic::dispatch::land__long__ulong_long, pythonic::dispatch::land__long__list, pythonic::dispatch::land__long__set, pythonic::dispatch::land__long__dict, pythonic::dispatch::land__long__orderedset, pythonic::dispatch::land__long__ordereddict, pythonic::dispatch::land__long__graph};
    t[7] = {pythonic::dispatch::land__long_long__none, pythonic::dispatch::land__long_long__int, pythonic::dispatch::land__long_long__float, pythonic::dispatch::land__long_long__string, pythonic::dispatch::land__long_long__bool, pythonic::dispatch::land__long_long__double, pythonic::dispatch::land__long_long__long, pythonic::dispatch::land__long_long__long_long, pythonic::dispatch::land__long_long__long_double, pythonic::dispatch::land__long_long__uint, pythonic::dispatch::land__long_long__ulong, pythonic::dispatch::land__long_long__ulong_long, pythonic::dispatch::land__long_long__list, pythonic::dispatch::land__long_long__set, pythonic::dispatch::land__long_long__dict, pythonic::dispatch::land__long_long__orderedset, pythonic::dispatch::land__long_long__ordereddict, pythonic::dispatch::land__long_long__graph};
    t[8] = {pythonic::dispatch::land__long_double__none, pythonic::dispatch::land__long_double__int, pythonic::dispatch::land__long_double__float, pythonic::dispatch::land__long_double__string, pythonic::dispatch::land__long_double__bool, pythonic::dispatch::land__long_double__double, pythonic::dispatch::land__long_double__long, pythonic::dispatch::land__long_double__long_long, pythonic::dispatch::land__long_double__long_double, pythonic::dispatch::land__long_double__uint, pythonic::dispatch::land__long_double__ulong, pythonic::dispatch::land__long_double__ulong_long, pythonic::dispatch::land__long_double__list, pythonic::dispatch::land__long_double__set, pythonic::dispatch::land__long_double__dict, pythonic::dispatch::land__long_double__orderedset, pythonic::dispatch::land__long_double__ordereddict, pythonic::dispatch::land__long_double__graph};
    t[9] = {pythonic::dispatch::land__uint__none, pythonic::dispatch::land__uint__int, pythonic::dispatch::land__uint__float, pythonic::dispatch::land__uint__string, pythonic::dispatch::land__uint__bool, pythonic::dispatch::land__uint__double, pythonic::dispatch::land__uint__long, pythonic::dispatch::land__uint__long_long, pythonic::dispatch::land__uint__long_double, pythonic::dispatch::land__uint__uint, pythonic::dispatch::land__uint__ulong, pythonic::dispatch::land__uint__ulong_long, pythonic::dispatch::land__uint__list, pythonic::dispatch::land__uint__set, pythonic::dispatch::land__uint__dict, pythonic::dispatch::land__uint__orderedset, pythonic::dispatch::land__uint__ordereddict, pythonic::dispatch::land__uint__graph};
    t[10] = {pythonic::dispatch::land__ulong__none, pythonic::dispatch::land__ulong__int, pythonic::dispatch::land__ulong__float, pythonic::dispatch::land__ulong__string, pythonic::dispatch::land__ulong__bool, pythonic::dispatch::land__ulong__double, pythonic::dispatch::land__ulong__long, pythonic::dispatch::land__ulong__long_long, pythonic::dispatch::land__ulong__long_double, pythonic::dispatch::land__ulong__uint, pythonic::dispatch::land__ulong__ulong, pythonic::dispatch::land__ulong__ulong_long, pythonic::dispatch::land__ulong__list, pythonic::dispatch::land__ulong__set, pythonic::dispatch::land__ulong__dict, pythonic::dispatch::land__ulong__orderedset, pythonic::dispatch::land__ulong__ordereddict, pythonic::dispatch::land__ulong__graph};
    t[11] = {pythonic::dispatch::land__ulong_long__none, pythonic::dispatch::land__ulong_long__int, pythonic::dispatch::land__ulong_long__float, pythonic::dispatch::land__ulong_long__string, pythonic::dispatch::land__ulong_long__bool, pythonic::dispatch::land__ulong_long__double, pythonic::dispatch::land__ulong_long__long, pythonic::dispatch::land__ulong_long__long_long, pythonic::dispatch::land__ulong_long__long_double, pythonic::dispatch::land__ulong_long__uint, pythonic::dispatch::land__ulong_long__ulong, pythonic::dispatch::land__ulong_long__ulong_long, pythonic::dispatch::land__ulong_long__list, pythonic::dispatch::land__ulong_long__set, pythonic::dispatch::land__ulong_long__dict, pythonic::dispatch::land__ulong_long__orderedset, pythonic::dispatch::land__ulong_long__ordereddict, pythonic::dispatch::land__ulong_long__graph};
    t[12] = {pythonic::dispatch::land__list__none, pythonic::dispatch::land__list__int, pythonic::dispatch::land__list__float, pythonic::dispatch::land__list__string, pythonic::dispatch::land__list__bool, pythonic::dispatch::land__list__double, pythonic::dispatch::land__list__long, pythonic::dispatch::land__list__long_long, pythonic::dispatch::land__list__long_double, pythonic::dispatch::land__list__uint, pythonic::dispatch::land__list__ulong, pythonic::dispatch::land__list__ulong_long, pythonic::dispatch::land__list__list, pythonic::dispatch::land__list__set, pythonic::dispatch::land__list__dict, pythonic::dispatch::land__list__orderedset, pythonic::dispatch::land__list__ordereddict, pythonic::dispatch::land__list__graph};
    t[13] = {pythonic::dispatch::land__set__none, pythonic::dispatch::land__set__int, pythonic::dispatch::land__set__float, pythonic::dispatch::land__set__string, pythonic::dispatch::land__set__bool, pythonic::dispatch::land__set__double, pythonic::dispatch::land__set__long, pythonic::dispatch::land__set__long_long, pythonic::dispatch::land__set__long_double, pythonic::dispatch::land__set__uint, pythonic::dispatch::land__set__ulong, pythonic::dispatch::land__set__ulong_long, pythonic::dispatch::land__set__list, pythonic::dispatch::land__set__set, pythonic::dispatch::land__set__dict, pythonic::dispatch::land__set__orderedset, pythonic::dispatch::land__set__ordereddict, pythonic::dispatch::land__set__graph};
    t[14] = {pythonic::dispatch::land__dict__none, pythonic::dispatch::land__dict__int, pythonic::dispatch::land__dict__float, pythonic::dispatch::land__dict__string, pythonic::dispatch::land__dict__bool, pythonic::dispatch::land__dict__double, pythonic::dispatch::land__dict__long, pythonic::dispatch::land__dict__long_long, pythonic::dispatch::land__dict__long_double, pythonic::dispatch::land__dict__uint, pythonic::dispatch::land__dict__ulong, pythonic::dispatch::land__dict__ulong_long, pythonic::dispatch::land__dict__list, pythonic::dispatch::land__dict__set, pythonic::dispatch::land__dict__dict, pythonic::dispatch::land__dict__orderedset, pythonic::dispatch::land__dict__ordereddict, pythonic::dispatch::land__dict__graph};
    t[15] = {pythonic::dispatch::land__orderedset__none, pythonic::dispatch::land__orderedset__int, pythonic::dispatch::land__orderedset__float, pythonic::dispatch::land__orderedset__string, pythonic::dispatch::land__orderedset__bool, pythonic::dispatch::land__orderedset__double, pythonic::dispatch::land__orderedset__long, pythonic::dispatch::land__orderedset__long_long, pythonic::dispatch::land__orderedset__long_double, pythonic::dispatch::land__orderedset__uint, pythonic::dispatch::land__orderedset__ulong, pythonic::dispatch::land__orderedset__ulong_long, pythonic::dispatch::land__orderedset__list, pythonic::dispatch::land__orderedset__set, pythonic::dispatch::land__orderedset__dict, pythonic::dispatch::land__orderedset__orderedset, pythonic::dispatch::land__orderedset__ordereddict, pythonic::dispatch::land__orderedset__graph};
    t[16] = {pythonic::dispatch::land__ordereddict__none, pythonic::dispatch::land__ordereddict__int, pythonic::dispatch::land__ordereddict__float, pythonic::dispatch::land__ordereddict__string, pythonic::dispatch::land__ordereddict__bool, pythonic::dispatch::land__ordereddict__double, pythonic::dispatch::land__ordereddict__long, pythonic::dispatch::land__ordereddict__long_long, pythonic::dispatch::land__ordereddict__long_double, pythonic::dispatch::land__ordereddict__uint, pythonic::dispatch::land__ordereddict__ulong, pythonic::dispatch::land__ordereddict__ulong_long, pythonic::dispatch::land__ordereddict__list, pythonic::dispatch::land__ordereddict__set, pythonic::dispatch::land__ordereddict__dict, pythonic::dispatch::land__ordereddict__orderedset, pythonic::dispatch::land__ordereddict__ordereddict, pythonic::dispatch::land__ordereddict__graph};
    t[17] = {pythonic::dispatch::land__graph__none, pythonic::dispatch::land__graph__int, pythonic::dispatch::land__graph__float, pythonic::dispatch::land__graph__string, pythonic::dispatch::land__graph__bool, pythonic::dispatch::land__graph__double, pythonic::dispatch::land__graph__long, pythonic::dispatch::land__graph__long_long, pythonic::dispatch::land__graph__long_double, pythonic::dispatch::land__graph__uint, pythonic::dispatch::land__graph__ulong, pythonic::dispatch::land__graph__ulong_long, pythonic::dispatch::land__graph__list, pythonic::dispatch::land__graph__set, pythonic::dispatch::land__graph__dict, pythonic::dispatch::land__graph__orderedset, pythonic::dispatch::land__graph__ordereddict, pythonic::dispatch::land__graph__graph};
    return t;
}();

// OpTable initialization for LogicalOr
template <>
const std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> pythonic::dispatch::OpTable<pythonic::dispatch::LogicalOr>::table = []() {
    std::array<std::array<pythonic::dispatch::BinaryOpFunc, pythonic::dispatch::TypeTagCount>, pythonic::dispatch::TypeTagCount> t{};
    t[0] = {pythonic::dispatch::lor__none__none, pythonic::dispatch::lor__none__int, pythonic::dispatch::lor__none__float, pythonic::dispatch::lor__none__string, pythonic::dispatch::lor__none__bool, pythonic::dispatch::lor__none__double, pythonic::dispatch::lor__none__long, pythonic::dispatch::lor__none__long_long, pythonic::dispatch::lor__none__long_double, pythonic::dispatch::lor__none__uint, pythonic::dispatch::lor__none__ulong, pythonic::dispatch::lor__none__ulong_long, pythonic::dispatch::lor__none__list, pythonic::dispatch::lor__none__set, pythonic::dispatch::lor__none__dict, pythonic::dispatch::lor__none__orderedset, pythonic::dispatch::lor__none__ordereddict, pythonic::dispatch::lor__none__graph};
    t[1] = {pythonic::dispatch::lor__int__none, pythonic::dispatch::lor__int__int, pythonic::dispatch::lor__int__float, pythonic::dispatch::lor__int__string, pythonic::dispatch::lor__int__bool, pythonic::dispatch::lor__int__double, pythonic::dispatch::lor__int__long, pythonic::dispatch::lor__int__long_long, pythonic::dispatch::lor__int__long_double, pythonic::dispatch::lor__int__uint, pythonic::dispatch::lor__int__ulong, pythonic::dispatch::lor__int__ulong_long, pythonic::dispatch::lor__int__list, pythonic::dispatch::lor__int__set, pythonic::dispatch::lor__int__dict, pythonic::dispatch::lor__int__orderedset, pythonic::dispatch::lor__int__ordereddict, pythonic::dispatch::lor__int__graph};
    t[2] = {pythonic::dispatch::lor__float__none, pythonic::dispatch::lor__float__int, pythonic::dispatch::lor__float__float, pythonic::dispatch::lor__float__string, pythonic::dispatch::lor__float__bool, pythonic::dispatch::lor__float__double, pythonic::dispatch::lor__float__long, pythonic::dispatch::lor__float__long_long, pythonic::dispatch::lor__float__long_double, pythonic::dispatch::lor__float__uint, pythonic::dispatch::lor__float__ulong, pythonic::dispatch::lor__float__ulong_long, pythonic::dispatch::lor__float__list, pythonic::dispatch::lor__float__set, pythonic::dispatch::lor__float__dict, pythonic::dispatch::lor__float__orderedset, pythonic::dispatch::lor__float__ordereddict, pythonic::dispatch::lor__float__graph};
    t[3] = {pythonic::dispatch::lor__string__none, pythonic::dispatch::lor__string__int, pythonic::dispatch::lor__string__float, pythonic::dispatch::lor__string__string, pythonic::dispatch::lor__string__bool, pythonic::dispatch::lor__string__double, pythonic::dispatch::lor__string__long, pythonic::dispatch::lor__string__long_long, pythonic::dispatch::lor__string__long_double, pythonic::dispatch::lor__string__uint, pythonic::dispatch::lor__string__ulong, pythonic::dispatch::lor__string__ulong_long, pythonic::dispatch::lor__string__list, pythonic::dispatch::lor__string__set, pythonic::dispatch::lor__string__dict, pythonic::dispatch::lor__string__orderedset, pythonic::dispatch::lor__string__ordereddict, pythonic::dispatch::lor__string__graph};
    t[4] = {pythonic::dispatch::lor__bool__none, pythonic::dispatch::lor__bool__int, pythonic::dispatch::lor__bool__float, pythonic::dispatch::lor__bool__string, pythonic::dispatch::lor__bool__bool, pythonic::dispatch::lor__bool__double, pythonic::dispatch::lor__bool__long, pythonic::dispatch::lor__bool__long_long, pythonic::dispatch::lor__bool__long_double, pythonic::dispatch::lor__bool__uint, pythonic::dispatch::lor__bool__ulong, pythonic::dispatch::lor__bool__ulong_long, pythonic::dispatch::lor__bool__list, pythonic::dispatch::lor__bool__set, pythonic::dispatch::lor__bool__dict, pythonic::dispatch::lor__bool__orderedset, pythonic::dispatch::lor__bool__ordereddict, pythonic::dispatch::lor__bool__graph};
    t[5] = {pythonic::dispatch::lor__double__none, pythonic::dispatch::lor__double__int, pythonic::dispatch::lor__double__float, pythonic::dispatch::lor__double__string, pythonic::dispatch::lor__double__bool, pythonic::dispatch::lor__double__double, pythonic::dispatch::lor__double__long, pythonic::dispatch::lor__double__long_long, pythonic::dispatch::lor__double__long_double, pythonic::dispatch::lor__double__uint, pythonic::dispatch::lor__double__ulong, pythonic::dispatch::lor__double__ulong_long, pythonic::dispatch::lor__double__list, pythonic::dispatch::lor__double__set, pythonic::dispatch::lor__double__dict, pythonic::dispatch::lor__double__orderedset, pythonic::dispatch::lor__double__ordereddict, pythonic::dispatch::lor__double__graph};
    t[6] = {pythonic::dispatch::lor__long__none, pythonic::dispatch::lor__long__int, pythonic::dispatch::lor__long__float, pythonic::dispatch::lor__long__string, pythonic::dispatch::lor__long__bool, pythonic::dispatch::lor__long__double, pythonic::dispatch::lor__long__long, pythonic::dispatch::lor__long__long_long, pythonic::dispatch::lor__long__long_double, pythonic::dispatch::lor__long__uint, pythonic::dispatch::lor__long__ulong, pythonic::dispatch::lor__long__ulong_long, pythonic::dispatch::lor__long__list, pythonic::dispatch::lor__long__set, pythonic::dispatch::lor__long__dict, pythonic::dispatch::lor__long__orderedset, pythonic::dispatch::lor__long__ordereddict, pythonic::dispatch::lor__long__graph};
    t[7] = {pythonic::dispatch::lor__long_long__none, pythonic::dispatch::lor__long_long__int, pythonic::dispatch::lor__long_long__float, pythonic::dispatch::lor__long_long__string, pythonic::dispatch::lor__long_long__bool, pythonic::dispatch::lor__long_long__double, pythonic::dispatch::lor__long_long__long, pythonic::dispatch::lor__long_long__long_long, pythonic::dispatch::lor__long_long__long_double, pythonic::dispatch::lor__long_long__uint, pythonic::dispatch::lor__long_long__ulong, pythonic::dispatch::lor__long_long__ulong_long, pythonic::dispatch::lor__long_long__list, pythonic::dispatch::lor__long_long__set, pythonic::dispatch::lor__long_long__dict, pythonic::dispatch::lor__long_long__orderedset, pythonic::dispatch::lor__long_long__ordereddict, pythonic::dispatch::lor__long_long__graph};
    t[8] = {pythonic::dispatch::lor__long_double__none, pythonic::dispatch::lor__long_double__int, pythonic::dispatch::lor__long_double__float, pythonic::dispatch::lor__long_double__string, pythonic::dispatch::lor__long_double__bool, pythonic::dispatch::lor__long_double__double, pythonic::dispatch::lor__long_double__long, pythonic::dispatch::lor__long_double__long_long, pythonic::dispatch::lor__long_double__long_double, pythonic::dispatch::lor__long_double__uint, pythonic::dispatch::lor__long_double__ulong, pythonic::dispatch::lor__long_double__ulong_long, pythonic::dispatch::lor__long_double__list, pythonic::dispatch::lor__long_double__set, pythonic::dispatch::lor__long_double__dict, pythonic::dispatch::lor__long_double__orderedset, pythonic::dispatch::lor__long_double__ordereddict, pythonic::dispatch::lor__long_double__graph};
    t[9] = {pythonic::dispatch::lor__uint__none, pythonic::dispatch::lor__uint__int, pythonic::dispatch::lor__uint__float, pythonic::dispatch::lor__uint__string, pythonic::dispatch::lor__uint__bool, pythonic::dispatch::lor__uint__double, pythonic::dispatch::lor__uint__long, pythonic::dispatch::lor__uint__long_long, pythonic::dispatch::lor__uint__long_double, pythonic::dispatch::lor__uint__uint, pythonic::dispatch::lor__uint__ulong, pythonic::dispatch::lor__uint__ulong_long, pythonic::dispatch::lor__uint__list, pythonic::dispatch::lor__uint__set, pythonic::dispatch::lor__uint__dict, pythonic::dispatch::lor__uint__orderedset, pythonic::dispatch::lor__uint__ordereddict, pythonic::dispatch::lor__uint__graph};
    t[10] = {pythonic::dispatch::lor__ulong__none, pythonic::dispatch::lor__ulong__int, pythonic::dispatch::lor__ulong__float, pythonic::dispatch::lor__ulong__string, pythonic::dispatch::lor__ulong__bool, pythonic::dispatch::lor__ulong__double, pythonic::dispatch::lor__ulong__long, pythonic::dispatch::lor__ulong__long_long, pythonic::dispatch::lor__ulong__long_double, pythonic::dispatch::lor__ulong__uint, pythonic::dispatch::lor__ulong__ulong, pythonic::dispatch::lor__ulong__ulong_long, pythonic::dispatch::lor__ulong__list, pythonic::dispatch::lor__ulong__set, pythonic::dispatch::lor__ulong__dict, pythonic::dispatch::lor__ulong__orderedset, pythonic::dispatch::lor__ulong__ordereddict, pythonic::dispatch::lor__ulong__graph};
    t[11] = {pythonic::dispatch::lor__ulong_long__none, pythonic::dispatch::lor__ulong_long__int, pythonic::dispatch::lor__ulong_long__float, pythonic::dispatch::lor__ulong_long__string, pythonic::dispatch::lor__ulong_long__bool, pythonic::dispatch::lor__ulong_long__double, pythonic::dispatch::lor__ulong_long__long, pythonic::dispatch::lor__ulong_long__long_long, pythonic::dispatch::lor__ulong_long__long_double, pythonic::dispatch::lor__ulong_long__uint, pythonic::dispatch::lor__ulong_long__ulong, pythonic::dispatch::lor__ulong_long__ulong_long, pythonic::dispatch::lor__ulong_long__list, pythonic::dispatch::lor__ulong_long__set, pythonic::dispatch::lor__ulong_long__dict, pythonic::dispatch::lor__ulong_long__orderedset, pythonic::dispatch::lor__ulong_long__ordereddict, pythonic::dispatch::lor__ulong_long__graph};
    t[12] = {pythonic::dispatch::lor__list__none, pythonic::dispatch::lor__list__int, pythonic::dispatch::lor__list__float, pythonic::dispatch::lor__list__string, pythonic::dispatch::lor__list__bool, pythonic::dispatch::lor__list__double, pythonic::dispatch::lor__list__long, pythonic::dispatch::lor__list__long_long, pythonic::dispatch::lor__list__long_double, pythonic::dispatch::lor__list__uint, pythonic::dispatch::lor__list__ulong, pythonic::dispatch::lor__list__ulong_long, pythonic::dispatch::lor__list__list, pythonic::dispatch::lor__list__set, pythonic::dispatch::lor__list__dict, pythonic::dispatch::lor__list__orderedset, pythonic::dispatch::lor__list__ordereddict, pythonic::dispatch::lor__list__graph};
    t[13] = {pythonic::dispatch::lor__set__none, pythonic::dispatch::lor__set__int, pythonic::dispatch::lor__set__float, pythonic::dispatch::lor__set__string, pythonic::dispatch::lor__set__bool, pythonic::dispatch::lor__set__double, pythonic::dispatch::lor__set__long, pythonic::dispatch::lor__set__long_long, pythonic::dispatch::lor__set__long_double, pythonic::dispatch::lor__set__uint, pythonic::dispatch::lor__set__ulong, pythonic::dispatch::lor__set__ulong_long, pythonic::dispatch::lor__set__list, pythonic::dispatch::lor__set__set, pythonic::dispatch::lor__set__dict, pythonic::dispatch::lor__set__orderedset, pythonic::dispatch::lor__set__ordereddict, pythonic::dispatch::lor__set__graph};
    t[14] = {pythonic::dispatch::lor__dict__none, pythonic::dispatch::lor__dict__int, pythonic::dispatch::lor__dict__float, pythonic::dispatch::lor__dict__string, pythonic::dispatch::lor__dict__bool, pythonic::dispatch::lor__dict__double, pythonic::dispatch::lor__dict__long, pythonic::dispatch::lor__dict__long_long, pythonic::dispatch::lor__dict__long_double, pythonic::dispatch::lor__dict__uint, pythonic::dispatch::lor__dict__ulong, pythonic::dispatch::lor__dict__ulong_long, pythonic::dispatch::lor__dict__list, pythonic::dispatch::lor__dict__set, pythonic::dispatch::lor__dict__dict, pythonic::dispatch::lor__dict__orderedset, pythonic::dispatch::lor__dict__ordereddict, pythonic::dispatch::lor__dict__graph};
    t[15] = {pythonic::dispatch::lor__orderedset__none, pythonic::dispatch::lor__orderedset__int, pythonic::dispatch::lor__orderedset__float, pythonic::dispatch::lor__orderedset__string, pythonic::dispatch::lor__orderedset__bool, pythonic::dispatch::lor__orderedset__double, pythonic::dispatch::lor__orderedset__long, pythonic::dispatch::lor__orderedset__long_long, pythonic::dispatch::lor__orderedset__long_double, pythonic::dispatch::lor__orderedset__uint, pythonic::dispatch::lor__orderedset__ulong, pythonic::dispatch::lor__orderedset__ulong_long, pythonic::dispatch::lor__orderedset__list, pythonic::dispatch::lor__orderedset__set, pythonic::dispatch::lor__orderedset__dict, pythonic::dispatch::lor__orderedset__orderedset, pythonic::dispatch::lor__orderedset__ordereddict, pythonic::dispatch::lor__orderedset__graph};
    t[16] = {pythonic::dispatch::lor__ordereddict__none, pythonic::dispatch::lor__ordereddict__int, pythonic::dispatch::lor__ordereddict__float, pythonic::dispatch::lor__ordereddict__string, pythonic::dispatch::lor__ordereddict__bool, pythonic::dispatch::lor__ordereddict__double, pythonic::dispatch::lor__ordereddict__long, pythonic::dispatch::lor__ordereddict__long_long, pythonic::dispatch::lor__ordereddict__long_double, pythonic::dispatch::lor__ordereddict__uint, pythonic::dispatch::lor__ordereddict__ulong, pythonic::dispatch::lor__ordereddict__ulong_long, pythonic::dispatch::lor__ordereddict__list, pythonic::dispatch::lor__ordereddict__set, pythonic::dispatch::lor__ordereddict__dict, pythonic::dispatch::lor__ordereddict__orderedset, pythonic::dispatch::lor__ordereddict__ordereddict, pythonic::dispatch::lor__ordereddict__graph};
    t[17] = {pythonic::dispatch::lor__graph__none, pythonic::dispatch::lor__graph__int, pythonic::dispatch::lor__graph__float, pythonic::dispatch::lor__graph__string, pythonic::dispatch::lor__graph__bool, pythonic::dispatch::lor__graph__double, pythonic::dispatch::lor__graph__long, pythonic::dispatch::lor__graph__long_long, pythonic::dispatch::lor__graph__long_double, pythonic::dispatch::lor__graph__uint, pythonic::dispatch::lor__graph__ulong, pythonic::dispatch::lor__graph__ulong_long, pythonic::dispatch::lor__graph__list, pythonic::dispatch::lor__graph__set, pythonic::dispatch::lor__graph__dict, pythonic::dispatch::lor__graph__orderedset, pythonic::dispatch::lor__graph__ordereddict, pythonic::dispatch::lor__graph__graph};
    return t;
}();

} // namespace dispatch
} // namespace pythonic
